<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6-尚硅谷嵌入式技术之Linux应用层开发 | badboy</title><meta name="author" content="joy"><meta name="copyright" content="joy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="尚硅谷嵌入式技术之Linux应用层开发 （作者：尚硅谷研究院）  版本：V1.0.0 第 1 章 Linux下的C语言开发1.1 GCC、glibc和GNU C的关系1.1.1 GCCGCC全称GNU Compiler Collection，是GNU项目的一部分，主要是一套编译器工具集，支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada、Go和D等。GCC最初作为GN">
<meta property="og:type" content="article">
<meta property="og:title" content="6-尚硅谷嵌入式技术之Linux应用层开发">
<meta property="og:url" content="http://example.com/2024/09/26/6-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B9%8BLinux%E5%BA%94%E7%94%A8%E5%B1%82%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="badboy">
<meta property="og:description" content="尚硅谷嵌入式技术之Linux应用层开发 （作者：尚硅谷研究院）  版本：V1.0.0 第 1 章 Linux下的C语言开发1.1 GCC、glibc和GNU C的关系1.1.1 GCCGCC全称GNU Compiler Collection，是GNU项目的一部分，主要是一套编译器工具集，支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada、Go和D等。GCC最初作为GN">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-09-26T01:48:58.379Z">
<meta property="article:modified_time" content="2024-11-18T08:53:45.404Z">
<meta property="article:author" content="joy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/26/6-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B9%8BLinux%E5%BA%94%E7%94%A8%E5%B1%82%E5%BC%80%E5%8F%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6-尚硅谷嵌入式技术之Linux应用层开发',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-18 16:53:45'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="badboy"><span class="site-name">badboy</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6-尚硅谷嵌入式技术之Linux应用层开发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-26T01:48:58.379Z" title="Created 2024-09-26 09:48:58">2024-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-18T08:53:45.404Z" title="Updated 2024-11-18 16:53:45">2024-11-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6-尚硅谷嵌入式技术之Linux应用层开发"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>尚硅谷嵌入式技术之Linux应用层开发</p>
<p>（作者：尚硅谷研究院）</p>
<p> 版本：V1.0.0</p>
<h1 id="第-1-章-Linux下的C语言开发"><a href="#第-1-章-Linux下的C语言开发" class="headerlink" title="第 1 章 Linux下的C语言开发"></a>第 1 章 <strong>Linux下的C语言开发</strong></h1><h3 id="1-1-GCC、glibc和GNU-C的关系"><a href="#1-1-GCC、glibc和GNU-C的关系" class="headerlink" title="1.1 GCC、glibc和GNU C的关系"></a>1.1 <strong>GCC、glibc和GNU C的关系</strong></h3><h4 id="1-1-1-GCC"><a href="#1-1-1-GCC" class="headerlink" title="1.1.1 GCC"></a>1.1.1 <strong>GCC</strong></h4><p>GCC全称GNU Compiler Collection，是GNU项目的一部分，主要是一套编译器工具集，支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada、Go和D等。GCC最初作为GNU操作系统的官方编译器，用于编译GNU&#x2F;Linux系统和应用程序。它是自由软件，遵循GNU General Public License（GNU GPL）发布。</p>
<p>GCC的主要作用是将源代码编译成机器语言，生成可执行文件或库文件。它也提供了一些优化选项，可以在编译过程中优化代码，提高程序运行的效率。</p>
<h4 id="1-1-2-glibc"><a href="#1-1-2-glibc" class="headerlink" title="1.1.2 glibc"></a>1.1.2 <strong>glibc</strong></h4><p>glibc，全称GNU C Library，是GNU项目的一部分，是C语言标准库的一个实现版本，为C语言提供了标准的API，包括输入输出处理、字符串操作、内存管理等。glibc是Linux系统上最常用的C标准库实现之一，它实现了C标准规定的所有标准库函数以及POSIX（可移植操作系统接口）的扩展。</p>
<p>glibc对于Linux系统和基于Linux的应用程序至关重要，因为它提供了与操作系统交互的基本接口和运行时环境。应用程序通过调用glibc提供的函数来执行文件操作、内存管理、进程控制等操作。</p>
<h4 id="1-1-3-GNU-C"><a href="#1-1-3-GNU-C" class="headerlink" title="1.1.3 GNU C"></a>1.1.3 <strong>GNU C</strong></h4><p>GNU C通常指的是GNU项目的C语言编程标准，特别是在GCC中实现的C语言的扩展和特性。GNU C包括ANSI C（现在通常指C89或C90）的所有特性，以及对C99、C11等更现代C标准的支持和一些GNU特有的扩展。</p>
<h4 id="1-1-4-三者之间的关系"><a href="#1-1-4-三者之间的关系" class="headerlink" title="1.1.4 三者之间的关系"></a>1.1.4 <strong>三者之间的关系</strong></h4><p>GCC使用glibc作为其C语言程序的标准库。当GCC编译C语言程序时，程序中使用的标准库函数（如printf或malloc）是通过glibc提供的。</p>
<p>GNU C是GCC中实现的C语言的一个版本，包含了对C语言标准的支持以及GNU特有的扩展。这些扩展可以在使用GCC编译程序时通过特定的编译选项启用。</p>
<p>总的来说，GCC是编译器，负责将源代码转换为可执行代码；glibc是运行时库，提供程序运行所需的标准函数和操作系统服务的接口；而GNU C则定义了GCC支持的C语言的标准和扩展。</p>
<p>这三者共同构成了GNU&#x2F;Linux系统下开发和运行C语言程序的基础。</p>
<h3 id="1-2-POSIX"><a href="#1-2-POSIX" class="headerlink" title="1.2 POSIX"></a>1.2 <strong>POSIX</strong></h3><p>POSIX，全称为“可移植操作系统接口”（Portable Operating System Interface），是一组标准，用来确保各种不同的操作系统能够提供相同的应用编程接口（API）。这套标准由 IEEE（电气和电子工程师协会）制定，标识符为IEEE 1003。</p>
<p>POSIX标准的主要目的是促进应用软件与多种类型的操作系统之间的兼容性。通过遵循POSIX标准，开发人员可以编写能够在各种不同系统上运行的程序，而无需对程序进行大量修改。这包括Unix、Linux、MacOS以及其他类Unix系统。</p>
<p>主要内容包括：</p>
<p>（1）系统调用和库：定义了操作系统应提供的核心服务，如文件系统操作、进程管理和线程控制。</p>
<p>（2）Shell和工具：规定了标准命令行接口和一系列基本工具，如awk、echo等。</p>
<p>（3）程序接口：包括语言、函数库等接口规范，使程序能够在任何遵循POSIX的操作系统上运行。</p>
<p>POSIX标准的遵循，有助于提高软件的可移植性和灵活性，是现代操作系统开发的重要基石。</p>
<h3 id="1-3-安装IDE编程环境"><a href="#1-3-安装IDE编程环境" class="headerlink" title="1.3 安装IDE编程环境"></a>1.3 <strong>安装IDE编程环境</strong></h3><p>众所周知，没有真正的大佬会在记事本里面写代码，一定会使用一款趁手的开发工具。所以首先我们需要安装一款合适的代码开发工具。C语言开发比较经典的IDE有VC、VS（VC扩展版）、Clion（付费，和IDEA一个公司）等。这里我们选择VS。</p>
<p>#使用命令安装vs</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/桌面$ <span class="built_in">sudo</span> snap install code --classic</span><br></pre></td></tr></table></figure>

<h3 id="1-4-安装gcc"><a href="#1-4-安装gcc" class="headerlink" title="1.4 安装gcc"></a>1.4 <strong>安装gcc</strong></h3><p>GCC是C语言的编译器，VS只是代替了记事本，编译器需要根据自己的操作系统额外安装。执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~$ <span class="built_in">sudo</span> apt install gcc</span><br></pre></td></tr></table></figure>

<p>根据提示输入y即可。</p>
<p>测试使用GCC</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~$ gcc</span><br></pre></td></tr></table></figure>

<p>gcc: fatal error: no input files</p>
<p>compilation terminated.</p>
<h3 id="1-5-设置使用VS"><a href="#1-5-设置使用VS" class="headerlink" title="1.5 设置使用VS"></a>1.5 <strong>设置使用VS</strong></h3><h4 id="1-5-1-启动VSCode"><a href="#1-5-1-启动VSCode" class="headerlink" title="1.5.1 启动VSCode"></a>1.5.1 <strong>启动VSCode</strong></h4><p>终端输入code命令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/桌面$ code</span><br></pre></td></tr></table></figure>

<p>注意：XShell不支持图形化功能，因此，上述命令的执行及下文的所有图形化操作都要在VMWare中完成。</p>
<h4 id="1-5-2-修改为中文（可选）"><a href="#1-5-2-修改为中文（可选）" class="headerlink" title="1.5.2 修改为中文（可选）"></a>1.5.2 <strong>修改为中文（可选）</strong></h4><p>首先第一次进入VS会让用户选择喜欢的页面配置：</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps1_20241001144742980284.jpg"></p>
<p>如果选择不配置，可以直接点击Mark Done。</p>
<p>修改为中文页面，需要自己安装扩展，点击左边的标签栏，输入Chinese，选择中文简体安装。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps2_20241001144908613243.jpg"> </p>
<p>之后点击重启即可。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps3_20241001144953170708.jpg"> </p>
<h4 id="1-5-3-修改页面"><a href="#1-5-3-修改页面" class="headerlink" title="1.5.3 修改页面"></a>1.5.3 <strong>修改页面</strong></h4><p>推荐修改字体大小，调大一点，推荐改20。软件的大小也能调大，按Ctrl和+</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps4_20241001145115615379.jpg" alt="img"> </p>
<p>把页面主题修改为浅色会亮一些。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps5_20241001145244733219.jpg" alt="img"> </p>
<h4 id="1-5-4-安装扩展"><a href="#1-5-4-安装扩展" class="headerlink" title="1.5.4 安装扩展"></a>1.5.4 <strong>安装扩展</strong></h4><p>可以选择自己提前搜索扩展程序，添加对应的扩展。也可以等待系统提示的时候，选择自动安装（推荐）。</p>
<p><strong>1）</strong><em><strong>*在家目录创建一个文件夹，helloworld*</strong></em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~$ <span class="built_in">mkdir</span> helloworld</span><br></pre></td></tr></table></figure>

<p><strong>2）</strong><em><strong>*用VSCode打开*</strong></em></p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps6_20241001145257312867.jpg" alt="img"> </p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps7_20241001145307175397.jpg" alt="img"> </p>
<p>在弹出的窗口中勾选如下，点击“是，我信任此作者”即可。之后启动不再弹窗。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps8_20241001145316395102.jpg" alt="img"> </p>
<p><strong>3）</strong><em><strong>*新建main.c文件*</strong></em></p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps9_20241001145705948566.jpg" alt="img"> </p>
<p>输入文件名。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps10_20241001145716287157.jpg" alt="img"> </p>
<p>之后会有弹窗如下，点击右上角的“创建文件”即可。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps11_20241001145726121123.jpg" alt="img"> </p>
<p><strong>4）</strong><em><strong>*根据提示安装插件*</strong></em></p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps12_20241001145735750131.jpg" alt="img"> </p>
<p><strong>5）</strong><em><strong>*查看扩展列表，此时应有6个扩展*</strong></em></p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps13_20241001145804339259.jpg" alt="img"> </p>
<h3 id="1-6-彻底卸载VS（先别选）"><a href="#1-6-彻底卸载VS（先别选）" class="headerlink" title="1.6 彻底卸载VS（先别选）"></a>1.6 <strong>彻底卸载VS（先别选）</strong></h3><p>要在Ubuntu系统中彻底卸载Visual Studio Code（简称VSCode），请按照以下步骤操作：</p>
<p>使用终端（Terminal）执行卸载命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/桌面$ <span class="built_in">sudo</span> snap remove code <span class="comment"># 对于通过Snap安装的VSCode</span></span><br></pre></td></tr></table></figure>

<p>删除配置文件和缓存数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/桌面$ <span class="built_in">rm</span> -rf ~/.config/Code <span class="comment"># 删除VSCode的用户配置文件</span></span><br><span class="line"></span><br><span class="line">atguigu@ubuntu:~/桌面$ <span class="built_in">rm</span> -rf ~/.vscode <span class="comment"># 删除VSCode的工作区设置和个人扩展</span></span><br></pre></td></tr></table></figure>

<p>请注意，上述命令会删除所有VSCode相关的用户配置和扩展，如果你想要保留这些设置，请自行备份。</p>
<p>确认卸载后，Visual Studio Code应该已经从你的Ubuntu系统中完全移除。不过，这不会影响你在系统其他位置手动创建的VSCode快捷方式或启动器，如有需要，你可以手动删除这些残留项。</p>
<h3 id="1-7-C语言编译过程"><a href="#1-7-C语言编译过程" class="headerlink" title="1.7 C语言编译过程"></a>1.7 <strong>C语言编译过程</strong></h3><p>Linux的C语言开发，一般选择GCC工具链进行编译，通过下面的例子来演示GCC如何使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~$ <span class="built_in">mkdir</span> helloworld</span><br><span class="line"></span><br><span class="line">atguigu@ubuntu:~$ <span class="built_in">cd</span> helloworld</span><br></pre></td></tr></table></figure>

<p>在这个目录中新建两个文件</p>
<p><strong>1）</strong><em><strong>*main*</strong></em><em><strong>*.c*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  say_hello();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）</strong><em><strong>*h*</strong></em><em><strong>*ello.h*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __HELLO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HELLO_H__</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">say_hello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>3）</strong><em><strong>*h*</strong></em><em><strong>*ello.c*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">say_hello</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以采用如下命令编译可执行文件并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc main.c hello.c -o main</span><br><span class="line"></span><br><span class="line">atguigu@ubuntu:~/helloworld$ ./main</span><br></pre></td></tr></table></figure>

<p>helloworld!</p>
<p><strong>-o：</strong>output的缩写，表示输出，用于指定输出文件名。</p>
<p>编译过程被浓缩成一步命令。但实际上，c语言的编译是有一个多步骤流程的。</p>
<h4 id="1-7-1-预处理"><a href="#1-7-1-预处理" class="headerlink" title="1.7.1 预处理"></a>1.7.1 <strong>预处理</strong></h4><p><strong>1）</strong><em><strong>*预处理命令*</strong></em></p>
<p>在C语言编译过程中，预处理是其中的第一个阶段，它的主要目的是处理源代码文件中的预处理指令，将它们转换成编译器可以识别的形式。预处理主要包含宏替换、文件包含、条件编译、注释移除等几种任务。预处理的输出通常是经过预处理后的源代码文件，它会被保存成一个临时文件，并作为编译器的输入。预处理器处理后的文件通常会比原始源文件大，因为它会展开宏和包含其他文件的内容。</p>
<p>用下面的命令对两个源文件进行预处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc -E hello.c -o hello.i</span><br><span class="line"></span><br><span class="line">atguigu@ubuntu:~/helloworld$ gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure>

<p>Ø <strong>-E：</strong>Expand（展开）的缩写，该参数指定gcc执行预处理操作。</p>
<p>Ø <strong>.i：</strong>intermediate（中间的）的缩写，预处理后的源文件通常以.i作为后缀。</p>
<p>得到的hello.i和main.i就是预处理之后的文件。我们可以查看它们的内容，例如main.i:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">0</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.h&quot;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">say_hello</span><span class="params">()</span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  say_hello();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到hello.h的内容已经被展开了。</p>
<p><strong>2）</strong><em><strong>*.i文件内容解读*</strong></em></p>
<p>与处理后的.i文件包含了经过C预处理器处理的源代码及行控制指令等内容。</p>
<p>源代码不必多数，此处对行控制指令做简要介绍。</p>
<p>.i文件中以#开头的是预处理器插入的行控制指令，用于标示从下一行起的代码来源，格式大致为</p>
<p># 行号 “文件名” 标志</p>
<p>行号和文件名表示从下一行开始的源代码来源于哪个文件的哪一行。</p>
<p>标志可以是数字1,2,3,4，每个数字的含义如下：</p>
<p>Ø 1: 表示接下来的内容开始于一个新的文件。</p>
<p>Ø 2: 表示控制权从被包含的文件返回。这用于当预处理器完成一个包含文件的读取，回到包含它的文件继续处理时。</p>
<p>Ø 3: 指示接下来的内容来自系统头文件。</p>
<p>Ø 4: 表明接下来的内容应被视为被extern “C”包围，这主要用于C++中，以指示C链接约定。extern C是C++中的关键字组合，我们不必关注。</p>
<p><strong>注：</strong>行号为0通常是预处理器的一种特殊标记用法，并不指向源代码中的实际行号。它可能用于初始化或特殊标记，比如标识文件的开始，而不直接对应于源代码中的行。我们只需要知道.i文件是将源码中宏定义处理之后的源文件，其它内容了解即可。</p>
<h4 id="1-7-2-编译"><a href="#1-7-2-编译" class="headerlink" title="1.7.2 编译"></a>1.7.2 <strong>编译</strong></h4><p>编译阶段，编译器会将经过预处理的源代码文件转换成汇编代码。在这个阶段，编译器会将源代码翻译成机器能够理解的中间代码，包括词法分析、语法分析、语义分析和优化等过程。编译器会检查代码的语法和语义，生成对应的汇编代码。编译阶段是整个编译过程中最复杂和耗时的阶段之一，它对源代码进行了深入的分析和转换，确保了程序的正确性和性能。</p>
<p>执行下面的命令对刚刚生成的预处理文件进行编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc -S hello.i -o hello.s</span><br><span class="line"></span><br><span class="line">atguigu@ubuntu:~/helloworld$ gcc -S main.i -o main.s</span><br></pre></td></tr></table></figure>

<p>Ø <strong>-S：</strong>Source（源代码）的缩写，该参数指定gcc将预处理后的源码编译为汇编语言。</p>
<p>Ø <strong>.s：</strong>Assembly Source（汇编源码）的缩写，通常编译后的汇编文件以.s作为后缀。</p>
<p>我们同样可以观察编译器生成的汇编文件，例如main.s：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    .file  <span class="string">&quot;main.c&quot;</span></span><br><span class="line"></span><br><span class="line">​    .text</span><br><span class="line"></span><br><span class="line">​    .globl  main</span><br><span class="line"></span><br><span class="line">​    .type  main, @function</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line"></span><br><span class="line">.LFB0:</span><br><span class="line"></span><br><span class="line">​    .cfi_startproc</span><br><span class="line"></span><br><span class="line">​    endbr64</span><br><span class="line"></span><br><span class="line">​    pushq  %rbp</span><br><span class="line"></span><br><span class="line">​    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line"></span><br><span class="line">​    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line"></span><br><span class="line">​    movq   %rsp, %rbp</span><br><span class="line"></span><br><span class="line">​    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line"></span><br><span class="line">​    movl   $<span class="number">0</span>, %eax</span><br><span class="line"></span><br><span class="line">​    call   say_hello@PLT</span><br><span class="line"></span><br><span class="line">​    movl   $<span class="number">0</span>, %eax</span><br><span class="line"></span><br><span class="line">​    popq   %rbp</span><br><span class="line"></span><br><span class="line">​    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line"></span><br><span class="line">​    ret</span><br><span class="line"></span><br><span class="line">​    .cfi_endproc</span><br><span class="line"></span><br><span class="line">.LFE0:</span><br><span class="line"></span><br><span class="line">​    .size  main, .-main</span><br><span class="line"></span><br><span class="line">​    .ident  <span class="string">&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span></span><br><span class="line"></span><br><span class="line">​    .section     .note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line"></span><br><span class="line">​    .section     .note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">​    .align <span class="number">8</span></span><br><span class="line"></span><br><span class="line">​    .<span class="type">long</span>  <span class="number">1f</span> - <span class="number">0f</span></span><br><span class="line"></span><br><span class="line">​    .<span class="type">long</span>  <span class="number">4f</span> - <span class="number">1f</span></span><br><span class="line"></span><br><span class="line">​    .<span class="type">long</span>  <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">​    .<span class="built_in">string</span> <span class="string">&quot;GNU&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">​    .align <span class="number">8</span></span><br><span class="line"></span><br><span class="line">​    .<span class="type">long</span>  <span class="number">0xc0000002</span></span><br><span class="line"></span><br><span class="line">​    .<span class="type">long</span>  <span class="number">3f</span> - <span class="number">2f</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">​    .<span class="type">long</span>  <span class="number">0x3</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">​    .align <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>:</span><br></pre></td></tr></table></figure>

<p>上述文件中记录了汇编代码，此外还有编译器版本表示等元数据，了解即可。</p>
<h4 id="1-7-3-汇编"><a href="#1-7-3-汇编" class="headerlink" title="1.7.3 汇编"></a>1.7.3 <strong>汇编</strong></h4><p><strong>1）</strong><em><strong>*汇编命令*</strong></em></p>
<p>汇编阶段是C语言编译过程中的重要阶段，它将编译器生成的中间代码或汇编代码转换成目标机器的机器语言代码，也就是目标代码。这个阶段由汇编器（Assembler）完成，其主要任务是将汇编指令翻译成目标机器的二进制形式。主要包含以下几个任务：符号解析、指令翻译、地址关联、重定位、代码优化。最终，汇编器会将翻译和处理后的目标代码输出到目标文件中，用于后续的链接和生成可执行程序或共享库文件。</p>
<p>执行下面的指令对刚刚生成的汇编文件进行汇编：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc -c main.s -o main.o</span><br><span class="line"></span><br><span class="line">atguigu@ubuntu:~/helloworld$ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>Ø <strong>-c****：</strong>可以被理解为Compile or Assemble（编译或汇编），该参数可以指定gcc将汇编代码翻译为机器码，但不做链接。此外，该参数也可以用于将.c文件直接处理为机器码，同样不做链接。</p>
<p>Ø **-**<strong>o：</strong>Object的缩写，通常汇编得到的机器码文件以.o为后缀。</p>
<p><strong>2）</strong><em><strong>*.o文件内容解读*</strong></em></p>
<p>这次生成的文件已经是二进制文件了，我们不能用文本编辑器直接查看该文件。可以用下面的指令查看main.o文件实质的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ objdump -s main.o</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">main.o：   文件格式 elf64-x86-64-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"></span><br><span class="line"> 0000 f30f1efa 554889e5 b8000000 00e80000  ....UH..........</span><br><span class="line"></span><br><span class="line"> 0010 0000b800 0000005d c3         .......].</span><br><span class="line"></span><br><span class="line">Contents of section .comment:</span><br><span class="line"></span><br><span class="line"> 0000 00474343 3a202855 62756e74 75203131  .GCC: (Ubuntu 11</span><br><span class="line"></span><br><span class="line"> 0010 2e342e30 2d317562 756e7475 317e3232  .4.0-1ubuntu1~22</span><br><span class="line"></span><br><span class="line"> 0020 2e303429 2031312e 342e3000      .04) 11.4.0.</span><br><span class="line"></span><br><span class="line">Contents of section .note.gnu.property:</span><br><span class="line"></span><br><span class="line"> 0000 04000000 10000000 05000000 474e5500  ............GNU.</span><br><span class="line"></span><br><span class="line"> 0010 020000c0 04000000 03000000 00000000  ................</span><br><span class="line"></span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"></span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"></span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"></span><br><span class="line"> 0020 00000000 19000000 00450e10 8602430d  .........E....C.</span><br><span class="line"></span><br><span class="line"> 0030 06500c07 08000000           .P......</span><br></pre></td></tr></table></figure>

<p>文件大致可以分为五个部分：</p>
<p>（1）文件格式</p>
<p>最上面的行标明了文件的格式为：elf64-x86-64-64，为x86-64-64架构设计的64位ELF文件格式。ELF英文全称为Executable and Linkable Format，即可执行链接格式，了解即可。</p>
<p>（2）.text节</p>
<p>从Contents of section .text开始到下一个Contents之间的属于.text节。这部分包含了程序的机器代码或指令，是程序实际执行的代码。</p>
<p>① 列之间是以空格分隔的，左侧第一列为四位16进制数，用于表示当前行的地址偏移量，上述文件中，.text节第一列第一行为0x0000，表示这一行的地址偏移量是从0开始的，第一列第二行为0x0010，表示这一行的偏移量是从十进制的16开始的。</p>
<p>② 从第二至第五列共4列均为16进制数表示的机器码，一行写满，刚好占用16个字节，因此，第一行的地址从0开始，第二行从16开始。可以看到，main函数源码处理之后得到的机器码共占用了25个字节的空间。</p>
<p>③ 第六列即最后一列是机器码的ASCII码表示，和②中的16进制表示相对应。对于ASCII码无法表示的字符，全部用.表示，对于.text节，这部分是无意义的，因为机器码的意义和作用与ASCII码表示无关。</p>
<p>（3）.comment节</p>
<p>从Contents of section .comment至下一个Contents之间的属于.comment节。这部分包含编译器和编译选项的信息，用于记录编译这个文件的环境。</p>
<p>这一节及后续两节的列布局与.text相同，即第一列为地址偏移量，最后一列为机器码的ASCII码表示，其余列为机器码的16进制表示，不再赘述。</p>
<p>本节记录的信息可以从ASCII码表示部分读取：编译器版本为GCC：（Ubuntu 11.4.0-1ubuntu1~22.04）11.4.0。</p>
<p>（4）.note.gnu.property节</p>
<p>从Contents of section .note.gnu.property到下一个Contents之间的部分属于本节。通常包含了一些GNU特定的属性。这部分内容与.text节相同，无法通过ASCII码解读。了解即可。</p>
<p>（5）.eh_frame节</p>
<p>从Contents of section .eh_frame到下一个Contents之间的部分属于本节。包含了用于异常处理的元数据，如每个函数的堆栈信息，可用于异常处理和调试。同样无法通过ASCII码解读。</p>
<p><strong>3）</strong><em><strong>*.o文件section介绍*</strong></em></p>
<p>除了上面的四个section，.o文件中还可能存在其它section。通过以下方式查看更多的section类型。</p>
<p>（1）获得可执行文件</p>
<p>可执行文件需要经过链接才可以获得，关于链接的内容会在下文介绍。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc main.o hello.o -o main</span><br></pre></td></tr></table></figure>

<p>（2）查看可执行文件main中的所有section及其头部信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ objdump -h main</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">main：   文件格式 elf64-x86-64-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line"></span><br><span class="line">Idx Name      Size    VMA        LMA        File off  Algn</span><br><span class="line"></span><br><span class="line"> 0 .interp    0000001c  0000000000000318 0000000000000318 00000318 2**0</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 1 .note.gnu.property 00000030 0000000000000338 0000000000000338 00000338 2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 2 .note.gnu.build-id 00000024 0000000000000368 0000000000000368 00000368 2**2</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 3 .note.ABI-tag 00000020 000000000000038c  000000000000038c  0000038c  2**2</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 4 .gnu.hash   00000024 00000000000003b0  00000000000003b0  000003b0  2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 5 .dynsym    000000a8  00000000000003d8  00000000000003d8  000003d8  2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 6 .dynstr    0000008d  0000000000000480 0000000000000480 00000480 2**0</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 7 .gnu.version  0000000e  000000000000050e  000000000000050e  0000050e  2**1</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 8 .gnu.version_r 00000030 0000000000000520 0000000000000520 00000520 2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 9 .rela.dyn   000000c0  0000000000000550 0000000000000550 00000550 2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 10 .rela.plt   00000018 0000000000000610 0000000000000610 00000610 2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 11 .init     0000001b  0000000000001000 0000000000001000 00001000 2**2</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line"> 12 .plt      00000020 0000000000001020 0000000000001020 00001020 2**4</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line"> 13 .plt.got    00000010 0000000000001040 0000000000001040 00001040 2**4</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line"> 14 .plt.sec    00000010 0000000000001050 0000000000001050 00001050 2**4</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line"> 15 .text     00000116 0000000000001060 0000000000001060 00001060 2**4</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line"> 16 .fini     0000000d  0000000000001178 0000000000001178 00001178 2**2</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line"> 17 .rodata    00000014 0000000000002000 0000000000002000 00002000 2**2</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 18 .eh_frame_hdr 00000034 0000000000002014 0000000000002014 00002014 2**2</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 19 .eh_frame   000000ac  0000000000002048 0000000000002048 00002048 2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line"> 20 .init_array  00000008 0000000000003db8  0000000000003db8  00002db8  2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"></span><br><span class="line"> 21 .fini_array  00000008 0000000000003dc0  0000000000003dc0  00002dc0  2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"></span><br><span class="line"> 22 .dynamic    000001f0  0000000000003dc8  0000000000003dc8  00002dc8  2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"></span><br><span class="line"> 23 .got      00000048 0000000000003fb8  0000000000003fb8  00002fb8  2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"></span><br><span class="line"> 24 .data     00000010 0000000000004000 0000000000004000 00003000 2**3</span><br><span class="line"></span><br><span class="line">​         CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"></span><br><span class="line"> 25 .bss      00000008 0000000000004010 0000000000004010 00003010 2**0</span><br><span class="line"></span><br><span class="line">​         ALLOC</span><br><span class="line"></span><br><span class="line"> 26 .comment    0000002b  0000000000000000 0000000000000000 00003010 2**0</span><br><span class="line"></span><br><span class="line">​         CONTENTS, READONLY</span><br></pre></td></tr></table></figure>

<p>（3）列</p>
<p>每个section对应两行，第一行为section的布局信息，如下。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps14_20241001145816324826.jpg" alt="img"> </p>
<p>这些信息以空格分隔，共有七列，如下。</p>
<p>① Idx (Index): 节的索引号，这是一个简单的序列号，用于唯一标识每个section。</p>
<p>② Name: 节的名称，如.text、.data、.bss等。每个名称代表了该节的用途或包含的数据类型。</p>
<p>③ Size: 节的大小，以十六进制表示。这表示节在文件中占用的字节数。</p>
<p>④ VMA (Virtual Memory Address): 虚拟内存地址，指出当程序加载到内存中时，该节的内容应放置在内存的什么位置。这个地址是虚拟的，用于运行时。了解即可。</p>
<p>⑤ LMA (Load Memory Address): 加载内存地址，指出节内容在可执行文件中的实际位置。通常与VMA相同，除非创建位置独立的代码。了解即可。</p>
<p>⑥ File off (File Offset): 文件偏移，以十六进制表示，指出该节在文件中的起始位置。</p>
<p>⑦ Algn (Alignment): 对齐，表示该节在内存中的对齐要求。例如，2**3表示该节的数据在内存中的地址应该是8的倍数。</p>
<p>以.section为例，改节的索引为15，名称为.text，大小为0x116，虚拟内存地址和加载内存地址均为0x1060，文件偏移为0x1060，内存中的地址是以2的四次方即16字节对齐的，与objdump -s main.o看到的内容一致。</p>
<p>（4）属性</p>
<p>第二行为该节的标志或属性信息，如下。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/wps15_20241001145838008987.jpg" alt="img"> </p>
<p>Ø CONTENTS: 该section在文件中包含实际的数据或代码。</p>
<p>Ø ALLOC: 在程序执行时，该section需要被分配内存空间。</p>
<p>Ø LOAD: 该section的内容需要从磁盘加载到内存中。</p>
<p>Ø READONLY: 该section是只读的，不能被程序修改。</p>
<p>Ø DATA: 指示该section包含数据而非执行代码，这通常用于区分包含变量和常量的section。</p>
<p>Ø CODE: 指示该section包含可执行代码。</p>
<p>Ø WRITE: 该section在运行时可以被写入，通常与DATA标志一起出现，表明这是一个包含可修改数据的section，如全局变量。</p>
<p>Ø EXECINSTR: 该section包含可执行指令。</p>
<p>（5）常见的section</p>
<p>除了执行<strong>objdump -s main.o</strong>看到的几种section，常见的还有：.data，.bss和.rodata</p>
<p>① .data：包含初始化了的全局变量和静态变量。这些变量在程序开始执行前就已经被赋予了初始值。</p>
<p>② .bss（Block Started by Symbol）：包含未初始化的全局变量和静态变量。对于ELF文件，.bss节并不真正占用文件空间，它仅仅是一个占位符，指示程序启动时需要分配多少空间并将其清零。</p>
<p>③ .rodata（Read-Only Data）：包含只读数据，比如字符串常量和其他程序中用到的不可修改的数据。</p>
<p>（6）删除可执行文件main</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ <span class="built_in">rm</span> main</span><br></pre></td></tr></table></figure>

<p><strong>4）</strong> <strong>反汇编</strong></p>
<p>可以执行下面的指令对main.o内容进行反汇编：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ objdump -d main.o</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main.o：   文件格式 elf64-x86-64-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">  0:  f3 0f 1e fa       endbr64</span><br><span class="line"></span><br><span class="line">  4:  55            push  %rbp</span><br><span class="line"></span><br><span class="line">  5:  48 89 e5         mov   %rsp,%rbp</span><br><span class="line"></span><br><span class="line">  8:  b8 00 00 00 00      mov   <span class="variable">$0x0</span>,%eax</span><br><span class="line"></span><br><span class="line">  d:  e8 00 00 00 00      call  12 &lt;main+0x12&gt;</span><br><span class="line"></span><br><span class="line"> 12:  b8 00 00 00 00      mov   <span class="variable">$0x0</span>,%eax</span><br><span class="line"></span><br><span class="line"> 17:  5d            pop   %rbp</span><br><span class="line"></span><br><span class="line"> 18:  c3            ret</span><br></pre></td></tr></table></figure>

<p>反汇编内容保留了objdump -s main.o看到的前两节内容，主要是将.text节的内容反汇编为汇编代码。从000000..（若干0） <main>：下一行起的内容均为汇编代码。同样地，汇编代码可以按照空格分隔，第一列为地址偏移量，第二列至第六列共5列为汇编指令对应的机器码，从第七列开始的均为汇编指令。</p>
<h4 id="1-7-4-链接"><a href="#1-7-4-链接" class="headerlink" title="1.7.4 链接"></a>1.7.4 <strong>链接</strong></h4><p>链接阶段，由链接器完成。链接器将各个目标文件以及可能用到的库文件进行链接，生成最终的可执行程序。在这个阶段，链接器会解析目标文件中的符号引用，并将它们与符号定义进行匹配，以解决符号的地址关联问题。链接器还会处理全局变量的定义和声明，解决重定位问题，最终生成可执行文件或共享库文件。</p>
<p><strong>1）</strong><em><strong>*链接方式*</strong></em></p>
<p>我们在say_hello()函数中调用了printf()函数，这个函数是在stdio.h中声明的，后者来源于glibc库，printf()的实现在glibc的二进制组件中，通常是在共享库（如libc.so）或静态库（如libc.a）文件中。因此，我们除了要链接main.o、hello.o，还需要和glibc库的文件链接。通常，C语言的链接共有三种方式：静态链接、动态链接和混合链接。三者的区别就在于链接器在链接过程中对程序中库函数调用的解析。</p>
<p>（1）静态链接</p>
<p>将所有目标文件和所需的库在编译时一并打包进最终的可执行文件。库的代码被复制到最终的可执行文件中，使得可执行文件变得自包含，不需要在运行时查找或加载外部库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc -static main.o hello.o -o main</span><br></pre></td></tr></table></figure>

<p><strong>- static：</strong>该参数指示编译器进行静态链接，而不是默认的动态链接。使用这个参数，GCC会尝试将所有用到的库函数直接链接到最终生成的可执行文件中，包括C标准库（libc）、数学库（libm）和其他任何通过代码引用的外部库。</p>
<p>（2）动态链接</p>
<p>库在运行时被加载，可执行文件包含了需要加载的库的路径和符号信息。动态链接的可执行文件比静态链接的小，因为它们共享系统级的库代码。与静态链接不同，库代码不包含在可执行文件中。</p>
<p>① 方式一</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc main.o hello.o -o main</span><br></pre></td></tr></table></figure>

<p>没有添加-static关键字，gcc默认执行动态链接，即glibc库文件没有包含到可执行文件中。</p>
<p>② 方式二</p>
<p>我们也可以将自己编写的部分代码处理为动态库。</p>
<p>执行下面的指令将hello.o编译为动态链接库libhello.so。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu@ubuntu:~/helloworld$ gcc -fPIC -shared -o libhello.so hello.o</span><br></pre></td></tr></table></figure>

<p>Ø **-<strong><strong>f</strong></strong>PIC：**这个选项告诉编译器为“位置无关代码（Position Independent Code）”生成输出。在创建共享库时使用这个选项是非常重要的，因为它允许共享库被加载到内存中的任何位置，而不影响其执行。这是因为位置无关代码使用相对地址而非绝对地址进行数据访问和函数调用，使得库在被不同程序加载时能够灵活地映射到不同的地址空间。</p>
<p>Ø <strong>-shared：</strong>这个选项指示GCC生成一个共享库而不是一个可执行文件。共享库可以被多个程序同时使用，节省了内存和磁盘空间。</p>
<p>Ø <strong>-o libhello.so：</strong>这部分指定了输出文件的名称。-o选项后面跟着的是输出文件的名字，这里命名为libhello.so。按照惯例，Linux下的共享库名称以lib开头，扩展名为.so（表示共享对象）。</p>
<p>Ø <strong>hello.o：</strong>这是命令的输入文件，即之前编译生成的目标文件。在这个例子中，GCC会将hello.o中的代码和数据打包进最终的共享库libhello.so中。</p>
<p>上述命令的作用是：使用GCC，采用位置无关代码的方式，从hello.o目标文件创建一个名为libhello.so的动态共享库文件。</p>
<p>编译完成后查看刚刚编译的动态链接库：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ ll</p>
<p>总计 80</p>
<p>drwxrwxr-x  3 atguigu atguigu  4096 3月 27 20:38 .&#x2F;</p>
<p>drwxr-x— 23 atguigu atguigu  4096 3月 27 19:12 ..&#x2F;</p>
<p>-rw-rw-r–  1 atguigu atguigu   91 3月 27 15:17 hello.c</p>
<p>-rw-rw-r–  1 atguigu atguigu   68 3月 27 15:17 hello.h</p>
<p>-rw-rw-r–  1 atguigu atguigu 18009 3月 27 17:27 hello.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1496 3月 27 17:27 hello.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  680 3月 27 17:27 hello.s</p>
<p><em><strong>*-rwxrwxr-x*</strong></em>  <em><strong>*1*</strong></em> <em><strong>*atguigu atguigu*</strong></em> <em><strong>*15576*</strong></em> <em><strong>*3*</strong></em><em><strong>*月*</strong></em> <em><strong>*27*</strong></em> <em><strong>*20*</strong></em><em><strong>*:*</strong></em><em><strong>*23*</strong></em> <em><strong>*libhello.so**</strong></em></p>
<p>-rw-rw-r–  1 atguigu atguigu   67 3月 27 15:17 main.c</p>
<p>-rw-rw-r–  1 atguigu atguigu  225 3月 27 15:18 main.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1360 3月 27 15:18 main.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  589 3月 27 15:18 main.s</p>
<p>drwxrwxr-x  2 atguigu atguigu  4096 3月 27 14:24 .vscode&#x2F;</p>
<p>使用动态链接库编译新的可执行文件：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ gcc main.o -L .&#x2F; -lhello -o main_d</p>
<p>Ø <strong>-L .&#x2F;：</strong>指定了库文件搜索路径。-L选项告诉链接器在哪些目录下查找库文件，.&#x2F;表示当前目录。这意味着在链接过程中，链接器将会在当前目录下搜索指定的库文件。</p>
<p>Ø <strong>-lhello：</strong>指定了要链接的库。-l选项后面跟库的名称，这里是hello。根据约定，链接器会搜索名为libhello.so（动态库）或libhello.a（静态库）的文件来链接。链接器会根据-L选项指定的路径列表查找这个库。</p>
<p>当前目录下只有libhello.so而没有libhello.a，因此，这条命令的最终效果是动态链接当前目录下的libhello.so库以及默认的glibc库，生成可执行文件main_d。</p>
<p>编译后查看结果：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ ll</p>
<p>总计 96</p>
<p>drwxrwxr-x  3 atguigu atguigu  4096 3月 27 20:40 .&#x2F;</p>
<p>drwxr-x— 23 atguigu atguigu  4096 3月 27 19:12 ..&#x2F;</p>
<p>-rw-rw-r–  1 atguigu atguigu   91 3月 27 15:17 hello.c</p>
<p>-rw-rw-r–  1 atguigu atguigu   68 3月 27 15:17 hello.h</p>
<p>-rw-rw-r–  1 atguigu atguigu 18009 3月 27 17:27 hello.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1496 3月 27 17:27 hello.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  680 3月 27 17:27 hello.s</p>
<p>-rwxrwxr-x  1 atguigu atguigu 15576 3月 27 20:23 libhello.so*</p>
<p>-rw-rw-r–  1 atguigu atguigu   67 3月 27 15:17 main.c</p>
<p><em><strong>*-rwxrwxr-x*</strong></em>  <em><strong>*1*</strong></em> <em><strong>*atguigu atguigu*</strong></em> <em><strong>*15952*</strong></em> <em><strong>*3*</strong></em><em><strong>*月*</strong></em> <em><strong>*27*</strong></em> <em><strong>*20*</strong></em><em><strong>*:*</strong></em><em><strong>*40*</strong></em> <em><strong>*main_d**</strong></em></p>
<p>-rw-rw-r–  1 atguigu atguigu  225 3月 27 15:18 main.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1360 3月 27 15:18 main.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  589 3月 27 15:18 main.s</p>
<p>drwxrwxr-x  2 atguigu atguigu  4096 3月 27 14:24 .vscode&#x2F;</p>
<p>这时如果我们直接执行main_d文件，会收到以下报错：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ .&#x2F;main_d</p>
<p>.&#x2F;main_d: error <strong>while</strong> loading <strong>shared</strong> libraries: libhello.so: cannot <strong>open</strong> <strong>shared</strong> object <strong>file</strong>: No such <strong>file</strong> <strong>or</strong> directory</p>
<p>这句报错的意思时main_d在执行过程中，没有找到动态链接库文件libhello.so文件，链接失败无法执行。Linux的默认动态链接库文件夹是&#x2F;lib 和&#x2F;usr&#x2F;lib，而我们的libhello.so不在其中，所以我们需要在执行的时候指明额外的动态链接库文件夹。</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;atguigu&#x2F;helloworld .&#x2F;main_d</p>
<p>Hello world!</p>
<p>（3）混合链接</p>
<p>某些库静态链接，而其他库动态链接。这种方式结合了静态链接和动态链接的优点。</p>
<p>执行下面的指令可以将hello.o编译为静态链接库libhello.a</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ ar crv libhello.a hello.o</p>
<p>Ø <strong>ar：</strong>归档命令，用于处理静态库文件。</p>
<p>Ø <strong>crv：</strong>ar命令的选项，由三个字符组成，每个字符代表一个选项：</p>
<p>Ø <strong>c：</strong>创建归档文件。如果指定的归档文件不存在，ar会创建它。</p>
<p>Ø <strong>r：</strong>替换归档文件中现有的文件或者向归档文件中添加新文件。如果hello.o已经在libhello.a中，它会被新版本替换；如果不存在，则会被添加。</p>
<p>Ø <strong>v：</strong>详细模式（verbose mode），在处理文件时显示详细信息。使用这个选项，ar会列出它正在执行的操作，包括哪些文件被添加或替换。</p>
<p>Ø <strong>libhello.a：</strong>要创建或更新的静态库文件的名称。按照惯例，Linux下的静态库文件名以lib开头，并以.a作为文件扩展名。</p>
<p>Ø <strong>hello.o：</strong>输入文件，即要添加到静态库libhello.a中的目标文件。此处只有一个目标文件hello.o，但ar命令支持同时指定多个文件。</p>
<p>查看生成的静态库文件：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ ll</p>
<p>总计 100</p>
<p>drwxrwxr-x  3 atguigu atguigu  4096 3月 27 20:41 .&#x2F;</p>
<p>drwxr-x— 23 atguigu atguigu  4096 3月 27 19:12 ..&#x2F;</p>
<p>-rw-rw-r–  1 atguigu atguigu   91 3月 27 15:17 hello.c</p>
<p>-rw-rw-r–  1 atguigu atguigu   68 3月 27 15:17 hello.h</p>
<p>-rw-rw-r–  1 atguigu atguigu 18009 3月 27 17:27 hello.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1496 3月 27 17:27 hello.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  680 3月 27 17:27 hello.s</p>
<p><em><strong>*-rw-rw-r–*</strong></em>  <em><strong>*1*</strong></em> <em><strong>*atguigu atguigu*</strong></em>  <em><strong>*1642*</strong></em> <em><strong>*3*</strong></em><em><strong>*月*</strong></em> <em><strong>*27*</strong></em> <em><strong>*20*</strong></em><em><strong>*:*</strong></em><em><strong>*41*</strong></em> <em><strong>*libhello.a*</strong></em></p>
<p>-rwxrwxr-x  1 atguigu atguigu 15576 3月 27 20:23 libhello.so*</p>
<p>-rw-rw-r–  1 atguigu atguigu   67 3月 27 15:17 main.c</p>
<p>-rwxrwxr-x  1 atguigu atguigu 15952 3月 27 20:40 main_d*</p>
<p>-rw-rw-r–  1 atguigu atguigu  225 3月 27 15:18 main.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1360 3月 27 15:18 main.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  589 3月 27 15:18 main.s</p>
<p>drwxrwxr-x  2 atguigu atguigu  4096 3月 27 14:24 .vscode&#x2F;</p>
<p>删除动态链接库，如果相同目录下同时存在hello的静态库和动态库文件，链接时会默认选择动态链接。</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ rm libhello.so</p>
<p>利用静态库文件生成可执行的main文件：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ gcc main.o -L .&#x2F; -lhello -o main</p>
<p>Ø -L .&#x2F;表示额外的库文件位置为当前目录；</p>
<p>Ø -lhello表示链接libhello.a文件。注意这里要去掉开头的lib前缀和结尾的.a后缀。</p>
<p>编译完成后的main文件同样可以执行，并且不依赖于静态库libhello.a。</p>
<p>查看静态链接生成的可执行文件</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ ll</p>
<p>总计 100</p>
<p>drwxrwxr-x  3 atguigu atguigu  4096 3月 27 20:54 .&#x2F;</p>
<p>drwxr-x— 23 atguigu atguigu  4096 3月 27 19:12 ..&#x2F;</p>
<p>-rw-rw-r–  1 atguigu atguigu   91 3月 27 15:17 hello.c</p>
<p>-rw-rw-r–  1 atguigu atguigu   68 3月 27 15:17 hello.h</p>
<p>-rw-rw-r–  1 atguigu atguigu 18009 3月 27 17:27 hello.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1496 3月 27 17:27 hello.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  680 3月 27 17:27 hello.s</p>
<p>-rw-rw-r–  1 atguigu atguigu  1642 3月 27 20:41 libhello.a</p>
<p><em><strong>*-rwxrwxr-x*</strong></em>  <em><strong>*1*</strong></em> <em><strong>*atguigu atguigu*</strong></em> <em><strong>*16024*</strong></em> <em><strong>*3*</strong></em><em><strong>*月*</strong></em> <em><strong>*27*</strong></em> <em><strong>*20*</strong></em><em><strong>*:*</strong></em><em><strong>*54*</strong></em> <em><strong>*main**</strong></em></p>
<p>-rw-rw-r–  1 atguigu atguigu   67 3月 27 15:17 main.c</p>
<p><em><strong>*-rwxrwxr-x*</strong></em>  <em><strong>*1*</strong></em> <em><strong>*atguigu atguigu*</strong></em> <em><strong>*15952*</strong></em> <em><strong>*3*</strong></em><em><strong>*月*</strong></em> <em><strong>*27*</strong></em> <em><strong>*20*</strong></em><em><strong>*:*</strong></em><em><strong>*40*</strong></em> <em><strong>*main_d**</strong></em></p>
<p>-rw-rw-r–  1 atguigu atguigu  225 3月 27 15:18 main.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1360 3月 27 15:18 main.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  589 3月 27 15:18 main.s</p>
<p>drwxrwxr-x  2 atguigu atguigu  4096 3月 27 14:24 .vscode&#x2F;</p>
<p>可以看到，静态链接libhello.a生成的main比main_d文件要大一些，这是因为hello库的代码被复制到了可执行文件main中，和动态链接相比，执行速度略高，但是二进制代码的复用性差，略微增加了二进制文件的体积。</p>
<p>需要注意的是，虽然我们静态链接了libhello.a库，但是main文件在执行时依然需要动态链接glibc的库。因此，这种方式实质上并非静态链接，而是混合链接。</p>
<p><strong>2）</strong><em><strong>*gblic的动态库和静态库*</strong></em></p>
<p>glibc的动态库和静态库分别位于&#x2F;usr&#x2F;lib&#x2F;x86-64_64-linux-gnu&#x2F;目录下的libc.so和libc.a文件中。</p>
<h3 id="1-8-Makefile基础"><a href="#1-8-Makefile基础" class="headerlink" title="1.8 Makefile基础"></a>1.8 <strong>Makefile基础</strong></h3><p>Makefile是一种用于管理和自动化软件编译过程的文本文件。它通常包含了一系列规则，这些规则描述了如何根据源代码文件生成可执行文件或者其他目标文件。Makefile的核心概念是规则和依赖关系，规则定义了如何生成一个或多个目标文件，而依赖关系则指定了生成目标文件所需要的源文件或其他依赖文件。下面我们通过一步一步编写Makefile来学习Makefile规则。</p>
<p><strong>1）</strong><em><strong>*安装*</strong></em><em><strong>*build-essential*</strong></em><em><strong>*工具包*</strong></em></p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ sudo apt install -y build-essential</p>
<p><strong>2）</strong><em><strong>*为main*</strong></em><em><strong>*.c*</strong></em><em><strong>*和hello*</strong></em><em><strong>*.c*</strong></em><em><strong>*编写基本*</strong></em><em><strong>*Makefile*</strong></em></p>
<p>（1）编写Makefile</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ vim Makefile</p>
<p>文件内容如下：</p>
<p># Makefile内容通常由以下部分组成</p>
<p># &lt;目标&gt;: &lt;前置依赖&gt;</p>
<p>#   &lt;需要执行的命令&gt;</p>
<p># 放在第一个的是默认目标</p>
<p># 目标为编译出main文件，依赖main.o和hello.o文件</p>
<p># 编译的命令为 gcc -o main hello.o main.o</p>
<p>main: hello.o main.o</p>
<p>  gcc -o main hello.o main.o</p>
<p># main.o目标依赖main.c hello.h</p>
<p># 编译命令为gcc -c main.c</p>
<p>main.o: main.c hello.h</p>
<p>  gcc -c main.c</p>
<p># hello.hello.c hello.h</p>
<p># 编译命令为gcc -c hello.c</p>
<p>hello.o: hello.c hello.h</p>
<p>  gcc -c hello.c</p>
<p># clean目标可以清理编译的临时文件</p>
<p>clean:</p>
<p>  rm main main.o hello.o</p>
<p>保存退出。</p>
<p>（2）文件内容解读</p>
<p>规则是Makefile的构建单元，Make工具通过解析这些规则来执行构建过程。</p>
<p>① 规则的基本结构</p>
<p>我们用空行将Makefile的不同规则划分开来。规则有两行构成，第一行为目标和前置依赖，二者通过冒号区分开来，目标在前，前置依赖在后。</p>
<p># &lt;目标&gt;: &lt;前置依赖&gt;</p>
<p>#   &lt;需要执行的命令&gt;</p>
<p>② 目标：本条规则需要生成的目标文件名。</p>
<p>③ 前置依赖：生成目标文件需要的依赖文件列表。</p>
<p>④ 命令：一系列将被Shell执行的命令，用于从前置依赖构建目标。</p>
<p><strong>需要注意的是</strong>，Makefile中每个规则的命令必须以一个制表符（tab）开始，而不能是空格。否则会提示“<strong>缺失分隔符</strong>”。</p>
<p>⑤ 上文提到，gcc的-c参数不仅可以将汇编代码转换为机器码，还可以直接将C语言源文件转换为机器码，gcc -c main.c就是第二种用法，这里省略了-o main.o。默认情况下，在指定-c参数时，gcc会将与源文件名去掉扩展名再加上后缀.o作为目标文件的名称。</p>
<p>（3）测试</p>
<p>① 执行make命令：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make </p>
<p>make: “main”已是最新。</p>
<p>提示我们“main”已是最新，这是因为上面的操作已经生成了最终的可执行文件“main”，要看到make的作用，需要先将之前编译好的文件删除</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ rm main.o hello.o main</p>
<p>② 重新执行make</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make</p>
<p>gcc -c hello.c</p>
<p>gcc -c main.c</p>
<p>gcc -o main hello.o main.o</p>
<p>可以看到make首先将hello.c转换为hello.o，然后将main.c转换为main.o，最后生成main可执行文件。</p>
<p>③ 同理，执行make clean可以执行clean目标：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make clean</p>
<p>rm -f main main.o hello.o</p>
<p>这个目标我们定义了如何清理编译的残留文件和结果。执行这个目标后，我们的编译结果和临时文件就都被清理了。</p>
<p>这就是Makefile，可以批处理进行一键编译，大大提高了编译效率。</p>
<p><strong>3）</strong><em><strong>*引入变量*</strong></em></p>
<p>Makefile中为了方便，可以引入临时变量：</p>
<p># 定义变量objects</p>
<p>objects :&#x3D;  hello.o\</p>
<p>​      main.o</p>
<p># 在目标中引入变量</p>
<p>main: $(objects)</p>
<p>  gcc -o main $(objects)</p>
<p>main.o: main.c hello.h</p>
<p>  gcc -c main.c</p>
<p>hello.o: hello.c hello.h</p>
<p>  gcc -c hello.c</p>
<p># clean目标中也可以引入变量</p>
<p>clean:</p>
<p>  rm main $(objects)</p>
<p>Ø <strong>objects</strong>为变量名</p>
<p>Ø **:&#x3D;**的组合相当于C语言中的&#x3D;，表示赋值</p>
<p>Ø :&#x3D;后面为变量的值</p>
<p>Ø <em>***为续行符，表示命令或定义延续到下一行。此处的作用是将hello.o和main.o合并为一行，此处的定义等价于**objects :&#x3D; hello.o main.o</em>*。</p>
<p>Ø **$(变量名)**表示获取变量的值</p>
<p><strong>4）</strong><em><strong>*引入make自动推导：*</strong></em></p>
<p>（1）更改Makefile</p>
<p>make可以根据目标自动加入所需的依赖文件和命令。例如main.o目标，会默认将main.c作为依赖加入，同时也可以自动推导出编译main.o的命令，于是我们的Makefile就可以改成以下内容：</p>
<p>objects :&#x3D;  hello.o\</p>
<p>​      main.o</p>
<p>main: $(objects)</p>
<p>  gcc -o main $(objects)</p>
<p># 利用make的自动推导</p>
<p>clean:</p>
<p>  rm main $(objects)</p>
<p>（2）依赖文件的作用</p>
<p>要注意的是，虽然这种方式精简Makefile的内容，但是当没有显式声明的依赖文件发生更改时Make无法追踪。</p>
<p>① 执行make命令，确保控制台输出如下</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make</p>
<p>make: “main”已是最新。</p>
<p>② 更改hello.h，在其中任意位置加入空行</p>
<p>③ 重新执行</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make</p>
<p>make: “main”已是最新。</p>
<p>此时Make工具没有检测到hello.h的更新。</p>
<p>④ 将Makefile恢复为以下内容。</p>
<p># Makefile内容通常由以下3部分组成</p>
<p># &lt;目标名称&gt;:&lt;前置依赖&gt;</p>
<p>#  \t&lt;需要执行的命令&gt;</p>
<p># 定义变量 objects</p>
<p>objects :&#x3D; hello.o \</p>
<p>main.o</p>
<p># 放在第一个的是默认目标</p>
<p># 目标是编译出main文件  依赖hello.o和main.o文件</p>
<p># 编译的命令是gcc hello.o main.o -o main</p>
<p>main: $(objects)</p>
<p>  gcc $(objects) -o main </p>
<p>#目标是main.o 依赖main.c和hello.h</p>
<p>#编译的命令是gcc -c main.c </p>
<p># main.o: main.c hello.h</p>
<p>#  gcc -c main.c </p>
<p>main.o: hello.h</p>
<p>#目标是hello.o 依赖hello.c和hello.h</p>
<p>#编译的命令是gcc -c hello.c</p>
<p># hello.o: hello.c hello.h</p>
<p>#  gcc -c hello.c</p>
<p>hello.o: hello.h</p>
<p>clean:</p>
<p>  rm main $(objects)</p>
<p>⑤ 执行make</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make</p>
<p>make: “main”已是最新。</p>
<p>⑥ 更改hello.h，删除任意空行</p>
<p>⑦ 重新执行</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make</p>
<p>gcc -c main.c</p>
<p>gcc -o main hello.o main.o</p>
<p>⑧ 总结：只有在Makefile中显式声明依赖的头文件才会被追踪，当它们发生更改时，重新执行make命令，会再次执行相应规则的命令。</p>
<p><strong>5）</strong><em><strong>*引入伪目标*</strong></em></p>
<p>（1）伪目标</p>
<p><strong>伪目标</strong>并不代表实际的文件名，它们更多的是行为或动作的标识符。伪目标并不生成具体文件。</p>
<p>（2）.PHONY目标</p>
<p>① <strong>.PHONY</strong>是Makefile中一个特殊的目标，用于声明其它目标是伪目标。</p>
<p>② 语法：**.PHONY:&lt;伪目标名称&gt;**</p>
<p>③ 细心的同学可能发现，目标为clean的规则没有前置依赖，这是因为它是用来执行清理操作的，并不是要生成名为clean的文件，因此不需要前置依赖。我们可以将clean声明为伪目标。</p>
<p>④ 修改Makefile，如下。</p>
<p># 定义变量objects</p>
<p>objects :&#x3D;  hello.o\</p>
<p>​      main.o</p>
<p># 在目标中引入变量</p>
<p>main: $(objects)</p>
<p>  gcc -o main $(objects)</p>
<p>main.o: hello.h</p>
<p>hello.o: hello.h</p>
<p># 声明伪目标</p>
<p>.PHONY: clean</p>
<p># clean目标中也可以引入变量</p>
<p>clean:</p>
<p>  rm main $(objects)</p>
<p>保存退出。</p>
<p>⑤ 执行</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make clean</p>
<p>rm main hello.o main.o</p>
<p>（3）为什么需要声明伪目标</p>
<p>我们看到，将clean声明为伪目标后执行make clean的结果与之前并无二致。那么声明伪目标的意义何在？</p>
<p>执行以下操作。</p>
<p>① 在helloworld目录下创建名为clean的文件</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ touch clean</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ ll</p>
<p>总计 96</p>
<p>drwxrwxr-x  3 atguigu atguigu  4096 3月 28 15:24 .&#x2F;</p>
<p>drwxr-x— 23 atguigu atguigu  4096 3月 28 15:00 ..&#x2F;</p>
<p><em><strong>*-rw-rw-r–*</strong></em>  <em><strong>*1*</strong></em> <em><strong>*atguigu atguigu*</strong></em>   <em><strong>*0*</strong></em> <em><strong>*3*</strong></em><em><strong>*月*</strong></em> <em><strong>*28*</strong></em> <em><strong>*15*</strong></em><em><strong>*:*</strong></em><em><strong>*24*</strong></em> <em><strong>*clean*</strong></em></p>
<p>-rw-rw-r–  1 atguigu atguigu   92 3月 28 14:45 hello.c</p>
<p>-rw-rw-r–  1 atguigu atguigu   69 3月 28 14:45 hello.h</p>
<p>-rw-rw-r–  1 atguigu atguigu 18009 3月 27 17:27 hello.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  680 3月 27 17:27 hello.s</p>
<p>-rw-rw-r–  1 atguigu atguigu  1642 3月 27 20:41 libhello.a</p>
<p>-rwxrwxr-x  1 atguigu atguigu 16024 3月 28 14:30 main123*</p>
<p>-rw-rw-r–  1 atguigu atguigu   67 3月 28 14:53 main.c</p>
<p>-rwxrwxr-x  1 atguigu atguigu 15952 3月 27 20:40 main_d*</p>
<p>-rw-rw-r–  1 atguigu atguigu  225 3月 27 15:18 main.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  589 3月 27 15:18 main.s</p>
<p>-rw-rw-r–  1 atguigu atguigu  279 3月 28 14:52 Makefile</p>
<p>drwxrwxr-x  2 atguigu atguigu  4096 3月 27 14:24 .vscode&#x2F;</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$</p>
<p>② 删除Makefile中的.PHONY: clean，保存退出</p>
<p>③ 重新执行make</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make</p>
<p>gcc -c hello.c</p>
<p>gcc -c main.c</p>
<p>gcc -o main hello.o main.o</p>
<p>④ 重新执行make clean</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make clean</p>
<p>make: “clean”已是最新。</p>
<p>我们发现，执行make clean并没有像我们预想的那样删除文件，而是告诉我们“clean”已是最新。这是因为，make将clean作为普通目标处理，它先检查clean的依赖（不存在），然后发现clean文件已存在且没有依赖更新（因为不存在，自然不需要更新），因此不会执行规则下的命令，并在控制台输出以上内容。显然，这不是我们期望的行为。</p>
<p>⑤ 在Makefile中添加.PHONY: clean将clean声明为伪目标，并保存退出</p>
<p>⑥ 重新执行make clean</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make clean</p>
<p>rm main hello.o main.o</p>
<p>可以看到，虽然目录下有名为clean的文件，但make仍执行了clean所在规则的命令。这是我们期望的行为。</p>
<p>⑦ 总结：将某些不生成目标文件的行为或动作（如清理、安装）声明为伪目标可以确保<strong>无条件执行</strong>规则下的命令。即便执行make命令时当前目录下存在与目标同名的文件，依然可以得到我们期望的效果。</p>
<p><strong>6）</strong><em><strong>*忽略错误*</strong></em></p>
<p>如果我们在没有编译时执行make clean目标，会收到以下报错：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make clean</p>
<p>rm main hello.o main.o</p>
<p>rm: 无法删除 ‘main’: 没有那个文件或目录</p>
<p>rm: 无法删除 ‘hello.o’: 没有那个文件或目录</p>
<p>rm: 无法删除 ‘main.o’: 没有那个文件或目录</p>
<p>make: *** [Makefile:20：clean] 错误 1</p>
<p>make命令最终以返回码1推出了。我们可以将Makefile改为下面的形式：</p>
<p># 定义变量objects</p>
<p>objects :&#x3D;  hello.o\</p>
<p>​      main.o</p>
<p># 在目标中引入变量</p>
<p>main: $(objects)</p>
<p>  gcc -o main $(objects)</p>
<p>main.o: hello.h</p>
<p>hello.o: hello.h</p>
<p># 声明伪目标</p>
<p>.PHONY: clean</p>
<p># clean目标中也可以引入变量</p>
<p>clean:</p>
<p>  -rm main $(objects)</p>
<p>rm前面的-告诉make，如果该命令执行失败，不要停止执行剩余的过程，即忽略错误。</p>
<p>再次执行make clean目标，提示信息会变为：</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make clean</p>
<p>rm main hello.o main.o</p>
<p>rm: 无法删除 ‘main’: 没有那个文件或目录</p>
<p>rm: 无法删除 ‘hello.o’: 没有那个文件或目录</p>
<p>rm: 无法删除 ‘main.o’: 没有那个文件或目录</p>
<p>make: [Makefile:20：clean] 错误 1 (已忽略）</p>
<p>错误已被忽略。</p>
<p><strong>7）</strong><em><strong>*目标名和命令中输出文件名的关系*</strong></em></p>
<p>（1）修改Makefile</p>
<p># 定义变量objects</p>
<p>objects :&#x3D;  hello.o\</p>
<p>​      main.o</p>
<p># 在目标中引入变量</p>
<p>main: $(objects)</p>
<p>  gcc -o main123 $(objects)</p>
<p>main.o: hello.h</p>
<p>hello.o: hello.h</p>
<p># 声明伪目标</p>
<p>.PHONY: clean</p>
<p># clean目标中也可以引入变量</p>
<p>clean:</p>
<p>  -rm main $(objects)</p>
<p>将命令中最终输出的文件名由main更改为main123。</p>
<p>保存退出。</p>
<p>（2）执行make</p>
<p>上一步已经删除了目录下的main.o，hello.o和main。</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make </p>
<p>gcc -c hello.c</p>
<p>gcc -c main.c</p>
<p>gcc -o main123 hello.o main.o</p>
<p>（3）可以看到make的日志中，最终生成的文件为main123，查看当前目录</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ ll</p>
<p>总计 104</p>
<p>drwxrwxr-x  3 atguigu atguigu  4096 3月 28 15:49 .&#x2F;</p>
<p>drwxr-x— 23 atguigu atguigu  4096 3月 28 15:49 ..&#x2F;</p>
<p>-rw-rw-r–  1 atguigu atguigu   0 3月 28 15:24 clean</p>
<p>-rw-rw-r–  1 atguigu atguigu   92 3月 28 14:45 hello.c</p>
<p>-rw-rw-r–  1 atguigu atguigu   69 3月 28 14:45 hello.h</p>
<p>-rw-rw-r–  1 atguigu atguigu 18009 3月 27 17:27 hello.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1496 3月 28 15:49 hello.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  680 3月 27 17:27 hello.s</p>
<p>-rw-rw-r–  1 atguigu atguigu  1642 3月 27 20:41 libhello.a</p>
<p>-rwxrwxr-x  1 atguigu atguigu 16024 3月 28 15:49 main123*</p>
<p>-rw-rw-r–  1 atguigu atguigu   67 3月 28 14:53 main.c</p>
<p>-rwxrwxr-x  1 atguigu atguigu 15952 3月 27 20:40 main_d*</p>
<p>-rw-rw-r–  1 atguigu atguigu  225 3月 27 15:18 main.i</p>
<p>-rw-rw-r–  1 atguigu atguigu  1360 3月 28 15:49 main.o</p>
<p>-rw-rw-r–  1 atguigu atguigu  589 3月 27 15:18 main.s</p>
<p>-rw-rw-r–  1 atguigu atguigu  316 3月 28 15:49 Makefile</p>
<p>drwxrwxr-x  2 atguigu atguigu  4096 3月 27 14:24 .vscode&#x2F;</p>
<p>（4）分析</p>
<p>当前目录下不存在名为main的文件，只有名为mian123的文件，可以得出结论：规则中的命令决定了生成目标文件的名称。目标名并不影响目标文件名。</p>
<p>（5）再次执行make</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ make</p>
<p>gcc -o main123 hello.o main.o</p>
<p>我们发现，make没有提示目标文件已是最新，而是重新执行了gcc -o main123 hello.o main.o。这是因为，make会按照目标名称在当前目录下追踪目标文件，如果不存在与目标同名的文件，会再次执行规则下的命令。</p>
<p>（6）总结</p>
<p>make输出的文件名取决于规则下的命令，而目标名称决定make追踪的目标文件名。如果二者不一致，make就会认为目标文件不存在而不断执行命令。我们应确保命令生成的目标文件名和目标名一致。</p>
<p><strong>8）</strong><em><strong>*安装vscode-makefile-term插件*</strong></em></p>
<p>在插件市场搜索并安装vscode-makefile-term插件，完成后，在VScode中打开Makefile文件，可以看到每个target上方都出现了执行按钮。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps16.jpg" alt="img"> </p>
<p>点击这些按钮vscode-makefile-term插件就会帮助我们执行相应的target。</p>
<h1 id="第-2-章-文件I-O"><a href="#第-2-章-文件I-O" class="headerlink" title="第 2 章 文件I&#x2F;O"></a>第 2 章 <strong>文件I&#x2F;O</strong></h1><p>我们在&#x2F;home&#x2F;atguigu下新建目录file_io，本章的所有例程全部放到该目录下。</p>
<h3 id="2-1-C标准I-O库函数回顾"><a href="#2-1-C标准I-O库函数回顾" class="headerlink" title="2.1 C标准I&#x2F;O库函数回顾"></a>2.1 <strong>C标准I&#x2F;O库函数回顾</strong></h3><h4 id="2-1-1-打开-关闭文件"><a href="#2-1-1-打开-关闭文件" class="headerlink" title="2.1.1 打开&#x2F;关闭文件"></a>2.1.1 <strong>打开&#x2F;关闭文件</strong></h4><p><strong>1）</strong><em><strong>*fopen*</strong></em></p>
<p>（1）新建fopen_test.c，写入以下内容。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;* 打开文件</p>
<p>  char *__restrict __filename: 字符串表示要打开文件的路径和名称</p>
<p>  char *__restrict __modes: 字符串表示访问模式</p>
<p>​    (1)”r”: 只读模式 没有文件打开失败</p>
<p>​    (2)”w”: 只写模式 存在文件写入会清空文件,不存在文件则创建新文件</p>
<p>​    (3)”a”: 只追加写模式 不会覆盖原有内容 新内容写到末尾，如果文件不存在则创建</p>
<p>​    (4)”r+”: 读写模式 文件必须存在 写入是从头一个一个覆盖</p>
<p>​    (5)”w+”: 读写模式 可读取,写入同样会清空文件内容，不存在则创建新文件</p>
<p>​    (6)”a+”: 读写追加模式 可读取,写入从文件末尾开始，如果文件不存在则创建</p>
<p>  return: FILE * 结构体指针 表示一个文件</p>
<p>  FILE *fopen (const char *__restrict __filename,</p>
<p>​      const char *__restrict __modes)</p>
<p>  *&#x2F;</p>
<p>  char *filename &#x3D; “io.txt”;</p>
<p>  FILE *ioFile &#x3D; fopen(filename, “a+”);</p>
<p>  if (ioFile &#x3D;&#x3D; NULL)</p>
<p>  {</p>
<p>​    printf(“FAILED，a+不能打开不存在的文件\n”);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    printf(“SUCCESS，a+能打开不存在的文件\n”);</p>
<p>  }</p>
<p>}</p>
<p>（2）新建Makefile，写入以下内容</p>
<p>CC:&#x3D;gcc</p>
<p>fopen_test: fopen_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>说明：</p>
<p>① 有时编译器不只是gcc，我们将编译器定义为变量CC，当切换编译器时只需要更改该变量的定义，而无须更改整个Makefile。</p>
<p>② $@相当于当前target目标文件的名称，此处为fopen_test。</p>
<p>③ $^相当于当前target所有依赖文件列表，此处为fopen_test.c</p>
<p>④ .&#x2F;$@的作用是执行目标文件</p>
<p>⑤ rm .&#x2F;$@的作用是在执行完毕后删除目标文件，如果没有这个操作，当源文件fopen_test.c未更改时就无法重复执行，会提示：make：“fopen_test”已是最新。此处删除目标文件，使得我们在不更改源文件的情况下可以多次执行。</p>
<p>⑥ 所有命令前都添加了“-”符号以忽略错误，确保即便上面的命令执行失败，仍然会向下执行。这样做是为了在发生错误时，确保删除目标文件，使得再次执行相同target时不会提示：make：“fopen_test”已是最新，可以重新执行target下的命令。</p>
<p>（3）执行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps17.jpg" alt="img"> </p>
<p><strong>2）</strong><em><strong>*fclose*</strong></em></p>
<p>（1）创建fclose_test.c文件，写入以下内容。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;* 打开文件</p>
<p>  char *__restrict __filename: 字符串表示要打开文件的路径和名称</p>
<p>  char *__restrict __modes: 字符串表示访问模式</p>
<p>​    (1)”r”: 只读模式 没有文件打开失败</p>
<p>​    (2)”w”: 只写模式 存在文件写入会清空文件,不存在文件则创建新文件</p>
<p>​    (3)”a”: 只追加写模式 不会覆盖原有内容 新内容写到末尾</p>
<p>​    (4)”r+”: 读写模式 文件必须存在 写入是从头一个一个覆盖</p>
<p>​    (5)”w+”: 读写模式 可读取,写入同样会清空文件内容或创建新文件</p>
<p>​    (6)”a+”: 读写追加模式 可读取,写入从文件末尾开始</p>
<p>  return: FILE * 结构体指针 表示一个文件 出错返回NULL</p>
<p>  FILE *fopen (const char *__restrict __filename,</p>
<p>​      const char *__restrict __modes)</p>
<p>  *&#x2F;</p>
<p>  char *filename &#x3D; “io1.txt”;</p>
<p>  FILE *ioFile &#x3D; fopen(filename,”r”);</p>
<p>  if (ioFile &#x3D;&#x3D; NULL)</p>
<p>  {</p>
<p>​    printf(“r不能打开不存在的文件\n”);</p>
<p>  }else{</p>
<p>​    printf(“r能打开不存在的文件\n”);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  FILE *__stream: 需要关闭的文件</p>
<p>  return: 成功返回0 失败返回EOF(负数) 通常失败会造成系统崩溃</p>
<p>  int fclose (FILE *__stream)</p>
<p>  *&#x2F;</p>
<p>  int result &#x3D; fclose(ioFile);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“关闭文件失败”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile中补充以下内容</p>
<p>fclose_test: fclose_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）执行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps18.jpg" alt="img"> </p>
<h4 id="2-1-2-向文件中写入数据"><a href="#2-1-2-向文件中写入数据" class="headerlink" title="2.1.2 向文件中写入数据"></a>2.1.2 <strong>向文件中写入数据</strong></h4><p><strong>1）</strong><em><strong>*fputc*</strong></em> <em><strong>*函数*</strong></em></p>
<p>（1）创建fputc_test.c文件，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;* 打开文件</p>
<p>  char *__restrict __filename: 字符串表示要打开文件的路径和名称</p>
<p>  char *__restrict __modes: 字符串表示访问模式</p>
<p>​    (1)”r”: 只读模式 没有文件打开失败</p>
<p>​    (2)”w”: 只写模式 存在文件写入会清空文件,不存在文件则创建新文件</p>
<p>​    (3)”a”: 只追加写模式 不会覆盖原有内容 新内容写到末尾</p>
<p>​    (4)”r+”: 读写模式 文件必须存在 写入是从头一个一个覆盖</p>
<p>​    (5)”w+”: 读写模式 可读取,写入同样会清空文件内容或创建新文件</p>
<p>​    (6)”a+”: 读写追加模式 可读取,写入从文件末尾开始</p>
<p>  return: FILE * 结构体指针 表示一个文件 出错返回NULL</p>
<p>  FILE *fopen (const char *__restrict __filename,</p>
<p>​      const char *__restrict __modes)</p>
<p>  *&#x2F;</p>
<p>  char *filename &#x3D; “io.txt”;</p>
<p>  FILE *ioFile &#x3D; fopen(filename,”a+”);</p>
<p>  if (ioFile &#x3D;&#x3D; NULL)</p>
<p>  {</p>
<p>​    printf(“a+不能打开不存在的文件\n”);</p>
<p>  }else{</p>
<p>​    printf(“a+能打开不存在的文件\n”);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  写入文件一个字符</p>
<p>  int __c: 写入的char按照AICII值写入 可提前声明一个char</p>
<p>  FILE *__stream: 要写入的文件,写在哪里取决于访问模式</p>
<p>  return: 成功返回char的值 失败返回EOF</p>
<p>  int fputc (int __c, FILE *__stream)</p>
<p>  *&#x2F;</p>
<p>  int putcR &#x3D; fputc(97,ioFile);</p>
<p>  if (putcR &#x3D;&#x3D; EOF)</p>
<p>  {</p>
<p>​    printf(“写入字符失败\n”);</p>
<p>  }else{</p>
<p>​    printf(“写入字符成功:%c\n”,putcR);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  FILE *__stream: 需要关闭的文件</p>
<p>  return: 成功返回0 失败返回EOF(负数) 通常失败会造成系统崩溃</p>
<p>  int fclose (FILE *__stream)</p>
<p>  *&#x2F;</p>
<p>  int result &#x3D; fclose(ioFile);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“关闭文件失败”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）在Makefile中补充以下内容</p>
<p>fputc_test: fputc_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行代码查看结果</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps19.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps20.jpg" alt="img"> </p>
<p><strong>2）</strong><em><strong>*f*</strong></em><em><strong>*puts*</strong></em> <em><strong>*函数*</strong></em></p>
<p>（1）创建fputs_test.c文件，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;* 打开文件</p>
<p>  char *__restrict __filename: 字符串表示要打开文件的路径和名称</p>
<p>  char *__restrict __modes: 字符串表示访问模式</p>
<p>​    (1)”r”: 只读模式 没有文件打开失败</p>
<p>​    (2)”w”: 只写模式 存在文件写入会清空文件,不存在文件则创建新文件</p>
<p>​    (3)”a”: 只追加写模式 不会覆盖原有内容 新内容写到末尾</p>
<p>​    (4)”r+”: 读写模式 文件必须存在 写入是从头一个一个覆盖</p>
<p>​    (5)”w+”: 读写模式 可读取,写入同样会清空文件内容或创建新文件</p>
<p>​    (6)”a+”: 读写追加模式 可读取,写入从文件末尾开始</p>
<p>  return: FILE * 结构体指针 表示一个文件 出错返回NULL</p>
<p>  FILE *fopen (const char *__restrict __filename,</p>
<p>​      const char *__restrict __modes)</p>
<p>  *&#x2F;</p>
<p>  char *filename &#x3D; “io.txt”;</p>
<p>  FILE *ioFile &#x3D; fopen(filename,”a+”);</p>
<p>  if (ioFile &#x3D;&#x3D; NULL)</p>
<p>  {</p>
<p>​    printf(“a+不能打开不存在的文件\n”);</p>
<p>  }else{</p>
<p>​    printf(“a+能打开不存在的文件\n”);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  写入文件一个字符串</p>
<p>  char *__restrict __s: 需要写入的字符串</p>
<p>  FILE *__restrict __stream: 要写入的文件,写在哪里取决于访问模式</p>
<p>  return: 成功返回非负整数(一般是0,1) 失败返回EOF</p>
<p>  int fputs (const char *__restrict __s, FILE *__restrict __stream)</p>
<p>  *&#x2F;</p>
<p>  int putsR &#x3D; fputs(“ love letter\n”,ioFile);</p>
<p>  if (putsR &#x3D;&#x3D; EOF)</p>
<p>  {</p>
<p>​    printf(“写入字符串失败\n”);</p>
<p>  }else{</p>
<p>​    printf(“写入字符串成功:%d\n”,putsR);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  FILE *__stream: 需要关闭的文件</p>
<p>  return: 成功返回0 失败返回EOF 通常失败会造成系统崩溃</p>
<p>  int fclose (FILE *__stream)</p>
<p>  *&#x2F;</p>
<p>  int result &#x3D; fclose(ioFile);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“关闭文件失败”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）在Makefile中写入以下内容</p>
<p>fputs_test: fputs_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行代码查看结果</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps21.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps22.jpg" alt="img"> </p>
<p><strong>3）</strong><em><strong>*fprintf*</strong></em> <em><strong>*函数*</strong></em></p>
<p>（1）创建fprintf_test.c文件，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;* 打开文件</p>
<p>  char *__restrict __filename: 字符串表示要打开文件的路径和名称</p>
<p>  char *__restrict __modes: 字符串表示访问模式</p>
<p>​    (1)”r”: 只读模式 没有文件打开失败</p>
<p>​    (2)”w”: 只写模式 存在文件写入会清空文件,不存在文件则创建新文件</p>
<p>​    (3)”a”: 只追加写模式 不会覆盖原有内容 新内容写到末尾</p>
<p>​    (4)”r+”: 读写模式 文件必须存在 写入是从头一个一个覆盖</p>
<p>​    (5)”w+”: 读写模式 可读取,写入同样会清空文件内容或创建新文件</p>
<p>​    (6)”a+”: 读写追加模式 可读取,写入从文件末尾开始</p>
<p>  return: FILE * 结构体指针 表示一个文件 出错返回NULL</p>
<p>  FILE *fopen (const char *__restrict __filename,</p>
<p>​      const char *__restrict __modes)</p>
<p>  *&#x2F;</p>
<p>  char *filename &#x3D; “io.txt”;</p>
<p>  FILE *ioFile &#x3D; fopen(filename,”a+”);</p>
<p>  if (ioFile &#x3D;&#x3D; NULL)</p>
<p>  {</p>
<p>​    printf(“a+不能打开不存在的文件\n”);</p>
<p>  }else{</p>
<p>​    printf(“a+能打开不存在的文件\n”);</p>
<p>}</p>
<p>  &#x2F;*</p>
<p>  FILE *__restrict __stream: 要写入的文件,写在哪里取决于访问模式</p>
<p>  char *__restrict __fmt: 格式化字符串</p>
<p>  …: 变长参数列表</p>
<p>  return: 成功返回正整数(写入字符总数不包含换行符) 失败返回EOF</p>
<p>  fprintf (FILE *__restrict __stream, const char *__restrict __fmt, …)</p>
<p>  *&#x2F;</p>
<p>  char *name  &#x3D; “大海”;</p>
<p>  int fprintfR &#x3D; fprintf(ioFile, “哎呀,那边窗户透出了什么光?\n那是东方,而你则是太阳!\n升起吧,骄阳,去让忌妒的月黯然失色!\n\t\t%s”, name);</p>
<p>  if (fprintfR &#x3D;&#x3D; EOF) {</p>
<p>​    printf(“写入字符串失败”);</p>
<p>  } else {</p>
<p>​    printf(“写入字符串成功:%d\n”, fprintfR);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  FILE *__stream: 需要关闭的文件</p>
<p>  return: 成功返回0 失败返回EOF(负数) 通常失败会造成系统崩溃</p>
<p>  int fclose (FILE *__stream)</p>
<p>  *&#x2F;</p>
<p>  int result &#x3D; fclose(ioFile);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“关闭文件失败”);</p>
<p>​    fprintf(stderr, “%s\n”, filename);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）在Makefile中写入以下内容</p>
<p>fprintf_test: fprintf_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行查看结果</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps23.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps24.jpg" alt="img"> </p>
<h4 id="2-1-3-从文件中读取数据"><a href="#2-1-3-从文件中读取数据" class="headerlink" title="2.1.3 从文件中读取数据"></a>2.1.3 <strong>从文件中读取数据</strong></h4><p><strong>1）</strong><em><strong>*fgetc*</strong></em> <em><strong>*函数*</strong></em></p>
<p>（1）创建fgetc_test.c文件，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;&#x2F; 打开文件</p>
<p>  FILE *ioFile &#x3D; fopen(“io.txt”,”r”);</p>
<p>  if (ioFile &#x3D;&#x3D; NULL)</p>
<p>  {</p>
<p>​    printf(“不能读不存在的文件”);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  FILE *__stream: 需要读取的文件</p>
<p>  return： 读取的一个字节 到文件结尾或出错返回EOF</p>
<p>  int fgetc (FILE *__stream)</p>
<p>  *&#x2F;</p>
<p>  char c &#x3D; fgetc(ioFile);</p>
<p>  while (c !&#x3D; EOF)</p>
<p>  {</p>
<p>​    printf(“%c”,c);</p>
<p>​    c &#x3D; fgetc(ioFile);</p>
<p>  }</p>
<p>  int result &#x3D; fclose(ioFile);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“关闭文件失败”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）在Makefile中补充以下内容</p>
<p>fgetc_test: fgetc_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行代码查看结果</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps25.jpg" alt="img"> </p>
<p><strong>2）</strong><em><strong>*fget*</strong></em><em><strong>*s*</strong></em> <em><strong>*函数*</strong></em></p>
<p>（1）创建fgets_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;&#x2F; 打开文件</p>
<p>  FILE *ioFile &#x3D; fopen(“io.txt”,”r”);</p>
<p>  if (ioFile &#x3D;&#x3D; NULL)</p>
<p>  {</p>
<p>​    printf(“不能读不存在的文件”);</p>
<p>  }</p>
<p>  &#x2F;*</p>
<p>  char *__restrict __s: 接收读取的数据字符串</p>
<p>  int __n: 能够接收数据的长度</p>
<p>  FILE *__restrict __stream: 需要读取的文件</p>
<p>  return: 成功返回字符串 失败返回NULL(可以直接用于while)</p>
<p>  fgets (char *__restrict __s, int __n, FILE *__restrict __stream)</p>
<p>  *&#x2F;</p>
<p>  char buffer[100];</p>
<p>  while (fgets(buffer, sizeof(buffer), ioFile)) {</p>
<p>​    printf(“%s”, buffer);</p>
<p>  }</p>
<p>  int result &#x3D; fclose(ioFile);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“关闭文件失败”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile中补充以下内容</p>
<p>fgets_test: fgets_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行代码，查看结果</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps26.jpg" alt="img"> </p>
<p><strong>3）</strong><em><strong>*fscanf*</strong></em> <em><strong>*函数*</strong></em></p>
<p>（1）新建文件user.txt，写入以下内容</p>
<p>罗密欧 18 朱丽叶</p>
<p>贾宝玉 14 薛宝钗</p>
<p>梁山伯 16 祝英台</p>
<p>海哥</p>
<p>（2）创建fscanf_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;*</p>
<p>  FILE *__restrict __stream: 读取的文件</p>
<p>  char *__restrict __format: 读取的匹配表达式</p>
<p>  …: 变长参数列表 用于接收匹配的数据</p>
<p>  return: 成功返回参数的个数  失败返回0 报错或结束返回EOF</p>
<p>  int fscanf (FILE *__restrict __stream,  const char *__restrict __format, …)</p>
<p>  *&#x2F;</p>
<p>  FILE *userFile &#x3D; fopen(“user.txt”, “r”);</p>
<p>  if (userFile &#x3D;&#x3D; NULL) {</p>
<p>​    printf(“不能打开不存在的文件”);</p>
<p>  }</p>
<p>  char name[50];</p>
<p>  int age;</p>
<p>  char wife[50];</p>
<p>  int scanfR;</p>
<p>  while (fscanf(userFile, “%s %d %s\n”, name, &amp;age, wife) !&#x3D; EOF) {</p>
<p>​    printf(“%s在%d岁爱上了%s\n”, name, age, wife);</p>
<p>  }</p>
<p>  int result &#x3D; fclose(userFile);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“关闭文件失败”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（3）Makefile补充以下内容</p>
<p>fscanf_test: fscanf_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（4）运行代码，查看结果</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps27.jpg" alt="img"> </p>
<h4 id="2-1-4-标准输入-输出-错误"><a href="#2-1-4-标准输入-输出-错误" class="headerlink" title="2.1.4 标准输入&#x2F;输出&#x2F;错误"></a>2.1.4 <strong>标准输入&#x2F;输出&#x2F;错误</strong></h4><p>读写文件通常用于代码内部操作，如果想要和用户沟通交流，就需要使用标准输入、输出和错误了。</p>
<p>（1）创建文件stdin_out_err_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  &#x2F;&#x2F; malloc动态分配内存  也可以用 char ch[100]接收数据</p>
<p>  char *ch &#x3D; malloc(100);</p>
<p>  &#x2F;&#x2F; char ch1[100];</p>
<p>  &#x2F;*</p>
<p>  stdin: 标准输入FILE *</p>
<p>  *&#x2F;</p>
<p>  fgets(ch, 100, stdin);</p>
<p>  printf(“你好:%s”, ch);</p>
<p>  &#x2F;*</p>
<p>  stdout: 标准输出FILE * 写入这个文件流会将数据输出到控制台</p>
<p>  printf底层就是使用的这个</p>
<p>  *&#x2F;</p>
<p>  fputs(ch, stdout);</p>
<p>  &#x2F;*</p>
<p>  stderr: 错误输出FILE * 一般用于输出错误日志</p>
<p>  *&#x2F;</p>
<p>  fputs(ch, stderr);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile中补充以下内容</p>
<p>stdin_out_err_test: stdin_out_err_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）测试</p>
<p>① 运行代码</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps28.jpg" alt="img"> </p>
<p>② 在控制台输入海哥，会出现对应的标准输出和错误输出：</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps29.jpg" alt="img"> </p>
<h3 id="2-2-系统调用"><a href="#2-2-系统调用" class="headerlink" title="2.2 系统调用"></a>2.2 <strong>系统调用</strong></h3><h4 id="2-2-1-关于系统调用"><a href="#2-2-1-关于系统调用" class="headerlink" title="2.2.1 关于系统调用"></a>2.2.1 <strong>关于系统调用</strong></h4><p>系统调用是操作系统内核提供给应用程序，使其可以间接访问硬件资源的接口，关于操作系统内核、应用程序等概念，我们会在第五章详细阐述。</p>
<h4 id="2-2-2-常见系统调用"><a href="#2-2-2-常见系统调用" class="headerlink" title="2.2.2 常见系统调用"></a>2.2.2 <strong>常见系统调用</strong></h4><p><strong>1）</strong><em><strong>*open*</strong></em></p>
<p>open()系统调用用于打开一个标准的文件描述符。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>&#x2F;*</p>
<p>  const char *__path: 文件路径</p>
<p>  int __oflag: 用于指定打开文件的方式,可以是以下选项的组合:</p>
<p>​    (1) O_RDONLY: 以只读方式打开文件 </p>
<p>​    (2) O_WRONLY: 以只写方式打开文件 </p>
<p>​    (3) O_RDWR: 以读写方式打开文件 </p>
<p>​    (4) O_CREAT: 如果文件不存在,则创建一个新文件 </p>
<p>​    (5) O_APPEND: 将所有写入操作追加到文件的末尾 </p>
<p>​    (6) O_TRUNC: 如果文件存在并且以写入模式打开,则截断文件长度为0 </p>
<p>​    还有其他标志,如O_EXCL（当与O_CREAT一起使用时,只有当文件不存在时才创建新文件）、O_SYNC（同步I&#x2F;O）、O_NONBLOCK（非阻塞I&#x2F;O）等 </p>
<p>  可选参数: mode -&gt; 仅在使用了O_CREAT标志且文件尚不存在的情况下生效,用于指定新创建文件的权限位 权限位通常由三位八进制数字组成,分别代表文件所有者、同组用户和其他用户的读写执行权限</p>
<p>  return: (1) 成功时返回非负的文件描述符。</p>
<p>​      (2) 失败时返回-1，并设置全局变量errno以指示错误原因。</p>
<p>*&#x2F;</p>
<p>int open (const char *__path, int __oflag, …);</p>
<p><strong>2）</strong><em><strong>*read*</strong></em></p>
<p>read()系统调用用于读取已经打开的文件描述符。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;*</p>
<p>  int __fd:一个整数,表示要从中读取数据的文件描述符</p>
<p>  void *__buf:一个指向缓冲区的指针,读取的数据将被存放到这个缓冲区中</p>
<p>  size_t __nbytes:一个size_t类型的整数,表示要读取的最大字节数 系统调用将尝试读取最多这么多字节的数据,但实际读取的字节数可能会少于请求的数量</p>
<p>  return: (1) 成功时,read()返回实际读取的字节数 这个值可能小于__nbytes,如果遇到了文件结尾（EOF）或者因为网络读取等原因提前结束读取 </p>
<p>​      (2) 失败时,read()将返回-1</p>
<p>*&#x2F;</p>
<p>ssize_t read (int __fd, void *__buf, size_t __nbytes);</p>
<p>（1）ssize_t</p>
<p>ssize_t相关的宏定义如下</p>
<p>typedef __ssize_t ssize_t;</p>
<p>__STD_TYPE __SSIZE_T_TYPE __ssize_t;</p>
<p># define __STD_TYPE   typedef</p>
<p>#define __SSIZE_T_TYPE    __SWORD_TYPE</p>
<p># define __SWORD_TYPE    long int</p>
<p>ssize_t是__ssize_t的别名，后者是long int的别名，long是long int的简写，因此，ssize_t实际上是long类型的别名。</p>
<p>（2）size_t</p>
<p>相关定义如下</p>
<p>typedef <strong>SIZE_TYPE</strong> size_t;</p>
<p>#define <strong>SIZE_TYPE</strong> long unsigned int</p>
<p>unsigned long是long unsigned int的简写，size_t实质上是unsigned long。</p>
<p><strong>3）</strong><em><strong>*write*</strong></em></p>
<p>write()系统调用用于对打开的文件描述符写入内容。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;*</p>
<p>  int __fd:一个整数,表示要写入数据的文件描述符</p>
<p>  void *__buf:一个指向缓冲区的指针,写入的数据需要先存放到这个缓冲区中</p>
<p>  size_t __n:一个size_t类型的整数,表示要写入的字节数 write()函数会尝试写入__n个字节的数据,但实际写入的字节数可能会少于请求的数量</p>
<p>  return: (1) 成功时,write()返回实际写入的字节数 这个值可能小于__n,如果写入操作因故提前结束,例如: 磁盘满、网络阻塞等情况 </p>
<p>​      (2) 失败时,write()将返回-1</p>
<p>*&#x2F;</p>
<p>ssize_t write (int __fd, const void *__buf, size_t __n);</p>
<p><strong>4）</strong><em><strong>*close*</strong></em></p>
<p>close()系统调用用于在使用完成之后，关闭对文件描述符的引用。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;*</p>
<p>  int __fd:一个整数,表示要关闭的文件描述符</p>
<p>  return: (1) 成功关闭时 返回0</p>
<p>​      (2) 失败时 返回-1</p>
<p>*&#x2F;</p>
<p>int close (int __fd);</p>
<p><strong>5）</strong><em><strong>*exit和_exit()*</strong></em></p>
<p>（1）系统调用_exit()</p>
<p>_exit()是由POSIX标准定义的系统调用，用于立即终止一个进程，定义在unistd.h中。这个调用确保进程立即退出，不执行任何清理操作。</p>
<p>_exit()在子进程终止时特别有用，这可以防止子进程的终止影响到父进程（比如，防止子进程意外地刷新了父进程未写入的输出缓冲区）。</p>
<p>_exit和_Exit功能一样。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * 立即终止当前进程，且不进行正常的清理操作，如关闭文件、释放内存等。这个函数通常在程序遇到严重错误需要立即退出时使用，或者在某些情况下希望避免清理工作时调用。</p>
<p> * </p>
<p> * int status: 父进程可接收到的退出状态码 0表示成功 非0表示各种不同的错误</p>
<p> *&#x2F;</p>
<p>void _exit(int status);</p>
<p>void _Exit (int __status) ;</p>
<p>（2）库函数exit()</p>
<p>exit()函数是由C标准库提供的，定义在stdlib.h中。</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>&#x2F;**</p>
<p> * 终止当前进程,但是在此之前会执行3种清理操作</p>
<p> * (1) 调用所有通过atexit()注册的终止处理函数(自定义)</p>
<p> * (2) 刷新所有标准I&#x2F;O缓冲区(刷写缓存到文件)</p>
<p> * (3) 关闭所有打开的标准I&#x2F;O流(比如通过fopen打开的文件)</p>
<p> * </p>
<p> * int status: 父进程可接收到的退出状态码 0表示成功 非0表示各种不同的错误</p>
<p> *&#x2F;</p>
<p>void exit(int status);</p>
<p>（3）使用场景</p>
<p>① 通常在父进程中使用exit()，以确保程序在退出前能执行清理操作，如关闭文件和刷新输出。</p>
<p>② 在子进程中，特别是在fork()之后立即调用了一个执行操作（如exec()）但执行失败时，推荐使用_exit()或_Exit()来确保子进程的快速、干净地退出，避免执行标准的清理操作，这些操作可能会与父进程发生冲突或不必要的重复。</p>
<h4 id="2-2-3-综合案例"><a href="#2-2-3-综合案例" class="headerlink" title="2.2.3 综合案例"></a>2.2.3 <strong>综合案例</strong></h4><p>使用标准的系统调用，来对第二章的文件进行简单的读写操作：</p>
<p>（1）创建文件system_call_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt; </p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{ </p>
<p>  int fd &#x3D; open(“io.txt”, O_RDONLY);</p>
<p>  if (fd &#x3D;&#x3D; -1) {</p>
<p>​    perror(“open”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  char buffer[1024]; &#x2F;&#x2F; 创建一个缓冲区来存放读取的数据</p>
<p>  ssize_t bytes_read;</p>
<p>  while ((bytes_read &#x3D; read(fd, buffer, sizeof(buffer))) &gt; 0) {</p>
<p>​    &#x2F;&#x2F; 将读取的数据写入标准输出</p>
<p>​    write(STDOUT_FILENO, buffer, bytes_read);</p>
<p>  }</p>
<p>  if (bytes_read &#x3D;&#x3D; -1) {</p>
<p>​    perror(“read”);</p>
<p>​    close(fd);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  close(fd); &#x2F;&#x2F; 使用完毕后关闭文件描述符</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile中补充以下内容</p>
<p>system_call_test: system_call_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps30.jpg" alt="img"> </p>
<h3 id="2-3-文件描述符"><a href="#2-3-文件描述符" class="headerlink" title="2.3 文件描述符"></a>2.3 <strong>文件描述符</strong></h3><p><strong>1）</strong><em><strong>*定义*</strong></em></p>
<p>在Linux系统中，当我们打开或创建一个文件（或套接字）时，操作系统会提供一个文件描述符（File Descriptor，FD），这是一个非负整数，我们可以通过它来进行读写等操作。</p>
<p>然而，文件描述符本身只是操作系统为应用程序操作底层资源（如文件、套接字等）所提供的一个引用或“句柄”。</p>
<p>在Linux中，文件描述符0、1、2是有特殊含义的。</p>
<p>Ø 0是标准输入（stdin）的文件描述符</p>
<p>Ø 1是标准输出（stdout）的文件描述符</p>
<p>Ø 2是标准错误（stderr）的文件描述符</p>
<p><strong>2）</strong><em><strong>*文件描述符关联的数据结构*</strong></em></p>
<p>（1）struct file</p>
<p>每个文件描述符都关联到内核一个struct file类型的结构体数据，结构体定义位于Linux系统的&#x2F;usr&#x2F;src&#x2F;linux-hwe-6.5-headers-6.5.0-27&#x2F;include&#x2F;linux&#x2F;fs.h文件中，从992行开始。</p>
<p>该结构体的部分关键字段如下。</p>
<p>struct file {</p>
<p>  …… </p>
<p>atomic_long_t f_count;    &#x2F;&#x2F; 引用计数，管理文件对象的生命周期</p>
<p>  struct mutex f_pos_lock;   &#x2F;&#x2F; 保护文件位置的互斥锁</p>
<p>  loff_t f_pos;         &#x2F;&#x2F; 当前文件位置（读写位置）</p>
<p>  …… </p>
<p>struct path f_path;      &#x2F;&#x2F; 记录文件路径</p>
<p>  struct inode *f_inode;        &#x2F;&#x2F; 指向与文件相关联的inode对象的指针，该对象用于维护文件元数据，如文件类型、访问权限等</p>
<p>  const struct file_operations *f_op; &#x2F;&#x2F; 指向文件操作函数表的指针，定义了文件支持的操作，如读、写、锁定等</p>
<p>  …… </p>
<p>void *private_data;          &#x2F;&#x2F; 存储特定驱动或模块的私有数据</p>
<p>  ……</p>
<p>} __randomize_layout</p>
<p>  <strong>attribute</strong>((aligned(4)));</p>
<p>这个数据结构记录了与文件相关的所有信息，其中比较关键的是f_path记录了文件的路径信息，f_inode，记录了文件的元数据。</p>
<p>（2）struct path</p>
<p>结构体定义位于Linux系统的&#x2F;usr&#x2F;src&#x2F;linux-hwe-6.5-headers-6.5.0-27&#x2F;include&#x2F;linux&#x2F;path.h文件中，从第8行开始。</p>
<p>struct path {</p>
<p>  struct vfsmount *mnt;</p>
<p>  struct dentry *dentry;</p>
<p>} __randomize_layout;</p>
<p>该结构体只有两个属性，这里不再通过定义展开。</p>
<p>Ø struct vfsmount：是虚拟文件系统挂载点的表示，存储有关挂载文件系统的信息。</p>
<p>Ø struct dentry：目录项结构体，代表了文件系统中的一个目录项。目录项是文件系统中的一个实体，通常对应一个文件或目录的名字。通过这个类型的属性，可以定位文件位置。</p>
<p>（3）struct inode</p>
<p>结构体定义位于Linux系统的&#x2F;usr&#x2F;src&#x2F;linux-hwe-6.5-headers-6.5.0-27&#x2F;include&#x2F;linux&#x2F;fs.h文件中，从639行开始。</p>
<p>struct inode结构的部分定义如下。</p>
<p>struct inode {</p>
<p>  umode_t i_mode; &#x2F;&#x2F; 文件类型和权限。这个字段指定了文件是普通文件、目录、字符设备、块设备等，以及它的访问权限（读、写、执行）。</p>
<p>  unsigned short i_opflags;</p>
<p>  kuid_t i_uid; &#x2F;&#x2F; 文件的用户ID，决定了文件的拥有者。</p>
<p>  kgid_t i_gid; &#x2F;&#x2F; 文件的组ID，决定了文件的拥有者组。</p>
<p>  unsigned int i_flags;</p>
<p>  …… </p>
<p>unsigned long i_ino; &#x2F;&#x2F; inode编号，是文件系统中文件的唯一标识。</p>
<p>  …… </p>
<p>loff_t i_size;    &#x2F;&#x2F; 文件大小</p>
<p>} __randomize_layout;</p>
<p><strong>3）</strong><em><strong>*文件描述符表关联的数据结构*</strong></em></p>
<p>（1）打开的文件表数据结构</p>
<p>struct files_struct是用来维护一个进程（下文介绍）中所有打开文件信息的。</p>
<p>结构体定义位于&#x2F;usr&#x2F;src&#x2F;linux-hwe-6.5-headers-6.5.0-27&#x2F;include&#x2F;linux&#x2F;fdtable.h文件中，从49行开始。</p>
<p>部分字段如下。</p>
<p>struct files_struct {</p>
<p>  …… </p>
<p>  struct fdtable __rcu *fdt;  &#x2F;&#x2F; 指向当前使用的文件描述符表（fdtable）</p>
<p>  …… </p>
<p>  unsigned int next_fd;     &#x2F;&#x2F; 存储下一个可用的最小文件描述符编号</p>
<p>  …… </p>
<p>  struct file __rcu *fd_array[NR_OPEN_DEFAULT]; &#x2F;&#x2F; struct file指针的数组，大小固定，用于快速访问。</p>
<p>};</p>
<p>fdt维护了文件描述符表，其中记录了所有打开的文件描述符和struct file的对应关系。</p>
<p>（2）打开文件描述符表</p>
<p>打开文件描述符表底层的数据结构是struct fdtable。</p>
<p>结构体定义位于&#x2F;usr&#x2F;src&#x2F;linux-hwe-6.5-headers-6.5.0-27&#x2F;include&#x2F;linux&#x2F;fdtable.h文件中，从27行开始。如下。</p>
<p>struct fdtable {</p>
<p>  unsigned int max_fds;  &#x2F;&#x2F; 文件描述符数组的容量，即可用的最大文件描述符</p>
<p>  struct file __rcu **fd; &#x2F;&#x2F; 指向struct file指针数组的指针</p>
<p>  unsigned long *close_on_exec;</p>
<p>  unsigned long *open_fds;</p>
<p>  unsigned long *full_fds_bits;</p>
<p>  struct rcu_head rcu;</p>
<p>};</p>
<p>（3）fd_array和fd</p>
<p>fd_array是一个定长数组，用于存储进程最常用的struct file。</p>
<p>fd是一个指针，可以指向任何大小的数组，其大小由max_fds字段控制。它可以根据需要动态扩展，以容纳更多的文件描述符。</p>
<p>当打开文件描述符的数量不多于NR_OPEN_DEFAULT时，fd指向的通常就是fd_array，当文件描述符的数量超过NR_OPEN_DEFAULT时，会发生动态扩容，会将fd_array的内容复制到扩容后的指针数组，fd指向扩容后的指针数组。这一过程是内核控制的。</p>
<p>（4）文件描述符和fd或fd_array的关系</p>
<p>文件描述符是一个非负整数，其值实际上就是其关联的struct file在fd指向的数组或fd_array中的下标。</p>
<p><strong>4）</strong><em><strong>*文件描述符引用图解*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps31.png" alt="img"></p>
<p><strong>5）</strong><em><strong>*小结*</strong></em></p>
<p>当我们执行open()等系统调用时，内核会创建一个新的struct file，这个数据结构记录了文件的元数据（文件类型、权限等）、文件路径、支持的操作等，然后分配文件描述符，将struct file维护在文件描述符表中，最后将文件描述符返回给应用程序。我们可以通过后者对文件执行它所支持的各种函数操作，而这些函数的函数指针都维护在struct file_operations数据结构中。文件描述符实质上是底层数据结构struct file的一个引用或者句柄，它为用户提供了操作底层文件的入口。</p>
<h1 id="第-3-章-进程处理"><a href="#第-3-章-进程处理" class="headerlink" title="第 3 章 进程处理"></a>第 3 章 <strong>进程处理</strong></h1><h3 id="3-1-Linux进程简介"><a href="#3-1-Linux进程简介" class="headerlink" title="3.1 Linux进程简介"></a>3.1 <strong>Linux进程简介</strong></h3><h4 id="3-1-1-什么是进程"><a href="#3-1-1-什么是进程" class="headerlink" title="3.1.1 什么是进程"></a>3.1.1 <strong>什么是进程</strong></h4><p>顾名思义，进程（Process）是正在运行的程序，是操作系统进行资源分配和调度的基本单位。程序是存储在硬盘或内存的一段二进制序列，是静态的，而进程是动态的。进程包括代码、数据以及分配给它的其他系统资源（如文件描述符、网络连接等）。</p>
<p>我们打开的VMWare、开启的浏览器都对应操作系统的一个进程。</p>
<p>在&#x2F;home&#x2F;atguigu下创建process_test目录，本章的所有文件都会放在该目录下。</p>
<h4 id="3-1-2-使用system函数生成子进程"><a href="#3-1-2-使用system函数生成子进程" class="headerlink" title="3.1.2 使用system函数生成子进程"></a>3.1.2 <strong>使用system函数生成子进程</strong></h4><p>system函数是标准库中执行shell指令的函数，可以使用man 3 system命令查看其声明。</p>
<p>（1）创建system_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;*</p>
<p>  根据传入的命令启动一个进程</p>
<p>  参数: 传入可执行的shell命令</p>
<p>  return: 成功返回0 不支持shell返回-1 失败返回非0</p>
<p>  *&#x2F;</p>
<p>  int result &#x3D; system(“ping -c 10 <a target="_blank" rel="noopener" href="http://www.atguigu.com/">www.atguigu.com</a>“);</p>
<p>  if (result !&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“无法执行命令”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>system中的shell命令表示向<a target="_blank" rel="noopener" href="http://www.baidu.com发送10/">www.atguigu.com发送10</a>个ICMP回声请求。-c 10是用来控制ICMP请求次数的，如果不加该参数，ping命令会无限期发送直至用户手动终止。</p>
<p>（2）创建Makefile，写入以下内容。</p>
<p>CC:&#x3D;gcc</p>
<p>system_test: system_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>要注意，****Makefile更改完成后必须保存，否则make执行的还是之前的内容。</strong></p>
<p>（3）ps -ef查看子进程</p>
<p>① 运行程序，system会帮助我们启动一个shell子进程。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps32.jpg" alt="img"> </p>
<p>② 在子进程执行过程中，开启一个终端执行ps -ef指令查看所有进程，可以看到下面的内容：</p>
<p>ps -ef展示的进程是按照进程的pid升序排列的，通常，创建越晚的进程pid越大。因此，我们从下往上找，很快就可以定位刚刚启动的进程。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps33.jpg" alt="img"> </p>
<p>test程序的pid为6176，它启动了子进程6185（sh -c ping -c 10 <a target="_blank" rel="noopener" href="http://www.atguigu.com),这个进程又启动了子进程6186(ping/">www.atguigu.com），这个进程又启动了子进程6186（ping</a> -c 10 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.atguigu.com</a>）</p>
<h3 id="3-2-进程处理相关系统调用"><a href="#3-2-进程处理相关系统调用" class="headerlink" title="3.2 进程处理相关系统调用"></a>3.2 <strong>进程处理相关系统调用</strong></h3><p>system函数用到的系统调用为fork、execve和waitpid，下面我们就来详细介绍以下这几个系统调用。</p>
<h4 id="3-2-1-C标准中的main函数声明"><a href="#3-2-1-C标准中的main函数声明" class="headerlink" title="3.2.1 C标准中的main函数声明"></a>3.2.1 <strong>C标准中的main函数声明</strong></h4><p>C语言标准提供了以下两种main函数声明。</p>
<p>（1）无参数形式</p>
<p>int main(void);</p>
<p>或</p>
<p>int main();</p>
<p>这两种形式都表示main函数不接收命令行参数。在C99标准之前，main函数没有参数的形式被写为int main()，这在某些情况下可能导致与int main(void)行为不完全相同的问题，因为int main()在老式的C语言标准中不明确指出函数是否接受参数。从C99标准开始，推荐使用int main(void)明确指明main函数不接受任何参数，以提高代码的可读性和一致性。</p>
<p>（2）有参数形式</p>
<p>int main(int argc, char *argv[]);</p>
<p>Ø argc：传递给程序的命令行参数的数量</p>
<p>Ø argv：指向字符串数组的指针，存储了命令行参数</p>
<p>Ø argv[0]通常是程序的名称</p>
<p>Ø argv[1]到argv[argc-1]是实际的命令行参数</p>
<h4 id="3-2-2-fork"><a href="#3-2-2-fork" class="headerlink" title="3.2.2 fork"></a>3.2.2 <strong>fork</strong></h4><p><strong>1）</strong><em><strong>*相关系统调用及数据类型*</strong></em></p>
<p>（1）pid_t</p>
<p>关于返回值类型pid_t：这个类型定义在头文件&#x2F;usr&#x2F;include&#x2F;x86-64_64-linux-gnu&#x2F;sys&#x2F;types.h中，定义如下。</p>
<p>&#x2F;&#x2F; 函数定义</p>
<p>__pid_t fork (void)</p>
<p>&#x2F;&#x2F; 类型定义</p>
<p>typedef __pid_t pid_t;</p>
<p>可以看到，pid_t是__pid_t的别名，后者定义在&#x2F;usr&#x2F;include&#x2F;x86-64_64-linux-gnu&#x2F;bits&#x2F;types.h中，相关宏定义如下。</p>
<p>__STD_TYPE __PID_T_TYPE __pid_t;</p>
<p>#define __PID_T_TYPE     __S32_TYPE</p>
<p>#define __S32_TYPE    int</p>
<p>#define __STD_TYPE   typedef</p>
<p>__STD_TYPE预处理后被替换为typedef，__PID_T_TYPE预处理后被替换为int，因此，__pid_t实际上是这样定义的</p>
<p>typedef int __pid_t;</p>
<p>它是int的别名，所以pid_t也是int的别名。</p>
<p>（2）fork()</p>
<p>&#x2F;**</p>
<p> * @brief 创建一个子进程(相当于复制,包括内存空间)</p>
<p> * void: 不需要填写参数</p>
<p> *  </p>
<p> * @return pid_t pid_t(int值) </p>
<p> *  (1) 在父进程中 返回子进程的PID</p>
<p> *  (2) 在子进程中 返回0</p>
<p> *  (3) 发生错误 返回-1</p>
<p> *&#x2F;</p>
<p>pid_t fork(void);</p>
<p>（3）getpid()</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 返回调用进程的PID</p>
<p> * </p>
<p> * @return pid_t 不会失败，必然返回进程PID</p>
<p> *&#x2F;</p>
<p>pid_t getpid(void);</p>
<p>（4）getppid()</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 返回调用进程父进程的PID</p>
<p> * </p>
<p> * @return pid_t 不会失败，必然返回父进程PID，即PPID</p>
<p> *&#x2F;</p>
<p>pid_t getppid(void);</p>
<p><strong>2）</strong><em><strong>*测试例程*</strong></em></p>
<p>（1）创建文件fork_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  printf(“海哥教老学员%d春暖花开!\n”,getpid());</p>
<p>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &lt; 0)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 创建新进程失败</p>
<p>​    printf(“新学员加入失败\n”);</p>
<p>​    return 1;</p>
<p>  }else if (pid &#x3D;&#x3D; 0){</p>
<p>​    &#x2F;&#x2F; 这里往下的代码都是新的子进程的</p>
<p>​    printf(“新学员%d加入成功,他是老学员%d推荐的\n”,getpid(),getppid());</p>
<p>  }else{</p>
<p>​    &#x2F;&#x2F; 这里往下继续运行父进程</p>
<p>​    printf(“老学员%d继续深造,他推荐了%d\n”,getpid(),pid);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile写入以下内容</p>
<p>fork_test: fork_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）执行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps34.jpg" alt="img"> </p>
<p>（4）执行过程分析</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps35.png" alt="img"></p>
<h4 id="3-2-3-文件描述符的引用计数和close"><a href="#3-2-3-文件描述符的引用计数和close" class="headerlink" title="3.2.3 文件描述符的引用计数和close()"></a>3.2.3 <strong>文件描述符的引用计数和close()</strong></h4><p><strong>1）</strong><em><strong>*案例*</strong></em></p>
<p>（1）sleep()</p>
<p>函数原型</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * 整个进程睡眠指定秒数,如果在sleep()期间进程接收到信号,且信号有相应的处理函数,则sleep()可能提前结束,并返回剩余未休眠的时间</p>
<p> * </p>
<p> * int seconds: 暂停的秒数</p>
<p> * return: unsigned int 如果sleep()函数正常执行且休眠时间结束,则返回0;如果sleep()由于接收到信号而被提前唤醒,则返回剩余的未休眠秒数</p>
<p> *&#x2F;</p>
<p>unsigned int sleep(unsigned int seconds);</p>
<p>（2）测试例程</p>
<p>当我们执行fork()系统调用时，子进程会复制父进程的资源，包括文件描述符。思考下面的案例。</p>
<p>创建fork_fd_test.c，写入以下内容。</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt; </p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  &#x2F;&#x2F; fork之前</p>
<p>  &#x2F;&#x2F; 打开一个文件</p>
<p>  int fd &#x3D; open(“io.txt”,O_CREAT | O_WRONLY | O_APPEND ,0644);</p>
<p>  if (fd &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“open”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  char buffer[1024];&#x2F;&#x2F;缓冲区存放写出的数据</p>
<p>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &lt; 0)</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }else if (pid &#x3D;&#x3D; 0){</p>
<p>​    &#x2F;&#x2F; 子进程代码</p>
<p>​    strcpy(buffer,”这是子进程写入的数据!\n”);</p>
<p>  }else {</p>
<p>​    &#x2F;&#x2F; 父进程代码</p>
<p>​    sleep(1);</p>
<p>​    strcpy(buffer,”这是父进程写入的数据!\n”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 父子进程都要执行的代码</p>
<p>  ssize_t bytes_write &#x3D; write(fd,buffer,strlen(buffer));</p>
<p>  if (bytes_write &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“write”);</p>
<p>​    close(fd);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  printf(“写入数据成功\n”);</p>
<p>  &#x2F;&#x2F; 使用完毕之后关闭</p>
<p>  close(fd);</p>
<p>  if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    printf(“子进程写入完毕,并释放文件描述符\n”);</p>
<p>  }else{</p>
<p>​    printf(“父进程写入完毕,并释放文件描述符\n”);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>我们通过open()以写入追加的模式打开了io.txt文件，如果这个文件不存在则创建。查看VScode工作目录&#x2F;home&#x2F;atguigu&#x2F;process_test，不存在io.txt。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps36.jpg" alt="img"> </p>
<p>上述程序的逻辑是：打开io.txt文件，获得文件描述符后，执行fork()创建子进程。分别在父子进程中向文件追加写入，并在写入完成后关闭。为了区分父子进程的操作，我们在父进程中通过sleep()休眠1s。</p>
<p>（3）Makefile</p>
<p>Makefile中写入以下内容。</p>
<p>fork_fd_test: fork_fd_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>2）</strong><em><strong>*测试*</strong></em></p>
<p>（1）执行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps37.jpg" alt="img"> </p>
<p>（2）查看io.txt</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps38.jpg" alt="img"> </p>
<p>（3）分析</p>
<p>子进程复制了父进程的文件描述符fd，二者指向的应是同一个底层文件描述（struct file结构体）。我们发现，子进程通过close()释放文件描述符之后，父进程对于相同的文件描述符执行write()操作仍然成功了。这是为什么？</p>
<p>struct file结构体中有一个属性为引用计数，记录的是与当前struct file绑定的文件描述符数量。close()系统调用的作用是将当前进程中的文件描述符和对应的struct file结构体解绑，使得引用计数减一。如果close()执行之后，引用计数变为0，则会释放struct file相关的所有资源。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps39.png" alt="img"></p>
<h4 id="3-2-4-execve"><a href="#3-2-4-execve" class="headerlink" title="3.2.4 execve"></a>3.2.4 <strong>execve</strong></h4><p><strong>1）</strong><em><strong>*execve单独测试*</strong></em></p>
<p>（1）创建erlou.c </p>
<p>exec系列函数可以在同一个进程中跳转执行另外一个程序，我们先准备一个可执行程序erlou，通过编译erlou.c获得。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt; </p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>  if (argc &lt; 2) {</p>
<p>​    printf(“参数不够,上不了二楼.\n”);</p>
<p>​    return 1; &#x2F;&#x2F; 当没有传入参数时，应返回非零值表示错误</p>
<p>  }</p>
<p>  printf(“我是%s %d,我跟海哥上二楼啦!\n”, argv[1], getpid());</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）创建execve_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  &#x2F;*exec系列函数  父进程跳转进入一个新进程</p>
<p>  推荐使用execve</p>
<p>  char *__path: 需要执行程序的完整路径名</p>
<p>  char *const __argv[]: 指向字符串数组的指针 需要传入多个参数</p>
<p>​    (1) 需要执行的程序命令(同*__path)</p>
<p>​    (2) 执行程序需要传入的参数</p>
<p>​    (3) 最后一个参数必须是NULL</p>
<p>  char *const __envp[]: 指向字符串数组的指针 需要传入多个环境变量参数</p>
<p>​    (1) 环境变量参数 固定格式 key&#x3D;value</p>
<p>​    (2) 最后一个参数必须是NULL</p>
<p>  return: 成功就回不来了 下面的代码都没有意义</p>
<p>​      失败返回-1</p>
<p>  int execve (const char *__path, char *const __argv[], char *const __envp[]) </p>
<p>  *&#x2F;</p>
<p>  char *name &#x3D; “banzhang”;</p>
<p>  printf(“我是%s %d,我现在在一楼\n”,name,getpid());</p>
<p>  &#x2F;&#x2F; 参数没填写够也能完成跳转,错误信息会在新程序中</p>
<p>  &#x2F;&#x2F; char *argv[] &#x3D; {“&#x2F;home&#x2F;atguigu&#x2F;process_test&#x2F;erlou”,NULL};</p>
<p>  char *args[] &#x3D; {“&#x2F;home&#x2F;atguigu&#x2F;process_test&#x2F;erlou”,name,NULL};</p>
<p>  &#x2F;&#x2F; 环境变量可以不传</p>
<p>  &#x2F;&#x2F; char *envp[] &#x3D; {NULL};</p>
<p>  char *envs[] &#x3D; {“PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin”,NULL};</p>
<p>  int re &#x3D; execve(argv[0],args,envs);</p>
<p>  if (re &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    printf(“你没机会上二楼\n”);</p>
<p>​    return -1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（3）Makefile</p>
<p>erlou: erlou.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>execve_test: execve_test.c erlou</p>
<p>  -$(CC) -o $@ $&lt;</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@ .&#x2F;$(word 2, $^)</p>
<p>① $&lt;：取依赖列表的第一个文件，此处是execve_test.c。等价于$(firstword $^)。</p>
<p>② $(word 2, $^)：取依赖列表的第二个文件，此处是erlou，这里也可以用$(lastword $^)表示取依赖列表的最后一个文件，也是erlou。</p>
<p>（4）运行测试</p>
<p>点击运行execve_test即可，结果如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps40.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps41.jpg" alt="img"> </p>
<p><strong>2）</strong><em><strong>*execve+fork*</strong></em></p>
<p>（1）测试例程</p>
<p>可以fork和exec共同使用，实现场景老学员推荐新学员在二楼学习，自己保持不变。</p>
<p>创建fork_execve_test.c，写入以下内容。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  char *name&#x3D;”老学员”;</p>
<p>  printf(“%s%d在一楼精进\n”,name,getpid());</p>
<p>  __pid_t pid &#x3D; fork();</p>
<p>  if (pid &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    printf(“邀请新学员失败!\n”);</p>
<p>  }else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 新学员在这里</p>
<p>​    char *newName &#x3D; “ergou”;</p>
<p>​    char *args[] &#x3D; {“&#x2F;home&#x2F;atguigu&#x2F;process_test&#x2F;erlou”,newName,NULL};</p>
<p>​    char *envs[] &#x3D; {“PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin”,NULL};</p>
<p>​    int re &#x3D; execve(argv[0],args,envs);</p>
<p>​    if (re &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      printf(“新学员上二楼失败\n”);</p>
<p>​      return 1;</p>
<p>​    }</p>
<p>​    </p>
<p>  }else{</p>
<p>​    &#x2F;&#x2F; 老学员在这里</p>
<p>​    printf(“老学员%d邀请完%d之后还是在一楼学习\n”,getpid(),pid);</p>
<p>​    </p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>fork_execve_test: fork_execve_test.c erlou</p>
<p>  -$(CC) -o $@ $(firstword $^)</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@ .&#x2F;$(lastword $^)</p>
<p>（3）运行复合案例</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps42.jpg" alt="img"> </p>
<p>（4）执行过程图解</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps43.png" alt="img"></p>
<h4 id="3-2-5-wait-pid"><a href="#3-2-5-wait-pid" class="headerlink" title="3.2.5 wait****pid"></a>3.2.5 <strong>wait****pid</strong></h4><p>Linux中父进程除了可以启动子进程，还要负责回收子进程的状态。如果子进程结束后父进程没有正常回收，那么子进程就会变成一个僵尸进程——即程序执行完成，但是进程没有完全结束，其内核中PCB结构体（下文介绍）没有释放。在上面的例子中，父进程在子进程结束前就结束了，那么其子进程的回收工作就交给了父进程的父进程的父进程（省略若干父进程）。</p>
<p>本节通过系统调用waitpid在父进程中等待子进程完成并执行回收工作。</p>
<p>（1）函数原型</p>
<p>执行man 2 waitpid查看手册可知声明如下：</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>&#x2F;** 等待子进程的终止并获取子进程的退出状态</p>
<p>*   功能简单 没有选择</p>
<p>*&#x2F;</p>
<p>pid_t wait(int *wstatus);</p>
<p>&#x2F;**</p>
<p> * 功能灵活 可以设置不同的模式 可以等待特定的子进程</p>
<p> * </p>
<p> * pid: 等待的模式</p>
<p> *    (1) 小于-1 例如 -1 * pgid，则等待进程组ID等于pgid的所有进程终止</p>
<p> *    (2) 等于-1 会等待任何子进程终止，并返回最先终止的那个子进程的进程ID -&gt; 儿孙都算</p>
<p> *    (3) 等于0 等待同一进程组中任何子进程终止（但不包括组领导进程） -&gt; 只算儿子</p>
<p> *    (4) 大于0 仅等待指定进程ID的子进程终止</p>
<p> * wstatus: 整数指针，子进程返回的状态码会保存到该int</p>
<p> * options: 选项的值是以下常量之一或多个的按位或（OR）运算的结果;二进制对应选项,可多选：</p>
<p> *    (1) WNOHANG 如果没有子进程终止，也立即返回;用于查看子进程状态而非等待</p>
<p> *    (2) WUNTRACED 收到子进程处于收到信号停止的状态，也返回。</p>
<p> *    (3) WCONTINUED（自Linux 2.6.10起）如果通过发送SIGCONT信号恢复了一个已停止的子进程，则也返回。</p>
<p> * return: (1) 成功等到子进程停止 返回pid</p>
<p> *     (2) 没等到并且没有设置WNOHANG 一直等</p>
<p> *     (3) 没等到设置WNOHANG 返回0</p>
<p> *     (4) 出错返回-1</p>
<p> *&#x2F;</p>
<p>pid_t waitpid(pid_t pid, int *wstatus, int options);</p>
<p>&#x2F;*</p>
<p>  更加全面的子进程监控和状态报告</p>
<p>*&#x2F;</p>
<p>int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</p>
<p>（2）测试例程</p>
<p>创建waitpid_test.c，写入以下内容。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  &#x2F;&#x2F; fork之前</p>
<p>  int subprocess_status;</p>
<p>  printf(“老学员在校区\n”);</p>
<p>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &lt; 0)</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>​    return 1;</p>
<p>  }else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 新学员</p>
<p>​    char *args[] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;ping”,”-c”,”50”,”<a target="_blank" rel="noopener" href="http://www.atguigu.com",null}/">www.atguigu.com&quot;,NULL}</a>;</p>
<p>​    char *envs[] &#x3D; {NULL};</p>
<p>​    printf(“新学员%d联系海哥10次\n”,getpid());</p>
<p>​    int exR &#x3D; execve(args[0],args,envs);   </p>
<p>​    if (exR &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“execve”);</p>
<p>​      return 1;</p>
<p>​    }</p>
<p>​    </p>
<p>  }else {</p>
<p>​    &#x2F;&#x2F; 老学员</p>
<p>​    printf(“老学员%d等待新学员%d联系\n”,getpid(),pid);</p>
<p>​    waitpid(pid,&amp;subprocess_status,0);</p>
<p>  }</p>
<p>  printf(“老学员等待新学员联系完成\n”);</p>
<p>  return 0;</p>
<p>}</p>
<p>waitpid(pid, &amp;subprocess_status, 0)执行之后将会一直挂起父进程（调用者）的执行，直至子进程pid终止。</p>
<p>（3）Makefile</p>
<p>waitpid_test: waitpid_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（4）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps44.jpg" alt="img"> </p>
<p>（5）在运行的过程中使用ps -ef | grep ping查看进程</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps45.jpg" alt="img"> </p>
<p>此时父进程没有结束，而是在等待子进程</p>
<p>（6）子进程执行完毕后，重新查看进程</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps46.jpg" alt="img"> </p>
<p>此时父进程和子进程全部销毁，父进程在子进程结束后回收了它，然后运行结束，由其父进程回收。</p>
<h4 id="3-2-6-进程树"><a href="#3-2-6-进程树" class="headerlink" title="3.2.6 进程树"></a>3.2.6 <strong>进程树</strong></h4><p>Linux的进程是通过父子关系组织起来的，所有进程之间的父子关系共同构成了进程树（Process Tree）。进程树中每个节点都是其上级节点的子进程，同时又是子结点的父进程。一个进程的父进程只能有一个，而一个进程的子进程可以不止一个。</p>
<p><strong>1）</strong><em><strong>*创建pstree_test.c，写入以下内容*</strong></em></p>
<p>以下程序是在fork_execve_test.c的基础上做了改动，通过fgetc()阻塞父进程的执行，确保测试期间父进程不会退出。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  char *name&#x3D;”老学员”;</p>
<p>  printf(“%s%d在一楼精进\n”,name,getpid());</p>
<p>  __pid_t pid &#x3D; fork();</p>
<p>  if (pid &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    printf(“邀请新学员失败!\n”);</p>
<p>  }else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 新学员在这里</p>
<p>​    char *newName &#x3D; “ergou”;</p>
<p>​    char *argv[] &#x3D; {“&#x2F;home&#x2F;atguigu&#x2F;process_test&#x2F;erlou”,newName,NULL};</p>
<p>​    char *envp[] &#x3D; {“PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin”,NULL};</p>
<p>​    int re &#x3D; execve(argv[0],argv,envp);</p>
<p>​    if (re &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      printf(“新学员上二楼失败\n”);</p>
<p>​      return 1;</p>
<p>​    }</p>
<p>​    </p>
<p>  }else{</p>
<p>​    &#x2F;&#x2F; 老学员在这里</p>
<p>​    printf(“老学员%d邀请完%d之后还是在一楼学习\n”,getpid(),pid);</p>
<p>​    &#x2F;&#x2F; 等待新学员二楼结束 手动输入一个字母结束等待</p>
<p>​    char bye &#x3D; fgetc(stdin);</p>
<p>​    </p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>pstree_test: pstree_test.c erlou</p>
<p>  -$(CC) -o $@ $&lt;</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@ .&#x2F;$(lastword $^)</p>
<p><strong>3）</strong><em><strong>*运行测试*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps47.jpg" alt="img"> </p>
<p>（1）此时在终端命令行执行ps -ef查看进程</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps48.jpg" alt="img"> </p>
<p>此时通过fork()和execve()启动的子进程共存，我们可以追溯main进程的父级进程，上推可以看到其三级父进程的pid为11614。</p>
<p>（2）执行命令ps -ef | grep 11614</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps49.jpg" alt="img"> </p>
<p>（3）执行命令ps -ef | grep 11612</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps50.jpg" alt="img"> </p>
<p>（4）执行命令ps -ef | grep 10295</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps51.jpg" alt="img"> </p>
<p>（5）执行命令ps -ef | grep 3444</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps52.jpg" alt="img"> </p>
<p>（6）执行命令ps -ef | grep 3316</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps53.jpg" alt="img"> </p>
<p>（7）执行命令ps -ef | grep 1582</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps54.jpg" alt="img"> </p>
<p>可以看到pid为1582的进程，它的父进程为1号进程，这个进程是操作系统的第一个进程，是所有其它进程的父进程</p>
<p>（8）执行命令ps -ef</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps55.jpg" alt="img"> </p>
<p>可以看到pid为1的进程是由&#x2F;sbin&#x2F;init splash命令创建的。</p>
<p>（9）执行ll &#x2F;sbin&#x2F;init</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps56.jpg" alt="img"> </p>
<p>实质上，1号进程就是systemd，它由内核创建，是第一个进程，负责初始化系统，启动其他所有用户空间的服务和进程。它是所有进程的祖先。</p>
<p>在ps -ef的输出结果中，我们发现，CMD部分有的行带有[]，而有的没有，前者属于内核线程，内核线程在内核空间执行，不占用任何用户空间资源，它们在技术上是线程，而在许多方面表现得像独立的进程，因此也会被ps命令检索到。第一个内核线程的pid为2，它是所有其它内核线程的祖先。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps57.jpg" alt="img"> </p>
<p>此外，pid为1的进程和pid为2的内核线程，它们的父进程id均为0，这是因为二者都是由内核直接创建，都是“祖先”，不存在“辈分”更大的进程或内核线程。</p>
<p>（10）pstree查看进程树</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps58.jpg" alt="img"> </p>
<p>pstree命令会以树状图展示所有用户进程的依赖关系，可以看到，systemd是所有用户进程的祖先。</p>
<p>（11）pstree -p查看进程树</p>
<p>-p表示显示进程号</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps59.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps60.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps61.jpg" alt="img"> </p>
<p>可以看到，ping进程的父子关系正如我们通过ps -ef | grep [pid]的方式逐级检索查明的那样。</p>
<h4 id="3-2-7-孤儿进程"><a href="#3-2-7-孤儿进程" class="headerlink" title="3.2.7 孤儿进程"></a>3.2.7 <strong>孤儿进程</strong></h4><p>孤儿进程（Orphan Process）是指父进程已结束或终止，而它仍在运行的进程。</p>
<p>当父进程结束之前没有等待子进程结束，且父进程先于子进程结束时，那么子进程就会变成孤儿进程。</p>
<p>（1）创建erlou_block.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>  if (argc &lt; 2)</p>
<p>  {</p>
<p>​    printf(“参数不够,上不了二楼.\n”);</p>
<p>​    return 1; &#x2F;&#x2F; 当没有传入参数时，应返回非零值表示错误</p>
<p>  }</p>
<p>  printf(“我是%s %d,我跟海哥上二楼啦!\n”, argv[1], getpid());</p>
<p>  &#x2F;&#x2F; 挂起子进程</p>
<p>  sleep(100);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）创建orphan_process_test.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  char *name &#x3D; “老学员”;</p>
<p>  printf(“%s%d在一楼精进\n”, name, getpid());</p>
<p>  __pid_t pid &#x3D; fork();</p>
<p>  if (pid &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    printf(“邀请新学员失败!\n”);</p>
<p>  }</p>
<p>  else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 新学员在这里</p>
<p>​    char *newName &#x3D; “ergou”;</p>
<p>​    char *argv[] &#x3D; {“&#x2F;home&#x2F;atguigu&#x2F;process_test&#x2F;erlou_block”, newName, NULL};</p>
<p>​    char *envp[] &#x3D; {“PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin”, NULL};</p>
<p>​    int re &#x3D; execve(argv[0], argv, envp);</p>
<p>​    if (re &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      printf(“新学员上二楼失败\n”);</p>
<p>​      return 1;</p>
<p>​    }</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 老学员在这里</p>
<p>​    printf(“老学员%d邀请完%d之后还是在一楼学习\n”, getpid(), pid);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（3）Makefile</p>
<p>erlou_block: erlou_block.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>orphan_process_test: orphan_process_test.c erlou_block</p>
<p>  -$(CC) -o $@ $&lt;</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@ .&#x2F;$(word 2, $^)</p>
<p>（4）重新执行程序</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps62.jpg" alt="img"> </p>
<p>（5）在终端命令行通过ps -ef  | grep 12463查看进程</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps63.jpg" alt="img"> </p>
<p>可以看到子进程已被其祖先领养，此时的进程树如下（进程树过长，省略无关紧要的部分）</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps64.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps65.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps66.jpg" alt="img"> </p>
<p>我们可以得出结论：孤儿进程会被其祖先自动领养。此时的子进程因为和终端切断了联系，所以很难再进行标准输入使其停止了，所以写代码的时候一定要注意避免出现孤儿进程。</p>
<h3 id="3-3-进程间通信"><a href="#3-3-进程间通信" class="headerlink" title="3.3 进程间通信"></a>3.3 <strong>进程间通信</strong></h3><p>进程之前的内存是隔离的，如果多个进程之间需要进行信息交换，常用的方法有以下几种：</p>
<p>（1）Unix Domain Socket IPC</p>
<p>（2）管道（有名管道、无名管道）</p>
<p>（3）共享内存</p>
<p>（4）消息队列</p>
<p>（5）信号量</p>
<p>此处提到的Unix Domain Socket IPC和信号量放在后面的章节讲解。</p>
<h4 id="1-1-1-SystemV-IPC和POSIX-IPC"><a href="#1-1-1-SystemV-IPC和POSIX-IPC" class="headerlink" title="1.1.1 SystemV IPC和POSIX IPC"></a>1.1.1 <strong>SystemV IPC和POSIX IPC</strong></h4><p><strong>1）</strong><em><strong>*System V*</strong></em></p>
<p>System V（读作System Five）是一种基于UNIX的操作系统版本，最初由AT&amp;T（American TelePhone and Telegraph Company，美国电话电报公司，由Bell TelePhone Company发展而来）开发。它在1983年首次发布，对UNIX操作系统的发展产生了深远的影响。SystemV引入了许多新的特性和标准，后来被许多UNIX系统和类UNIX系统（如Linux）采纳。</p>
<p><strong>2）</strong><em><strong>*System V IPC*</strong></em></p>
<p>System V IPC（Inter-Process Communication，进程间通信）是System V操作系统引入的一组进程间通信机制，包括<strong>消息队列</strong>、<strong>信号量</strong>和<strong>共享内存</strong>。这些机制允许不同的进程以一种安全且高效的方式共享数据和同步操作。</p>
<p>（1）消息队列：允许进程以消息的形式交换数据，这些消息存储在队列中，直到它们被接收。</p>
<p>（2）信号量：主要用于进程间的同步，防止多个进程同时访问相同的资源。</p>
<p>（3）共享内存：允许多个进程访问同一块内存区域，提供了一种非常高效的数据共享方式。</p>
<p>System V IPC是UNIX和类UNIX系统中常用的IPC方法之一，它<strong>通过关键字</strong>（key）来标识和访问IPC资源。</p>
<p><strong>3）</strong><em><strong>*POSIX IPC*</strong></em></p>
<p>POSIX IPC是POSIX标准中的一部分，提供了一种更现代和标准化的进程间通信方式，同样包括消息队列、信号量和共享内存三种方式。</p>
<p>（1）消息队列：类似于System V，但通常具有更简洁的API和更好的错误处理能力。</p>
<p>（2）信号量：提供了更多的功能和更高的性能，支持更大范围的操作。</p>
<p>（3）共享内存：提供了更多的控制和配置选项，以支持更复杂的应用场景。</p>
<p>POSIX IPC 使用名字（name）作为唯一标识。这些名字通常是以正斜杠（&#x2F;）开头的字符串，用于唯一地识别资源如消息队列、信号量或共享内存对象。</p>
<p><strong>4）</strong><em><strong>*二者的比较*</strong></em></p>
<p>System V IPC和POSIX IPC在功能上有所重叠，但它们在实现和API设计上有明显的区别。POSIX IPC通常被视为更现代、更标准化的解决方案，提供了更好的跨平台支持和更易于使用的API。然而，System V IPC在历史上更早地被大量UNIX系统所采用，因此在一些旧的或特定的环境中仍然非常重要。在选择使用哪种IPC机制时，应考虑应用程序的具体需求、目标系统的支持程度以及开发者的熟悉程度。</p>
<p>System V IPC和POSIX IPC各自提供了一组API，如果全部介绍未免太过冗长，他们实现的效果是类似的。本文只介绍POSIX IPC提供的API。</p>
<h4 id="1-1-2-匿名管道（Pipe）"><a href="#1-1-2-匿名管道（Pipe）" class="headerlink" title="1.1.2 匿名管道（Pipe）"></a>1.1.2 <strong>匿名管道（Pipe）</strong></h4><p><strong>5）</strong><em><strong>*库函数perror()*</strong></em></p>
<p>（1）创建perror_test.c，写入以下内容。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  &#x2F;**</p>
<p>   * 输出错误信息报告到系统的错误输出</p>
<p>   * char *__s: 自定义的错误信息前缀 会打印在输出的前面 中间补充”: “ 后面跟errno</p>
<p>   * 隐藏参数: errno 用于保存错误信息的全局变量 系统调用和库函数出错会将信息存储到这里</p>
<p>   * void perror (const char *__s)</p>
<p>  *&#x2F;</p>
<p>  fopen(“bucunzai.txt”,”r”);</p>
<p>  perror(“这道题我不会做! “);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>perror_test: perror_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps67.jpg" alt="img"> </p>
<p>（4）分析</p>
<p>当系统调用或库函数发生错误时，通常会通过设置全局变量errno来指示错误的具体原因。errno是在C语言（及其在Unix、Linux系统下的应用）中用来存储错误号的一个全局变量。每当系统调用或某些库函数遇到错误，无法正常完成操作时，它会将一个错误代码存储到errno中。这个错误代码提供了失败的具体原因，程序可以通过检查errno的值来确定发生了什么错误，并据此进行相应的错误处理。</p>
<p>errno定义在头文件&lt;errno.h&gt;中，引入该文件即可调用全局变量errno。</p>
<p>perror函数用于将errno当前值对应的错误描述以人类可读的形式输出到标准错误输出（stderr）。</p>
<p>参数s：指向一个字符串的指针，如果s不是空指针且指向的不是\0字符，则perror会在s后添加一个冒号和空格作为前缀，输出错误信息，否则不输出前缀，直接输出错误信息。</p>
<p>（5）创建errno_test.c</p>
<p>#include &lt;errno.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main() {</p>
<p>  fopen(“&#x2F;opt”, “a+”);</p>
<p>  printf(“errno: %d\n”, errno);</p>
<p>  perror(“文件打开出问题”);</p>
<p>  return 0;</p>
<p>}</p>
<p>（6）Makefile</p>
<p>errno_test: errno_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（7）运行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps68.jpg" alt="img"> </p>
<p><strong>6）</strong><em><strong>*系统调用pipe()*</strong></em></p>
<p>匿名管道是位于内核的一块缓冲区，用于进程间通信。创建匿名管道的系统调用为pipe。执行man 2 pipe查看手册，其声明如下：</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * 在内核空间创建管道，用于父子进程或者其他相关联的进程之间通过管道进行双向的数据传输。。</p>
<p> * </p>
<p> * pipefd: 用于返回指向管道两端的两个文件描述符。pipefd[0]指向管道的读端。pipefd[1]指向管道的写端。</p>
<p> * return: 成功  0</p>
<p> *     不成功 -1，并且pipefd不会改变</p>
<p> *&#x2F;</p>
<p>int pipe(int pipefd[2]);</p>
<p><strong>7）</strong><em><strong>*匿名管道测试例程*</strong></em></p>
<p>（1）宏定义EXIT_FAILURE、EXIT_SUCCESS 、STDOUT_FILENO</p>
<p>#define EXIT_FAILURE   1  &#x2F;* Failing exit status.  *&#x2F;</p>
<p>#define EXIT_SUCCESS   0  &#x2F;* Successful exit status.  *&#x2F;</p>
<p>#define STDIN_FILENO   0  &#x2F;* Standard input.  *&#x2F;</p>
<p>#define STDOUT_FILENO  1  &#x2F;* Standard output.  *&#x2F;</p>
<p>#define STDERR_FILENO  2  &#x2F;* Standard error output.  *&#x2F;</p>
<p>Ø EXIT_FAILURE：表示以失败状态退出进程</p>
<p>Ø EXIT_SUCCESS：表示以成功状态退出进程</p>
<p>Ø STDOUT_FILENO：表示标准输出</p>
<p>（2）创建unnamed_pipe_test.c</p>
<p>下面的例子展示了父进程将argv[1]写入匿名管道，子进程读取并输出到控制台的过程，例程如下。</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int pipefd[2];</p>
<p>  pid_t cpid;</p>
<p>  char buf;</p>
<p>  if (argc !&#x3D; 2)</p>
<p>  {</p>
<p>​    fprintf(stderr, “%s:请填写需要传递的信息\n”, argv[0]);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  if (pipe(pipefd) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“创建管道失败\n”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  cpid &#x3D; fork();</p>
<p>  if (cpid &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“邀请新学员失败!\n”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  if (cpid &#x3D;&#x3D; 0)</p>
<p>  {    </p>
<p>​    &#x2F;&#x2F; 新学员读数据 关闭写端        </p>
<p>​    close(pipefd[1]); </p>
<p>​    char str[100]&#x3D;{0};</p>
<p>​    sprintf(str,”新学员%d收到邀请\n”,getpid());</p>
<p>​    write(STDOUT_FILENO, str, sizeof(str));</p>
<p>​    &#x2F;&#x2F; 一直读取读端的数据 单个字节读取方便读取结尾 直到数据结束或出错</p>
<p>​    while (read(pipefd[0], &amp;buf, 1) &gt; 0){</p>
<p>​      &#x2F;&#x2F; 将读取数据写到标准输出</p>
<p>​      write(STDOUT_FILENO, &amp;buf, 1);</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 输出换行</p>
<p>​    write(STDOUT_FILENO, “\n”, 1);</p>
<p>​    close(pipefd[0]);</p>
<p>​    _exit(EXIT_SUCCESS);</p>
<p>  }</p>
<p>  else</p>
<p>  { </p>
<p>​    &#x2F;&#x2F; 老学员写数据 关闭读端</p>
<p>​    close(pipefd[0]); </p>
<p>​    &#x2F;&#x2F; 写入传入的参数到管道的写端</p>
<p>​    printf(“老学员%d发出邀请\n”,getpid());</p>
<p>​    write(pipefd[1], argv[1], strlen(argv[1]));</p>
<p>​    &#x2F;&#x2F; 写完之后关闭写端  读端会返回0</p>
<p>​    close(pipefd[1]); </p>
<p>​    &#x2F;&#x2F; 等待子进程结束</p>
<p>​    waitpid(cpid,NULL,0);    </p>
<p>​    exit(EXIT_SUCCESS);</p>
<p>  }</p>
<p>}</p>
<p>（3）Makefile</p>
<p>unnamed_pipe_test: unnamed_pipe_test.c</p>
<p>  -$(CC) -o $@ $&lt;</p>
<p>  -.&#x2F;$@ “test”</p>
<p>  -rm .&#x2F;$@</p>
<p>需要注意的是，本例中我们需要通过命令行传参程序才能正确执行，-.&#x2F;$@之后的”test”就是传递给程序的命令行参数。</p>
<p>（4）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps69.jpg" alt="img"> </p>
<p>可以看到命令行传入的参数被打印到了终端，我们在上述程序中通过父进程将数据写入了管道，然后子进程从管道读出数据，写入了标准输出，日志如上则测试通过。</p>
<p><strong>8）</strong><em><strong>*使用管道*</strong></em><em><strong>*的*</strong></em><em><strong>*限制：*</strong></em> </p>
<p>（1）两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。</p>
<p>（2）管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。</p>
<p><strong>9）</strong><em><strong>*管道返回的文件描述符*</strong></em></p>
<p>管道返回的两个文件描述符分别表示读写，各自指向一个struct file结构体，然而，它们并不对应真正的文件。</p>
<p>struct file的私有数据指针属性private_data指向struct pipe_inode_info类型的结构体，后者声明位于&#x2F;usr&#x2F;src&#x2F;linux-hwe-6.5-headers-6.5.0-27&#x2F;include&#x2F;linux&#x2F;pipe_fs_i.h，定义如下。</p>
<p>struct pipe_inode_info {</p>
<p>  struct mutex mutex;         &#x2F;&#x2F; 互斥锁，用于同步对管道的访问</p>
<p>  wait_queue_head_t rd_wait, wr_wait; &#x2F;&#x2F; 等待队列，分别用于读操作和写操作的阻塞管理</p>
<p>  unsigned int head;          &#x2F;&#x2F; 管道缓冲区中读取数据的起始位置</p>
<p>  unsigned int tail;          &#x2F;&#x2F; 管道缓冲区中写入数据的结束位置</p>
<p>  unsigned int max_usage;       &#x2F;&#x2F; 管道使用过的最大容量，用于监控和调优</p>
<p>  unsigned int ring_size;       &#x2F;&#x2F; 管道缓冲区的总大小（环形缓冲区的大小）</p>
<p>  unsigned int nr_accounted;      &#x2F;&#x2F; 已记录的管道使用量</p>
<p>  unsigned int readers;        &#x2F;&#x2F; 当前打开管道读端的文件描述符数量</p>
<p>  unsigned int writers;        &#x2F;&#x2F; 当前打开管道写端的文件描述符数量</p>
<p>  unsigned int files;         &#x2F;&#x2F; 总共打开的文件描述符数量</p>
<p>  unsigned int r_counter;       &#x2F;&#x2F; 读操作的计数器</p>
<p>  unsigned int w_counter;       &#x2F;&#x2F; 写操作的计数器</p>
<p>  bool poll_usage;           &#x2F;&#x2F; 标志位，指示是否有进程在使用poll等机制监视管道</p>
<p>#ifdef CONFIG_WATCH_QUEUE</p>
<p>  bool note_loss; &#x2F;&#x2F; 是否记录了通知的丢失（用于调试或特定的资源监控）</p>
<p>#endif</p>
<p>  struct page *tmp_page;         &#x2F;&#x2F; 用于管道操作的临时内存页，通常用于优化读写性能</p>
<p>  struct fasync_struct *fasync_readers; &#x2F;&#x2F; 异步读操作通知结构体，支持SIGIO信号</p>
<p>  struct fasync_struct *fasync_writers; &#x2F;&#x2F; 异步写操作通知结构体，支持SIGIO信号</p>
<p>  struct pipe_buffer *bufs;       &#x2F;&#x2F; 指向管道缓冲区数组的指针，每个元素管理一个缓冲块</p>
<p>  struct user_struct *user;       &#x2F;&#x2F; 指向代表管道拥有者的用户结构体</p>
<p>#ifdef CONFIG_WATCH_QUEUE</p>
<p>  struct watch_queue *watch_queue; &#x2F;&#x2F; 用于管理内核通知队列的结构体（用于高级事件监视功能）</p>
<p>#endif</p>
<p>};</p>
<p>当我们开启管道时，父进程会创建两个struct file结构体用于管道的读写操作，并为二者各自分配一个文件描述符。它们的private_data属性指向同一个struct pipe_inode_info的结构体，由后者管理对于管道缓冲区的读写。通过fork()创建一个子进程，后者会继承文件描述符，指向相同的struct file结构体，如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps70.png" alt="img"></p>
<p><strong>10）</strong><em><strong>*图解*</strong></em></p>
<p>进程间通过管道通信的过程如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps71.png" alt="img"></p>
<h4 id="3-3-1-有名管道（FIFO）"><a href="#3-3-1-有名管道（FIFO）" class="headerlink" title="3.3.1 有名管道（FIFO）"></a>3.3.1 <strong>有名管道（FIFO）</strong></h4><p>上文介绍的Pipe是匿名管道，只能在有父子关系的进程间使用，某些场景下并不能满足需求。与匿名管道相对的是有名管道，在Linux中称为FIFO，即First In First Out，先进先出队列。</p>
<p>FIFO和Pipe一样，提供了双向进程间通信渠道。但要注意的是，无论是有名管道还是匿名管道，<strong>同一条管道只应用于单向通信</strong>，否则可能出现通信混乱（进程读到自己发的数据）。</p>
<p>有名管道可以用于任何进程之间的通信。</p>
<p><strong>1）</strong><em><strong>*库函数mkfifo()*</strong></em></p>
<p>执行man 3 mkfifo查看文件说明。</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 用于创建有名管道。该函数可以创建一个路径为pathname的FIFO专用文件，mode指定了FIFO的权限，FIFO的权限和它绑定的文件是一致的。FIFO和pipe唯一的区别在于创建方式的差异。一旦创建了FIFO专用文件，任何进程都可以像操作文件一样打开FIFO，执行读写操作。</p>
<p> * </p>
<p> * @param pathname 有名管道绑定的文件路径</p>
<p> * @param mode 有名管道绑定文件的权限</p>
<p> * @return int </p>
<p> *&#x2F;</p>
<p>int mkfifo(const char *pathname, mode_t mode);</p>
<p><strong>2）</strong><em><strong>*有名管道发送端*</strong></em></p>
<p>创建fifo_write.c，写入以下内容。</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  int fd;</p>
<p>  char *pipe_path &#x3D; “&#x2F;tmp&#x2F;myfifo”;</p>
<p>  &#x2F;&#x2F; 创建有名管道，权限设置为 0664</p>
<p>  if (mkfifo(pipe_path, 0664) !&#x3D; 0)</p>
<p>  {</p>
<p>​    perror(“mkfifo failed”);</p>
<p>​    if (errno !&#x3D; 17)</p>
<p>​    {</p>
<p>​      exit(EXIT_FAILURE);</p>
<p>​    }</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 打开有名管道用于写入</p>
<p>  fd &#x3D; open(pipe_path, O_WRONLY);</p>
<p>  if (fd &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“open failed”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  char write_buf[100];</p>
<p>  ssize_t read_num;</p>
<p>  while ((read_num &#x3D; read(STDIN_FILENO, write_buf, 100)) &gt; 0) {</p>
<p>​    write(fd, write_buf, read_num);</p>
<p>  }</p>
<p>  if (read_num &lt; 0) {</p>
<p>​    perror(“read”);</p>
<p>​    printf(“命令行数据读取异常，退出”);</p>
<p>​    close(fd);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  printf(“发送管道退出，进程终止\n”);</p>
<p>  close(fd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>3）</strong><em><strong>*有名管道接收端*</strong></em></p>
<p>创建fifo_read.c，写入以下内容。</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main() {</p>
<p>  int fd;</p>
<p>  char *pipe_path &#x3D; “&#x2F;tmp&#x2F;myfifo”;</p>
<p>  &#x2F;&#x2F; 打开有名管道用于读取</p>
<p>  fd &#x3D; open(pipe_path, O_RDONLY);</p>
<p>  if (fd &#x3D;&#x3D; -1) {</p>
<p>​    perror(“open failed”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  char read_buff[100];</p>
<p>  ssize_t read_num;</p>
<p>  while ((read_num &#x3D; read(fd, read_buff, 100)) &gt; 0) {</p>
<p>​    write(STDOUT_FILENO, read_buff, read_num);</p>
<p>  }</p>
<p>  if (read_num &lt; 0) {</p>
<p>​    perror(“read”);</p>
<p>​    printf(“管道数据读取异常，退出”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  printf(“接收管道退出，进程终止\n”);</p>
<p>  close(fd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>4）</strong><em><strong>*Makefile*</strong></em></p>
<p>（1）声明伪目标</p>
<p>在文件开头补充</p>
<p>.PHONY: named_fifo named_fifo_clean</p>
<p>如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps72.jpg" alt="img"> </p>
<p>（2）补充编译和清除target</p>
<p>fifo_write: fifo_write.c</p>
<p>  $(CC) -o $@ $&lt;</p>
<p>fifo_read: fifo_read.c</p>
<p>  $(CC) -o $@ $&lt;</p>
<p>named_fifo: fifo_write fifo_read</p>
<p>named_fifo_clean:</p>
<p>  -rm .&#x2F;fifo_write .&#x2F;fifo_read</p>
<p><strong>5）</strong><em><strong>*测试*</strong></em></p>
<p>（1）编译</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps73.jpg" alt="img"> </p>
<p>（2）在XShell开启两个标签页，右键点击“垂直分割”</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps74.jpg" alt="img"> </p>
<p>（3）在两个标签页分别开启发送端和接收端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps75.jpg" alt="img"> </p>
<p>（4）在发送端发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps76.jpg" alt="img"> </p>
<p>接收端可以看到数据。</p>
<p>（5）终止进程</p>
<p>发送端按下Ctrl+D，终止发送端，接收端收到信号，也会退出。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps77.jpg" alt="img"> </p>
<p><strong>6）</strong><em><strong>*有名管道在文件系统的对应*</strong></em></p>
<p>（1）再次启动</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps78.jpg" alt="img"> </p>
<p>再次启动上述文件提示mkfifo失败，原因是文件已存在，那么这里的文件是指哪个文件？</p>
<p>（2）fifo专用文件</p>
<p>创建有名管道时，我们同时创建了一个fifo专用文件，在上述案例中是&#x2F;tmp&#x2F;myfifo，这实际上就是fifo专用文件在文件系统的路径，如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps79.jpg" alt="img"> </p>
<p>程序执行完毕之后，该文件未被清除，因此会出现上述报错。</p>
<p>（3）更改fifo_write.c</p>
<p>有名管道使用完成后，应该通过unlink调用清除相关资源。这个函数只能调用一次，重复清除会提示No such file or directory。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 从文件系统中清除一个名称及其链接的文件</p>
<p> * </p>
<p> * @param pathname 文件路径</p>
<p> * @return int 成功返回0，失败返回-1，并设置errno</p>
<p> *&#x2F;</p>
<p>int unlink(const char *pathname);</p>
<p>我们在fifo_write.c中补充资源释放操作，如下。</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  int fd;</p>
<p>  char *pipe_path &#x3D; “&#x2F;tmp&#x2F;myfifo”;</p>
<p>  &#x2F;&#x2F; 创建有名管道，权限设置为 0664</p>
<p>  if (mkfifo(pipe_path, 0664) !&#x3D; 0)</p>
<p>  {</p>
<p>​    perror(“mkfifo failed”);</p>
<p>​    if (errno !&#x3D; 17)</p>
<p>​    {</p>
<p>​      exit(EXIT_FAILURE);</p>
<p>​    }</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 打开有名管道用于写入</p>
<p>  fd &#x3D; open(pipe_path, O_WRONLY);</p>
<p>  if (fd &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“open failed”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  char write_buf[100];</p>
<p>  ssize_t read_num;</p>
<p>  while ((read_num &#x3D; read(STDIN_FILENO, write_buf, 100)) &gt; 0) {</p>
<p>​    write(fd, write_buf, read_num);</p>
<p>  }</p>
<p>  if (read_num &lt; 0) {</p>
<p>​    perror(“read”);</p>
<p>​    printf(“命令行数据读取异常，退出”);</p>
<p>​    close(fd);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  printf(“发送管道退出，进程终止\n”);</p>
<p>  close(fd);</p>
<p>  <em>*<em>*<em>if*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>unlink*</em>*******</em>(pipe_path)*<em>*</em>* <em>*<em>*</em>&#x3D;&#x3D;***</em>* <em>*<em>*</em>-***</em><strong><strong>*<em>1*</em>***</strong><em>*</em>) {***</strong></p>
<p>​    <em>*<em>*<em>perror*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>“fifo_write unlink”*<em>*******</em>);*<em>*</em>*</p>
<p>  <em>*<em>*</em>}***</em>*</p>
<p>  return 0;</p>
<p>}</p>
<p>接下来，首先清除之前遗留的&#x2F;tmp&#x2F;myfifo，清除fifo_read和fifo_write。然后重新编译运行，再停止读写进程，可以发现fifo专用文件已被清除。</p>
<p><strong>7）</strong><em><strong>*注意*</strong></em></p>
<p>调用open()打开有名管道时，flags设置为O_WRONLY则当前进程用于向有名管道写入数据，设置为O_RDONLY则当前进程用于从有名管道读取数据。设置为O_RDWR从技术上是可行的，但正如上文提到的，此时管道既读又写很可能导致一个进程读取到自己发送的数据，通信出现混乱。因此，打开有名管道时，flags只应为O_WRONLY或O_RDONLY。</p>
<p>内核为每个被进程打开的FIFO专用文件维护一个管道对象。当进程通过FIFO交换数据时，内核会在内部传递所有数据，不会将其写入文件系统。因此，&#x2F;tmp&#x2F;myfifo文件大小始终为0。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps80.jpg" alt="img"> </p>
<p>需要注意的是，文件详细信息最开头的字母p表示这个是一个有名管道文件。</p>
<p><strong>8）</strong><em><strong>*图解*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps81.png" alt="img"></p>
<h4 id="3-3-2-共享内存"><a href="#3-3-2-共享内存" class="headerlink" title="3.3.2 共享内存"></a>3.3.2 <strong>共享内存</strong></h4><p><strong>1）</strong><em><strong>*shm_open()和*</strong></em><em><strong>*shm_unlink*</strong></em><em><strong>*()*</strong></em></p>
<p>shm_open可以开启一块内存共享对象，我们可以像使用一般文件描述符一般使用这块内存对象。</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>&#x2F;**</p>
<p> * const char *name: 这是共享内存对象的名称，直接写一个文件名称，本身会保存在 &#x2F;dev&#x2F;shm 。名称必须是唯一的，以便不同进程可以定位同一个共享内存段。</p>
<p> * 命名规则：必须是以正斜杠&#x2F;开头，以\0结尾的字符串，中间可以包含若干字符，但不能有正斜杠</p>
<p> * int oflag: 打开模式 二进制可拼接</p>
<p> *    (1) O_CREAT：如果不存在则创建新的共享内存对象</p>
<p> *    (2) O_EXCL：当与 O_CREAT 一起使用时，如果共享内存对象已经存在，则返回错误（避免覆盖现有对象）</p>
<p> *    (3) O_RDONLY：以只读方式打开</p>
<p> *    (4) O_RDWR：以读写方式打开</p>
<p> *    (5) O_TRUNC 用于截断现有对象至0长度（只有在打开模式中包含 O_RDWR 时才有效）。</p>
<p> * mode_t mode: 当创建新共享内存对象时使用的权限位，类似于文件的权限模式,一般0644即可</p>
<p> * return: 成功执行,它将返回一个新的描述符;发生错误,返回值为 -1</p>
<p>*&#x2F;</p>
<p>int shm_open(const char *name, int oflag, mode_t mode);</p>
<p>&#x2F;**</p>
<p> * </p>
<p> * 删除一个先前由 shm_open() 创建的命名共享内存对象。尽管这个函数被称为“unlink”，但它并没有真正删除共享内存段本身，而是移除了与共享内存对象关联的名称，使得通过该名称无法再打开共享内存。当所有已打开该共享内存段的进程关闭它们的描述符后，系统才会真正释放共享内存资源</p>
<ul>
<li></li>
</ul>
<p> * char *name: 要删除的共享内存对象名称</p>
<p> * return: 成功返回0 失败返回-1</p>
<p> *&#x2F;</p>
<p>int shm_unlink(const char *name);</p>
<p><strong>2）</strong><em><strong>*truncate()和ftruncate()*</strong></em></p>
<p>truncate和ftruncate都可以将文件缩放到指定大小，二者的行为类似：如果文件被缩小，截断部分的数据丢失，如果文件空间被放大，扩展的部分均为\0字符。缩放前后文件的偏移量不会更改。缩放成功返回0，失败返回-1。</p>
<p>不同的是，前者需要指定路径，而后者需要提供文件描述符；ftruncate缩放的文件描述符可以是通过shm_open()开启的内存对象，而truncate缩放的文件必须是文件系统已存在文件，若文件不存在或没有权限则会失败。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>&#x2F;**</p>
<p> * 将指定文件扩展或截取到指定大小</p>
<p> * </p>
<p> * char *path: 文件名 指定存在的文件即可 不需要打开</p>
<p> * off_t length: 指定长度 单位字节</p>
<p> * return: int 成功 0</p>
<p> *       失败 -1</p>
<p> *&#x2F;</p>
<p>int truncate(const char *path, off_t length);</p>
<p>&#x2F;**</p>
<p> *  将指定文件描述符扩展或截取到指定大小</p>
<p> * </p>
<p> * int fd: 文件描述符 需要打开并且有写权限</p>
<p> * off_t length: 指定长度 单位字节</p>
<p> * return: int 成功 0</p>
<p> *       失败 -1</p>
<p> *&#x2F;</p>
<p>int ftruncate(int fd, off_t length);</p>
<p><strong>3）</strong><em><strong>*mmap()*</strong></em></p>
<p>mmap系统调用可以将一组设备或者文件映射到内存地址，我们在内存中寻址就相当于在读取这个文件指定地址的数据。父进程在创建一个内存共享对象并将其映射到内存区后，子进程可以正常读写该内存区，并且父进程也能看到更改。使用man 2 mmap查看该系统调用声明：</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>&#x2F;**</p>
<p> * 将文件映射到内存区域,进程可以直接对内存区域进行读写操作,就像操作普通内存一样,但实际上是对文件或设备进行读写,从而实现高效的 I&#x2F;O 操作</p>
<p> * </p>
<p> * void *addr: 指向期望映射的内存起始地址的指针,通常设为 NULL,让系统选择合适的地址</p>
<p> * size_t length: 要映射的内存区域的长度,以字节为单位</p>
<p> * int prot: 内存映射区域的保护标志,可以是以下标志的组合</p>
<p> *      (1) PROT_READ: 允许读取映射区域</p>
<p> *      (2) PROT_WRITE: 允许写入映射区域</p>
<p> *      (3) PROT_EXEC: 允许执行映射区域</p>
<p> *      (4) PROT_NONE: 页面不可访问</p>
<p> * int flags：映射选项标志</p>
<p> *      (1) MAP_SHARED: 映射区域是共享的,对映射区域的修改会影响文件和其他映射到同一区域的进程(一般使用共享)</p>
<p> *      (2) MAP_PRIVATE: 映射区域是私有的,对映射区域的修改不会影响原始文件,对文件的修改会被暂时保存在一个私有副本中</p>
<p> *      (3) MAP_ANONYMOUS: 创建一个匿名映射,不与任何文件关联</p>
<p> *      (4) MAP_FIXED: 强制映射到指定的地址,如果不允许映射,将返回错误</p>
<p> * int fd: 文件描述符,用于指定要映射的文件或设备,如果是匿名映射,则传入无效的文件描述符（例如-1）</p>
<p> * off_t offset: 从文件开头的偏移量,映射开始的位置</p>
<p> * return void*: (1) 成功时,返回映射区域的起始地址,可以像操作普通内存那样使用这个地址进行读写</p>
<p> *        (2) 如果出错,返回 (void *) -1,并且设置 errno 变量来表示错误原因</p>
<p> *&#x2F;</p>
<p>void *mmap(void *addr, size_t length, int prot, int flags,</p>
<p>​      int fd, off_t offset);</p>
<p>&#x2F;**</p>
<p> * 用于取消之前通过 mmap() 函数建立的内存映射关系</p>
<p> * </p>
<p> * void *addr: 这是指向之前通过 mmap() 映射的内存区域的起始地址的指针,这个地址必须是有效的,并且必须是 mmap() 返回的有效映射地址</p>
<p> * size_t length: 这是要解除映射的内存区域的大小(以字节为单位),它必须与之前通过 mmap() 映射的大小一致</p>
<p> * return: int 成功 0</p>
<p> *       失败 -1</p>
<p> *&#x2F;</p>
<p>int munmap(void *addr, size_t length);</p>
<p><strong>4）</strong><em><strong>*测试例程*</strong></em></p>
<p>下面的程序展示了如何使用mmap在父子进程之间共享信息。</p>
<p>（1）创建shared_memory.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *share;</p>
<p>  pid_t pid;</p>
<p>  char shmName[100]&#x3D;{0};</p>
<p>  sprintf(shmName,”&#x2F;letter%d”,getpid());</p>
<p>  &#x2F;&#x2F; 共享内存对象的文件标识符</p>
<p>  int fd;</p>
<p>  fd &#x3D; shm_open(shmName, O_CREAT | O_RDWR, 0644);</p>
<p>  if (fd &lt; 0)</p>
<p>  {</p>
<p>​    perror(“共享内存对象开启失败!\n”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 将该区域扩充为100字节长度</p>
<p>  ftruncate(fd, 100);</p>
<p>  &#x2F;&#x2F; 以读写方式映射该区域到内存，并开启父子共享标签 偏移量选择0从头开始</p>
<p>  share &#x3D; mmap(NULL, 100, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</p>
<p>  &#x2F;&#x2F; 注意:不是p &#x3D;&#x3D; NULL 映射失败返回的是((void *) -1)</p>
<p>  if (share &#x3D;&#x3D; MAP_FAILED)</p>
<p>  { </p>
<p>​    perror(“共享内存对象映射到内存失败!\n”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 映射区建立完毕,关闭读取连接 注意不是删除</p>
<p>  close(fd);</p>
<p>  &#x2F;&#x2F; 创建子进程</p>
<p>  pid &#x3D; fork(); </p>
<p>  if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 子进程写入数据作为回信 </p>
<p>​    strcpy(share, “你是个好人!\n”);</p>
<p>​    printf(“新学员%d完成回信!\n”, getpid());</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 等待回信</p>
<p>​    sleep(1);</p>
<p>​    printf(“老学员%d看到新学员%d回信的内容: %s”, getpid(),pid,share);</p>
<p>​    &#x2F;&#x2F; 等到子进程运行结束</p>
<p>​    wait(NULL);</p>
<p>​    &#x2F;&#x2F; 释放映射区</p>
<p>​    int ret &#x3D; munmap(share, 100); </p>
<p>​    if (ret &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“munmap”);</p>
<p>​      exit(EXIT_FAILURE);</p>
<p>​    }</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 删除共享内存对象</p>
<p>  shm_unlink(shmName);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>shared_memory: shared_memory.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps82.jpg" alt="img"> </p>
<p><strong>5）</strong><em><strong>*临时文件系统*</strong></em></p>
<p>Linux的临时文件系统（tmpfs）是一种基于内存的文件系统，它将数据存储在RAM或者在需要时部分使用交换空间（swap）。tmpfs访问速度快，但因为存储在内存，重启后数据清空，通常用于存储一些临时文件。</p>
<p>我们可以通过df -h查看当前操作系统已挂载的文件系统。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps83.jpg" alt="img"> </p>
<p><strong>6）</strong><em><strong>*内存共享对象在临时文件系统中的表示*</strong></em></p>
<p>内存共享对象在临时文件系统中的表示位于&#x2F;dev&#x2F;shm目录下。</p>
<p>为看到共享对象在临时文件系统中的表示，我们修改程序，在创建后不销毁。</p>
<p>（1）创建shared_memory_block.c，写入以下内容</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *share;</p>
<p>  pid_t pid;</p>
<p>  char shmName[100]&#x3D;{0};</p>
<p>  sprintf(shmName,”&#x2F;letter%d”,getpid());</p>
<p>  printf(“shmName: %s\n”, shmName);</p>
<p>  &#x2F;&#x2F; 共享内存对象的文件标识符</p>
<p>  int fd;</p>
<p>  fd &#x3D; shm_open(shmName, O_CREAT | O_RDWR, 0644);</p>
<p>  if (fd &lt; 0)</p>
<p>  {</p>
<p>​    perror(“共享内存对象开启失败!\n”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  while(1);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>shared_memory_block: shared_memory_block.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）执行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps84.jpg" alt="img"> </p>
<p>（4）查看&#x2F;dev&#x2F;shm目录</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps85.jpg" alt="img"> </p>
<h4 id="3-3-3-消息队列"><a href="#3-3-3-消息队列" class="headerlink" title="3.3.3 消息队列"></a>3.3.3 <strong>消息队列</strong></h4><p><strong>1）</strong><em><strong>*相关数据类型*</strong></em></p>
<p>（1）mqd_t</p>
<p>该数据类型定义在mqueue.h中，是用来记录消息队列描述符的。</p>
<p>typedef int mqd_t;</p>
<p>实质上是int类型的别名。</p>
<p>（2）struct mq_attr</p>
<p>&#x2F;**</p>
<p> * @brief 消息队列的属性信息</p>
<p> * mq_flags 标记，对于mq_open，忽略它，因为这个标记是通过前者的调用传递的</p>
<p> * mq_maxmgs 队列可以容纳的消息的最大数量</p>
<p> * mq_msgsize 单条消息的最大允许大小，以字节为单位</p>
<p> * mq_curmsgs 当前队列中的消息数量，对于mq_open，忽略它</p>
<p> *&#x2F;</p>
<p>struct mq_attr {</p>
<p>long mq_flags;  &#x2F;* Flags (ignored for mq_open()) *&#x2F;</p>
<p>long mq_maxmsg; &#x2F;* Max. # of messages on queue *&#x2F;</p>
<p>long mq_msgsize; &#x2F;* Max. message size (bytes) *&#x2F;</p>
<p>long mq_curmsgs; &#x2F;* # of messages currently in queue</p>
<p>​        (ignored for mq_open()) *&#x2F;</p>
<p>};</p>
<p>（3）struct timespec</p>
<p>&#x2F;**</p>
<p> * @brief 时间结构体，提供了纳秒级的UNIX时间戳</p>
<p> * tv_sec 秒</p>
<p> * tv_nsec 纳秒</p>
<p> *&#x2F;</p>
<p>struct timespec {</p>
<p>time_t tv_sec;     &#x2F;* seconds *&#x2F;</p>
<p>long  tv_nsec;    &#x2F;* nanoseconds *&#x2F;</p>
<p>};</p>
<p><strong>2）</strong><em><strong>*相关系统调用*</strong></em></p>
<p>（1）mq_open()</p>
<p>#include &lt;fcntl.h&gt;   &#x2F;* For O_* constants *&#x2F;</p>
<p>#include &lt;sys&#x2F;stat.h&gt; &#x2F;* For mode constants *&#x2F;</p>
<p>#include &lt;mqueue.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 创建或打开一个已存在的POSIX消息队列，消息队列是通过名称唯一标识的。</p>
<ul>
<li></li>
</ul>
<p> * @param name 消息队列的名称</p>
<p> * 命名规则：必须是以正斜杠&#x2F;开头，以\0结尾的字符串，中间可以包含若干字符，但不能有正斜杠</p>
<p> * @param oflag 指定消息队列的控制权限，必须也只能包含以下三者之一</p>
<p> * O_RDONLY 打开的消息队列只用于接收消息</p>
<p> * O_WRONLY 打开的消息队列只用于发送消息</p>
<p> * O_RDWR 打开的消息队列可以用于收发消息</p>
<p> * 可以与以下选项中的0至多个或操作之后作为oflag</p>
<p> * O_CLOEXEC 设置close-on-exec标记，这个标记表示执行exec时关闭文件描述符</p>
<p> * O_CREAT 当文件描述符不存在时创建它，如果指定了这一标记，需要额外提供mode和attr参数</p>
<p> * O_EXCL 创建一个当前进程独占的消息队列，要同时指定O_CREAT，要求创建的消息队列不存在，否则将会失败，并提示错误EEXIST</p>
<p> * O_NONBLOCK 以非阻塞模式打开消息队列，如果设置了这个选项，在默认情况下收发消息发生阻塞时，会转而失败，并提示错误EAGAIN</p>
<p> * @param mode 每个消息队列在mqueue文件系统对应一个文件，mode是用来指定消息队列对应文件的权限的</p>
<p> * @param attr 属性信息，如果为NULL，则队列以默认属性创建</p>
<p>* @return mqd_t 成功则返回消息队列描述符，失败则返回(mqd_t)-1，同时设置errno以指明错误原因</p>
<p>*&#x2F;</p>
<p>mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);</p>
<p>&#x2F;**</p>
<p> * @brief 当oflag没有包含O_CREAT时方可调用</p>
<ul>
<li></li>
</ul>
<p> * @param name 同上</p>
<p> * @param oflag 同上</p>
<p> * @return mqd_t 同上</p>
<p> *&#x2F;</p>
<p>mqd_t mq_open(const char *name, int oflag);</p>
<p>（2）mq_timedsend()</p>
<p>#include &lt;time.h&gt;</p>
<p>#include &lt;mqueue.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将msg_ptr指向的消息追加到消息队列描述符mqdes指向的消息队列的尾部。如果消息队列已满，默认情况下，调用阻塞直至有充足的空间允许新的消息入队，或者达到abs_timeout指定的等待时间节点，或者调用被信号处理函数打断。需要注意的是，正如上文提到的，如果在mq_open时指定了O_NONBLOCK标记，则转而失败，并返回错误EAGAIN。</p>
<p> * </p>
<p> * @param mqdes 消息队列描述符</p>
<p> * @param msg_ptr 指向消息的指针</p>
<p> * @param msg_len msg_ptr指向的消息长度，不能超过队列的mq_msgsize属性指定的队列最大容量，长度为0的消息是被允许的</p>
<p> * @param msg_prio 一个非负整数，指定了消息的优先级，消息队列中的数据是按照优先级降序排列的，如果新旧消息的优先级相同，则新的消息排在后面。</p>
<p> * @param abs_timeout 指向struct timespec类型的对象，指定了阻塞等待的最晚时间。如果消息队列已满，且abs_timeout指定的时间节点已过期，则调用立即返回。</p>
<p> * @return int 成功返回0，失败返回-1，同时设置errno以指明错误原因。</p>
<p> *&#x2F;</p>
<p>int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);</p>
<p>（3）mq_timedreceive()</p>
<p>#include &lt;time.h&gt;</p>
<p>#include &lt;mqueue.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 从消息队列中取走最早入队且权限最高的消息，将其放入msg_ptr指向的缓存中。如果消息队列为空，默认情况下调用阻塞，此时的行为与mq_timedsend同理。</p>
<p> * </p>
<p> * @param mqdes 消息队列描述符</p>
<p> * @param msg_ptr 接收消息的缓存</p>
<p> * @param msg_len msg_ptr指向的缓存区的大小，必须大于等于mq_msgsize属性指定的队列单条消息最大字节数</p>
<p> * @param msg_prio 如果不为NULL，则用于接收接收到的消息的优先级 </p>
<p> * @param abs_timeout 阻塞时等待的最晚时间节点，同mq_timedsend</p>
<p> * @return ssize_t 成功则返回接收到的消息的字节数，失败返回-1，并设置errno指明错误原因</p>
<p> *&#x2F;</p>
<p>ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio, const struct timespec *abs_timeout);</p>
<p>（4）mq_unlink()</p>
<p>#include &lt;mqueue.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 清除name对应的消息队列，mqueue文件系统中的对应文件被立即清除。消息队列本身的清除必须等待所有指向该消息队列的描述符全部关闭之后才会发生。</p>
<p> * </p>
<p> * @param name 消息队列名称</p>
<p> * @return int 成功返回0，失败返回-1，并设置errno指明错误原因</p>
<p> *&#x2F;</p>
<p>int mq_unlink(const char *name);</p>
<p>（5）clock_gettime()</p>
<p>#include &lt;time.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 获取以struct timespec形式表示的clockid指定的时钟</p>
<p> * </p>
<p> * @param clockid 特定时钟的标识符，常用的是CLOCK_REALTIME，表示当前真实时间的时钟</p>
<p> * @param tp 用于接收时间信息的缓存</p>
<p> * @return int 成功返回0，失败返回-1，同时设置errno以指明错误原因</p>
<p> *&#x2F;</p>
<p>int clock_gettime(clockid_t clockid, struct timespec *tp);</p>
<p><strong>3）</strong><em><strong>*父子进程间通信测试例程*</strong></em></p>
<p>（1）创建father_son_mq_test.c</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;mqueue.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;time.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  &#x2F;&#x2F; 创建消息队列</p>
<p>  struct mq_attr attr;</p>
<p>  &#x2F;&#x2F; 有用的参数  表示消息队列的容量</p>
<p>  attr.mq_maxmsg &#x3D; 10;</p>
<p>  attr.mq_msgsize &#x3D; 100;</p>
<p>  &#x2F;&#x2F; 被忽略的消息 在创建消息队列的时候用不到</p>
<p>  attr.mq_flags &#x3D; 0;</p>
<p>  attr.mq_curmsgs &#x3D; 0;</p>
<p>  char *mq_name &#x3D; “&#x2F;father_son_mq”;</p>
<p>  mqd_t mqdes &#x3D; mq_open(mq_name,O_RDWR | O_CREAT,0664,&amp;attr);</p>
<p>  if (mqdes &#x3D;&#x3D; (mqd_t)-1)</p>
<p>  {</p>
<p>​    perror(“mq_open”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 创建父子进程</p>
<p>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &lt; 0)</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 子进程  等待接收消息队列中的信息</p>
<p>​    char read_buf[100];</p>
<p>​    struct timespec time_info;</p>
<p>​    for (size_t i &#x3D; 0; i &lt; 10; i++)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F; 清空接收数据的缓冲区</p>
<p>​      memset(read_buf,0,100);</p>
<p>​      &#x2F;&#x2F; 设置接收数据的等待时间</p>
<p>​      clock_gettime(0,&amp;time_info);</p>
<p>​      time_info.tv_sec +&#x3D; 15;</p>
<p>​      &#x2F;&#x2F; 接收消息队列的数据  打印到控制台</p>
<p>​      if (mq_timedreceive(mqdes,read_buf,100,NULL,&amp;time_info) &#x3D;&#x3D; -1)</p>
<p>​      {</p>
<p>​        perror(“mq_timedreceive”);</p>
<p>​      }</p>
<p>​      printf(“子进程接收到数据:%s\n”,read_buf);</p>
<p>​    }</p>
<p>​    </p>
<p>  }else {</p>
<p>​    &#x2F;&#x2F; 父进程  发送消息到消息队列中</p>
<p>​    char send_buf[100];</p>
<p>​    struct timespec time_info;</p>
<p>​    </p>
<p>​    for (size_t i &#x3D; 0; i &lt; 10; i++)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F; 清空处理buf</p>
<p>​      memset(send_buf,0,100);</p>
<p>​      sprintf(send_buf,”父进程的第%d次发送消息\n”,(int)(i+1));</p>
<p>​      &#x2F;&#x2F; 获取当前的具体时间</p>
<p>​      clock_gettime(0,&amp;time_info);</p>
<p>​      time_info.tv_sec +&#x3D; 5;</p>
<p>​      &#x2F;&#x2F; 发送消息</p>
<p>​      if (mq_timedsend(mqdes,send_buf,strlen(send_buf),0,&amp;time_info) &#x3D;&#x3D; -1)</p>
<p>​      {</p>
<p>​        perror(“mq_timedsend”);</p>
<p>​      }</p>
<p>​      printf(“父进程发送一条消息,休眠1s\n”);</p>
<p>​      sleep(1);</p>
<p>​    }</p>
<p>​    </p>
<p>​    </p>
<p>  }</p>
<p>  &#x2F;&#x2F; 最终不管是父进程还是子进程都需要释放消息队列的引用</p>
<p>  close(mqdes);</p>
<p>  &#x2F;&#x2F; 清除消息队列只需要执行一次</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    mq_unlink(mq_name);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>father_son_mq_test: father_son_mq_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）执行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps86.jpg" alt="img"> </p>
<p>子进程正确接收了父进程发送的数据。</p>
<p><strong>4）</strong><em><strong>*非父子进程通信案例*</strong></em></p>
<p>我们创建两个进程：生产者和消费者，前者从控制台接收数据并写入消息队列，后者从消息队列接收数据并打印到控制台。</p>
<p>（1）创建producer.c</p>
<p>#include &lt;time.h&gt;</p>
<p>#include &lt;mqueue.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *mq_name &#x3D; “&#x2F;p_c_mq”;</p>
<p>  struct mq_attr attr;</p>
<p>  attr.mq_flags &#x3D; 0;</p>
<p>  attr.mq_maxmsg &#x3D; 10;</p>
<p>  attr.mq_msgsize &#x3D; 100;</p>
<p>  attr.mq_curmsgs &#x3D; 0;</p>
<p>  &#x2F;&#x2F; 创建或打开消息队列</p>
<p>  mqd_t mqdes &#x3D; mq_open(mq_name, O_CREAT | O_WRONLY, 0666, &amp;attr);</p>
<p>  if (mqdes &#x3D;&#x3D; (mqd_t)-1)</p>
<p>  {</p>
<p>​    perror(“mq_open”);</p>
<p>  }</p>
<p>  char writeBuf[100];</p>
<p>  struct timespec time_info;</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 清空写缓冲区</p>
<p>​    memset(writeBuf, 0, 100);</p>
<p>​    &#x2F;&#x2F; 从命令行标准输入读取数据</p>
<p>​    ssize_t read_count &#x3D; read(0, writeBuf, 100);</p>
<p>​    if (read_count &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“read”);</p>
<p>​      continue;</p>
<p>​    }</p>
<p>​    else if (read_count &#x3D;&#x3D; 0)</p>
<p>​    {</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 获取当前时间中5s之后的timespec对象</p>
<p>​    clock_gettime(CLOCK_REALTIME, &amp;time_info);</p>
<p>​    time_info.tv_sec +&#x3D; 5;</p>
<p>​    &#x2F;&#x2F; 发送数据</p>
<p>​    &#x2F;&#x2F; 如果接收到命令行的EOF，read将返回0，此时向消费者端发送信息并退出</p>
<p>​    if (read_count &#x3D;&#x3D; 0)</p>
<p>​    {</p>
<p>​      printf(“Received EOF, exit…\n”);</p>
<p>​      char eof &#x3D; EOF;</p>
<p>​      if (mq_timedsend(mqdes, &amp;eof, 1, 0, &amp;time_info) &#x3D;&#x3D; -1)</p>
<p>​      {</p>
<p>​        perror(“mq_timedsend”);</p>
<p>​      }</p>
<p>​      break;</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 没有接收到EOF，正常发送数据</p>
<p>​    if (mq_timedsend(mqdes, writeBuf, strlen(writeBuf), 0, &amp;time_info) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“mq_timesend”);</p>
<p>​    }</p>
<p>​    printf(“从命令行接收到数据，已发送至消费者端\n”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 关闭描述符</p>
<p>  close(mqdes);</p>
<p>  &#x2F;&#x2F; mq_unlink 只应调用一次，我们选择在消费者中完成此操作</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）创建consumer.c</p>
<p>#include &lt;time.h&gt;</p>
<p>#include &lt;mqueue.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *mq_name &#x3D; “&#x2F;p_c_mq”;</p>
<p>  struct mq_attr attr;</p>
<p>  attr.mq_flags &#x3D; 0;</p>
<p>  attr.mq_maxmsg &#x3D; 10;</p>
<p>  attr.mq_msgsize &#x3D; 100;</p>
<p>  attr.mq_curmsgs &#x3D; 0;</p>
<p>  &#x2F;&#x2F; 创建或打开消息队列</p>
<p>  mqd_t mqdes &#x3D; mq_open(mq_name, O_CREAT | O_RDONLY, 0666, &amp;attr);</p>
<p>  if (mqdes &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“mq_open”);</p>
<p>  }</p>
<p>  char readBuf[100];</p>
<p>  struct timespec time_info;</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    memset(readBuf, 0, 100);</p>
<p>​    &#x2F;&#x2F; 获取1天后的time_spec结构对象，目的是在测试期间使得消费者一直等待生产者发送的数据</p>
<p>​    clock_gettime(CLOCK_REALTIME, &amp;time_info);</p>
<p>​    time_info.tv_sec +&#x3D; 86400;</p>
<p>​    &#x2F;&#x2F; 接收数据</p>
<p>​    if (mq_timedreceive(mqdes, readBuf, 100, NULL, &amp;time_info) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“mq_timedreceive”);</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 如果收到生产者发送的EOF，则结束进程</p>
<p>​    if (readBuf[0] &#x3D;&#x3D; EOF)</p>
<p>​    {</p>
<p>​      printf(“接收到生产者的终止信号，准备退出…\n”);</p>
<p>​      break;</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 如果没有收到EOF，将接收到的数据打印到标准输出</p>
<p>​    printf(“接收到来自于生产者的数据\n%s”, readBuf);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 释放消息队列描述符</p>
<p>  close(mqdes);</p>
<p>  &#x2F;&#x2F; mq_unlink 只应调用一次</p>
<p>  &#x2F;&#x2F; 清除消息队列</p>
<p>  mq_unlink(mq_name);</p>
<p>}</p>
<p>（3）Makefile</p>
<p>在伪目标中添加p_c_mq和pc_mq_clean，如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps87.jpg" alt="img"> </p>
<p>补充以下内容</p>
<p>producer: producer.c</p>
<p>  $(CC) -o $@ $^</p>
<p>cosumer: consumer.c</p>
<p>  $(CC) -o $@ $^</p>
<p>p_c_mq: producer consumer</p>
<p>pc_mq_clean:</p>
<p>  -rm .&#x2F;producer .&#x2F;consumer</p>
<p><strong>5）</strong><em><strong>*消息队列在mqueue文件系统的表示*</strong></em></p>
<p>我们启动producer和consumer，然后查看&#x2F;dev&#x2F;mqueue目录，如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps88.jpg" alt="img"> </p>
<p>终止消费和生产者后，上述文件被清除。</p>
<p><strong>6）</strong><em><strong>*消息队列通信方向的讨论*</strong></em></p>
<p>我们可以通过设置POSIX消息队列的模式为O_RDWR，使它可以用于收发数据，从技术上讲，单条消息队列可以用于双向通信，但是这会导致消息混乱，无法确定队列中的数据是本进程写入的还是读取的，因此，不会这么做，通常单条消息队列只用于单向通信。为了实现全双工通信，我们可以使用两条消息队列，分别负责两个方向的通信。类似于管道。</p>
<h3 id="3-4-信号"><a href="#3-4-信号" class="headerlink" title="3.4 信号"></a>3.4 <strong>信号</strong></h3><h4 id="3-4-1-信号简介"><a href="#3-4-1-信号简介" class="headerlink" title="3.4.1 信号简介"></a>3.4.1 <strong>信号简介</strong></h4><p>在Linux中，信号是一种用于通知进程发生了某种事件的机制。信号可以由内核、其他进程或者通过命令行工具发送给目标进程。Linux系统中有多种信号，每种信号都用一个唯一的整数值来表示，例如，常见的信号包括：</p>
<p>（1）SIGINT（2）：这是当用户在终端按下Ctrl+C时发送给前台进程的信号，通常用于请求进程终止。</p>
<p>（2）SIGKILL（9）：这是一种强制终止进程的信号，它会立即终止目标进程，且不能被捕获或忽略。</p>
<p>（3）SIGTERM（15）：这是一种用于请求进程终止的信号，通常由系统管理员或其他进程发送给目标进程。</p>
<p>（4）SIGUSR1（10）和SIGUSR2（12）：这两个信号是用户自定义的信号，可以由应用程序使用。</p>
<p>（5）SIGSEGV（11）：这是一种表示进程非法内存访问的信号，通常是由于进程尝试访问未分配的内存或者试图执行非法指令而导致的。</p>
<p>（6）SIGALRM（14）：这是一个定时器信号，通常用于在一定时间间隔后向目标进程发送信号。</p>
<p>每种信号都有其特定的含义和行为，进程可以通过注册信号处理函数来捕获信号并执行相应的操作，例如终止进程、忽略信号或者执行特定的处理逻辑。如果想查看所有的Linux信号，请执行kill -l指令，会得到以下反馈：</p>
<p>\1) SIGHUP    2) SIGINT    3) SIGQUIT    4) SIGILL    5) SIGTRAP</p>
<p> \6) SIGABRT    7) SIGBUS    8) SIGFPE    9) SIGKILL   10) SIGUSR1</p>
<p>\11) SIGSEGV   12) SIGUSR2   13) SIGPIPE   14) SIGALRM   15) SIGTERM</p>
<p>\16) SIGSTKFLT  17) SIGCHLD   18) SIGCONT   19) SIGSTOP   20) SIGTSTP</p>
<p>\21) SIGTTIN   22) SIGTTOU   23) SIGURG    24) SIGXCPU   25) SIGXFSZ</p>
<p>\26) SIGVTALRM  27) SIGPROF   28) SIGWINCH   29) SIGIO    30) SIGPWR</p>
<p>\31) SIGSYS    34) SIGRTMIN   35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</p>
<p>\38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</p>
<p>\43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</p>
<p>\48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</p>
<p>\53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</p>
<p>\58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</p>
<p>\63) SIGRTMAX-1  64) SIGRTMAX</p>
<h4 id="3-4-2-信号处理例程"><a href="#3-4-2-信号处理例程" class="headerlink" title="3.4.2 信号处理例程"></a>3.4.2 <strong>信号处理例程</strong></h4><p>我们可以通过signal系统调用注册信号处理函数：</p>
<p>#include &lt;signal.h&gt;</p>
<p>&#x2F;&#x2F; 信号处理函数声明</p>
<p>typedef void (*sighandler_t)(int);</p>
<p>&#x2F;**</p>
<p> *  signal系统调用会注册某一信号对应的处理函数。如果注册成功，当进程收到这一信号时，将不会调用默认的处理函数，而是调用这里的自定义函数</p>
<p> * </p>
<p> * int signum: 要处理的信号</p>
<p> * sighandler_t handler: 当收到对应的signum信号时，要调用的函数</p>
<p> * return: sighandler_t 返回之前的信号处理函数，如果错误会返回SEG_ERR</p>
<p> *&#x2F;</p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
<p>下面的例子简单演示了如何处理收到的信号。</p>
<p><strong>1）</strong><em><strong>*创建signal_test.c，写入以下内容*</strong></em></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;&#x2F; 定义信号处理函数</p>
<p>void sigint_handler(int signum) {</p>
<p>  printf(“\n收到%d信号,停止程序!\n”,signum);</p>
<p>  exit(signum);</p>
<p>}</p>
<p>int main() {</p>
<p>  &#x2F;&#x2F; 注册SIGINT信号处理函数 收到ctrl+c信号之后不执行默认的函数,而是执行新的注册函数</p>
<p>  if (signal(SIGINT, sigint_handler) &#x3D;&#x3D; SIG_ERR) {</p>
<p>​    perror(“注册新的信号处理函数失败\n”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 无限循环等待信号</p>
<p>  while (1) {</p>
<p>​    sleep(1);</p>
<p>​    printf(“你好,在吗?\n”);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>signal_test: signal_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>3）</strong><em><strong>*运行*</strong></em></p>
<p>程序运行后会以1s的间隔打印“你好，在吗？”。</p>
<p>光标移动到终端，按下Ctrl+C，结果如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps89.jpg" alt="img"> </p>
<p>信号处理函数已被替换。</p>
<h1 id="第-4-章-线程处理"><a href="#第-4-章-线程处理" class="headerlink" title="第 4 章 线程处理"></a>第 4 章 <strong>线程处理</strong></h1><h3 id="4-1-Linux线程简介"><a href="#4-1-Linux线程简介" class="headerlink" title="4.1 Linux线程简介"></a>4.1 <strong>Linux线程简介</strong></h3><p>Linux 中的线程是指轻量级的执行单元，相比于进程，具有以下特点：</p>
<p>（1）进程（Process）是正在执行的程序的实例。每个进程都有自己的地址空间、代码段、数据段和打开的文件描述符等资源。线程（Thread）是进程内的一个执行单元，它共享相同的地址空间和其他资源，包括文件描述符、信号处理等，但每个线程都有自己的栈空间。</p>
<p>（2）由于共享地址空间和数据段，同一进程的多线程之间进行数据交换比进程间通信方便很多，但也由此带来线程同步问题。</p>
<p>（3）同一进程的多线程共享大部分资源，除了每个线程独立的栈空间。这代表线程的创建、销毁、切换要比进程的创建、销毁、切换的资源消耗小很多，所以多线程比多进程更适合高并发。</p>
<p>在&#x2F;home&#x2F;atguigu下创建thread_test目录，本章的所有测试例程都会放到该目录下。</p>
<h3 id="4-2-线程控制"><a href="#4-2-线程控制" class="headerlink" title="4.2 线程控制"></a>4.2 <strong>线程控制</strong></h3><h4 id="4-2-1-线程创建"><a href="#4-2-1-线程创建" class="headerlink" title="4.2.1 线程创建"></a>4.2.1 <strong>线程创建</strong></h4><p><strong>1）</strong><em><strong>*pthread_create*</strong></em></p>
<p>线程操作相关函数来源于pthread共享库：</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * 创建一个新线程</p>
<p> * </p>
<p> * pthread_t *thread: 指向线程标识符的指针,线程创建成功时,用于存储新创建线程的线程标识符</p>
<p> * const pthread_attr_t *attr: pthead_attr_t结构体,这个参数可以用来设置线程的属性,如优先级、栈大小等。如果不需要定制线程属性,可以传入 NULL,此时线程将采用默认属性。 </p>
<p> * void *(*start_routine)(void *): 一个指向函数的指针,它定义了新线程开始执行时的入口点。这个函数必须接受一个 void * 类型的参数,并返回 void * 类型的结果</p>
<p> * void *arg: start_routine 函数的参数,可以是一个指向任意类型数据的指针</p>
<p> * return: int 线程创建结果</p>
<p> *       成功 0</p>
<p> *       失败 非0</p>
<p> *&#x2F;</p>
<p>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void *), void *arg);</p>
<p>每个线程都有一个唯一的标识符（即线程ID），这个标识符是通过pthread_t类型的变量来表示的，当pthread_create成功创建一个线程时，它会将新线程的标识符存储在thread参数指向的位置。</p>
<p>pthread_t定义在头文件&lt;pthreadtypes.h&gt;中，实际上是long类型（long和long int是相同类型的不同写法）的别名。</p>
<p>typedef unsigned long int pthread_t;</p>
<p>新线程执行函数的声明为void *(*start_routine)(void *)，其入参和返回值都是void *指针。我们可以将传递给线程函数的参数包装为结构体，并将其指针作为入参，再在函数内部处理；同理我们可以在线程函数内部将要返回的状态码和返回值包装为结构体，并将指针作为返回值return。</p>
<p>返回值的获取需要通过其他方法进行，在下面的章节我们会讲。</p>
<p><strong>2）</strong><em><strong>*测试例程*</strong></em></p>
<p>（1）创建create_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#define BUF_LEN 1024</p>
<p>char *buf;</p>
<p>&#x2F;**</p>
<p> * @brief 线程input_thread读取标准输入的数据，放入缓存区</p>
<p> * </p>
<p> * @param argv 不需要输入参数，所以固定为NULL</p>
<p> * @return void* 也不需要返回值</p>
<p> *&#x2F;</p>
<p>void *input_thread(void *argv)</p>
<p>{</p>
<p>  int i &#x3D; 0;</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 从标准输入读取一个字符</p>
<p>​    char c &#x3D; fgetc(stdin);</p>
<p>​    &#x2F;&#x2F; 如果字符不为0也不是换行，写入缓存区</p>
<p>​    if (c &amp;&amp; c!&#x3D; ‘\n’)</p>
<p>​    {</p>
<p>​      buf[i++] &#x3D; c;</p>
<p>​      &#x2F;&#x2F; 缓存区索引溢出，i归零</p>
<p>​      if (i &gt;&#x3D; BUF_LEN)</p>
<p>​      {</p>
<p>​        i &#x3D; 0;</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>&#x2F;**</p>
<p> * @brief 线程output_thread从缓存区读取数据写到标准输出，每个字符换行</p>
<p> * </p>
<p> * @param argv 不需要输入参数，所以固定为NULL</p>
<p> * @return void* 也不需要返回值</p>
<p> *&#x2F;</p>
<p>void *output_thread(void *argv)</p>
<p>{</p>
<p>  int i &#x3D; 0;</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    if (buf[i])</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F; 从缓存区读取一个字节写入标准输出并换行</p>
<p>​      fputc(buf[i], stdout);</p>
<p>​      fputc(‘\n’, stdout);</p>
<p>​      &#x2F;&#x2F; 清理读取完毕的字节</p>
<p>​      buf[i++] &#x3D; 0;</p>
<p>​      if (i &gt;&#x3D; BUF_LEN)</p>
<p>​      {</p>
<p>​        i &#x3D; 0;</p>
<p>​      }</p>
<p>​    } else {</p>
<p>​      sleep(1);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t pid_input;</p>
<p>  pthread_t pid_output;</p>
<p>  &#x2F;&#x2F; 分配缓存</p>
<p>  buf &#x3D; malloc(BUF_LEN);</p>
<p>  &#x2F;&#x2F; 初始化缓存区</p>
<p>  for (int i &#x3D; 0; i &lt; BUF_LEN; i++)</p>
<p>  {</p>
<p>​    buf[i] &#x3D; 0;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 创建读取线程</p>
<p>  pthread_create(&amp;pid_input, NULL, input_thread, NULL);</p>
<p>  &#x2F;&#x2F; 创建写出线程</p>
<p>  pthread_create(&amp;pid_output, NULL, output_thread, NULL);</p>
<p>  &#x2F;&#x2F; 等待指定线程结束，详细作用下一节讲</p>
<p>  pthread_join(pid_input, NULL);</p>
<p>  pthread_join(pid_output, NULL);</p>
<p>  free(buf);</p>
<p>  return 0;</p>
<p>}</p>
<p>上述代码启动了两个线程，输入线程不断检查stdin，将控制台输入的数据存储到缓冲区，输出线程检查缓冲区，如果缓冲区有数据则逐字符输出到stdout，否则等待1s再检查缓冲区。</p>
<p>（2）创建Makefile</p>
<p>CC:&#x3D;gcc</p>
<p>create_test: create_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行，在控制台输入hello，查看输出</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps90.jpg" alt="img"> </p>
<h4 id="4-2-2-线程终止"><a href="#4-2-2-线程终止" class="headerlink" title="4.2.2 线程终止"></a>4.2.2 <strong>线程终止</strong></h4><h5 id="4-2-2-1-相关函数"><a href="#4-2-2-1-相关函数" class="headerlink" title="4.2.2.1 相关函数"></a>4.2.2.1 <strong>相关函数</strong></h5><p><strong>1）</strong><em><strong>*pthread_exit*</strong></em></p>
<p>线程终止有以下几种方法：</p>
<p>（1）线程函数执行return语句；</p>
<p>（2）线程函数内部调用pthread_exit函数；</p>
<p>（3）其他线程调用pthread_cancel函数。</p>
<p>线程终止函数为pthread_exit：</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * 结束关闭调用该方法的线程，并返回一个内存指针用于存放结果</p>
<p> * void *retval: 要返回给其它线程的数据</p>
<p> *&#x2F;</p>
<p>void pthread_exit(void *retval);</p>
<p>当某个线程调用pthread_exit方法后，该线程会被关闭（相当于return）。线程可以通过retval向其它线程传递信息，retval指向的区域不可以放在线程函数的栈内。其他线程（例如主线程）如果需要获得这个返回值，需要调用pthread_join方法。</p>
<p><strong>2）</strong><em><strong>*pthread_join*</strong></em></p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * 等待指定线程结束，获取目标线程的返回值，并在目标线程结束后回收它的资源</p>
<p> * </p>
<p> * pthread_t thread: 指定线程ID</p>
<p> * void **retval: 这是一个可选参数，用于接收线程结束后传递的返回值。如果非空，pthread_join 会在成功时将线程的 exit status 复制到 *retval 所指向的内存位置。如果线程没有显式地通过 pthread_exit 提供返回值，则该参数将被设为 NULL 或忽略</p>
<p> * return: int 成功 0</p>
<p> *        失败 1</p>
<p> *&#x2F;</p>
<p>int pthread_join(pthread_t thread, void **retval);</p>
<p><strong>3）</strong><em><strong>*pthread_detach*</strong></em></p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将线程标记为detached状态。POSIX线程终止后，如果没有调用pthread_detach或pthread_join，其资源会继续占用内存，类似于僵尸进程的未回收状态。默认情况下创建线程后，它处于可join状态，此时可以调用pthread_join等待线程终止并回收资源。但是如果主线程不需要等待线程终止，可以将其标记为detached状态，这意味着线程终止后，其资源会自动被系统回收。</p>
<p> * </p>
<p> * @param thread 线程ID</p>
<p> * @return int 成功返回0，失败返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_detach(pthread_t thread);</p>
<p><strong>4）</strong><em><strong>*pthread_cancel*</strong></em></p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 向目标线程发送取消请求。目标线程是否和何时响应取决于它的取消状态和类型</p>
<p> *  取消状态（Cancelability State）：可以是enabled（默认）或disabled。如果取消状态为禁用，则取消请求会被挂起，直至线程启用取消功能。如果取消状态为启用，则线程的取消类型决定它何时取消。</p>
<p> *  取消类型（Cancelability Type）：可以是asynchronous（异步）或deferred（被推迟，默认值）。</p>
<p> *    asynchronous：意味着线程可能在任何时候被取消（通常立即被取消，但系统并不保证这一点）</p>
<p> *    deferred：被推迟意味着取消请求会被挂起，直至被取消的线程执行取消点（cancellation point）函数时才会真正执行线程的取消操作。</p>
<p> *    取消点函数：是在POSIX线程库中专门设计用于检查和处理取消请求的函数。当被取消的线程执行这些函数时，如果线程的取消状态是enabled且类型是deferred，则它会立即响应取消请求并终止执行。man 7 pthreads可以看到取消点函数列表。</p>
<p> * </p>
<p> * @param thread 目标线程，即被取消的线程</p>
<p> * @return int 成功返回0，失败返回非零的错误码</p>
<p> *    需要注意的是，取消操作和pthread_cancel函数的调用是异步的，这个函数的返回值只能告诉调用者取消请求是否成功发送。当线程被成功取消后，通过pthread_join和线程关联将会获得PTHREAD_CANCELED作为返回信息，这是判断取消是否完成的唯一方式</p>
<p> *&#x2F;</p>
<p>int pthread_cancel(pthread_t thread);</p>
<p><strong>5）</strong><em><strong>*pthread_setcancelstate*</strong></em></p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 设置调用线程的取消状态</p>
<p> *  PTHREAD_CANCEL_ENABLE：启用取消功能</p>
<p> *  PTHREAD_CANCEL_DISABLE：禁用取消功能</p>
<p> * </p>
<p> * @param state 目标状态</p>
<p> * @param oldstate 指针，用于返回历史状态</p>
<p> * @return int 成功返回0，失败返回非零错误码</p>
<p> *&#x2F;</p>
<p>int pthread_setcancelstate(int state, int *oldstate);</p>
<p><strong>6）</strong><em><strong>*pthread_setcanceltype*</strong></em></p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 设置调用线程的取消类型</p>
<p> *  PTHREAD_CANCEL_DEFERRED：设置取消类型为推迟</p>
<p> *  PTHREAD_CANCEL_ASYNCHRONOUS：设置取消类型为异步</p>
<p> * </p>
<p> * @param type 目标类型</p>
<p> * @param oldtype 指针，用于接收历史类型</p>
<p> * @return int 成功返回0，失败返回非零错误码</p>
<p> *&#x2F;</p>
<p>int pthread_setcanceltype(int type, int *oldtype);</p>
<h5 id="4-2-2-2-测试例程"><a href="#4-2-2-2-测试例程" class="headerlink" title="4.2.2.2 测试例程"></a>4.2.2.2 <strong>测试例程</strong></h5><p><strong>1）</strong><em><strong>*pthread_join测试例程*</strong></em></p>
<p>（1）创建terminate_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;math.h&gt;</p>
<p>#include &lt;string.h&gt; </p>
<p>&#x2F;&#x2F;定义结果结构体</p>
<p>typedef struct Result</p>
<p>{</p>
<p>  char *p;</p>
<p>  int len;</p>
<p>} Result;</p>
<p>&#x2F;**</p>
<p> * 红玫瑰</p>
<p> * </p>
<p> * void *argv: 指针，可以传递的参数  这里用一个字符表示她的代号</p>
<p> * return: void* 结果结构体指针 返回结局</p>
<p> *&#x2F;</p>
<p>void *red_thread(void *argv)</p>
<p>{</p>
<p>  Result *result &#x3D; malloc(sizeof(Result));</p>
<p>  char code &#x3D; *((char *)argv);</p>
<p>  &#x2F;&#x2F; 存放回信</p>
<p>  char *ans &#x3D; malloc(101);</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    fgets(ans,100,stdin);</p>
<p>​    if (ans[0]&#x3D;&#x3D;code)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F;接收到了对应的信息</p>
<p>​      free(ans);</p>
<p>​      printf(“红玫瑰离开了!\n”);</p>
<p>​      char *redAns &#x3D; strdup(“红玫瑰独自去了纽约.\n”);</p>
<p>​      result-&gt;p &#x3D; redAns;</p>
<p>​      result-&gt;len &#x3D; strlen(redAns);</p>
<p>​      &#x2F;&#x2F; 结束线程 输出返回值</p>
<p>​      pthread_exit((void *)result);</p>
<p>​    }else{</p>
<p>​      printf(“红玫瑰还在等你!\n”);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>&#x2F;**</p>
<p> * 白玫瑰</p>
<p> * </p>
<p> * void *argv: 指针，可以传递的参数  这里用一个字符表示她的代号</p>
<p> * return: void* 结果结构体指针 返回结局</p>
<p> *&#x2F;</p>
<p>void *white_thread(void *argv)</p>
<p>{</p>
<p>  Result *result &#x3D; malloc(sizeof(Result));</p>
<p>  char code &#x3D; *((char *)argv);</p>
<p>  &#x2F;&#x2F; 存放回信</p>
<p>  char *ans &#x3D; malloc(101);</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    fgets(ans,100,stdin);</p>
<p>​    if (ans[0]&#x3D;&#x3D;code)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F;接收到了对应的信息</p>
<p>​      free(ans);</p>
<p>​      printf(“白玫瑰离开了!\n”);</p>
<p>​      char *redAns &#x3D; strdup(“白玫瑰独自去了伦敦.\n”);</p>
<p>​      result-&gt;p &#x3D; redAns;</p>
<p>​      result-&gt;len &#x3D; strlen(redAns);</p>
<p>​      &#x2F;&#x2F; 结束线程 输出返回值</p>
<p>​      pthread_exit((void *)result);</p>
<p>​    }else{</p>
<p>​      printf(“白玫瑰还在等你!\n”);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t pid_red;</p>
<p>  pthread_t pid_white;</p>
<p>  char red_code&#x3D;’r’;</p>
<p>  char white_code&#x3D;’w’;</p>
<p>  Result *red_result &#x3D; NULL;</p>
<p>  Result *white_result &#x3D; NULL;</p>
<p>  &#x2F;&#x2F; 创建红玫瑰线程</p>
<p>  pthread_create(&amp;pid_red, NULL, red_thread, &amp;red_code);</p>
<p>  &#x2F;&#x2F; 创建白玫瑰线程</p>
<p>  pthread_create(&amp;pid_white, NULL, white_thread, &amp;white_code);</p>
<p>  &#x2F;&#x2F; 获取红玫瑰结果</p>
<p>  pthread_join(pid_red, (void **)&amp;red_result);</p>
<p>  printf(“红玫瑰故事结局:%s\n”,red_result-&gt;p);</p>
<p>  &#x2F;&#x2F; 释放内存</p>
<p>  free(red_result-&gt;p);</p>
<p>  free(red_result);</p>
<p>  &#x2F;&#x2F; 获取求素数结果</p>
<p>  pthread_join(pid_white, (void **)&amp;white_result);</p>
<p>  printf(“白玫瑰故事结局:%s\n”,white_result-&gt;p);</p>
<p>  &#x2F;&#x2F; 释放内存</p>
<p>  free(white_result-&gt;p);</p>
<p>  free(white_result);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>terminate_test: terminate_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p>终端输入r开头的字符串，然后输入w开头的字符串。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps91.jpg" alt="img"> </p>
<p>控制台输出如上。</p>
<p><strong>2）</strong><em><strong>*pthread_detach测试例程*</strong></em></p>
<p>（1）创建pthread_detach_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>void *task(void *arg)</p>
<p>{</p>
<p>  printf(“Thread started\n”);</p>
<p>  sleep(2); &#x2F;&#x2F; 模拟线程工作</p>
<p>  printf(“Thread finished\n”);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t tid;</p>
<p>  &#x2F;&#x2F; 创建线程</p>
<p>  pthread_create(&amp;tid, NULL, task, NULL);</p>
<p>  &#x2F;&#x2F; 使用 pthread_detach 让线程自动回收资源</p>
<p>  pthread_detach(tid);</p>
<p>  &#x2F;&#x2F; 主线程继续工作</p>
<p>  printf(“Main thread continues\n”);</p>
<p>  sleep(3); &#x2F;&#x2F; 需要注意的是，pthread_detach不会等待子线程结束，如果在后者执行完毕之前主线程退出，则整个进程退出，子线程被强制终止，因此需要等待足够的时间确保子线程完成自己的任务</p>
<p>  printf(“Main thread ending\n”);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>pthread_detach_test: pthread_detach_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps92.jpg" alt="img"> </p>
<p>（4）注释主线程的睡眠操作</p>
<p>需要注意的是，pthread_detach不会等待子线程结束，如果在后者执行完毕之前主线程退出，则整个进程退出，子线程被强制终止。为了验证这一点，注释以下代码</p>
<p>  <em>*<em>*</em>&#x2F;&#x2F;***</em>* <em>*<em>*<em>sleep*</em>*</em>*</em><strong>*<em>(3); &#x2F;&#x2F; 需要注意的是，pthread_detach不会等待子线程结束，如果在后者执行完毕之前主线程退出，则整个进程退出，子线程被强制终止，因此需要等待足够的时间确保子线程完成自己的任务*</em>*</strong></p>
<p>（5）保存后重新运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps93.jpg" alt="img"> </p>
<p><strong>3）</strong><em><strong>*pthread_cancel测试例程*</strong></em></p>
<p>（1）创建pthread_cancel_deferred_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>void *task(void *arg)</p>
<p>{</p>
<p>  printf(“Thread started\n”);</p>
<p>  &#x2F;&#x2F; 默认取消类型为延迟，无需设置</p>
<p>  &#x2F;&#x2F; 模拟工作</p>
<p>  printf(“Working…\n”);</p>
<p>  sleep(1);       &#x2F;&#x2F; 模拟工作</p>
<p>  pthread_testcancel(); &#x2F;&#x2F; 取消点函数</p>
<p>  printf(“After Cancelled\n”);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t tid;</p>
<p>  void *res;</p>
<p>  &#x2F;&#x2F; 创建线程</p>
<p>  pthread_create(&amp;tid, NULL, task, NULL);</p>
<p>  &#x2F;&#x2F; 取消子线程</p>
<p>  if (pthread_cancel(tid) !&#x3D; 0){</p>
<p>​    perror(“pthread_cancel”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 等待子线程终止并获取其退出状态</p>
<p>  pthread_join(tid, &amp;res);</p>
<p>  &#x2F;&#x2F; 检查子线程是否被取消</p>
<p>  if (res &#x3D;&#x3D; PTHREAD_CANCELED)</p>
<p>  {</p>
<p>​    printf(“Thread was canceled\n”);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    printf(“Thread was not canceled, exit code: %ld\n”, (long)res);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>pthread_cancel_deferred_test: pthread_cancel_deferred_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps94.jpg" alt="img"> </p>
<p>After Cancelled并未被打印，且主线程执行了取消成功分支，子线程被成功取消。</p>
<p>（4）创建pthread_cancel_async_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>void *task(void *arg)</p>
<p>{</p>
<p>  printf(“Thread started\n”);</p>
<p>  &#x2F;&#x2F; 设置取消类型为异步</p>
<p>  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);</p>
<p>  &#x2F;&#x2F; 模拟工作</p>
<p>  printf(“Working…\n”);</p>
<p>  sleep(1);       &#x2F;&#x2F; 模拟工作</p>
<p>  printf(“After Cancelled\n”);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t tid;</p>
<p>  void *res;</p>
<p>  &#x2F;&#x2F; 创建线程</p>
<p>  pthread_create(&amp;tid, NULL, task, NULL);</p>
<p>  &#x2F;&#x2F; 取消子线程</p>
<p>  if (pthread_cancel(tid) !&#x3D; 0)</p>
<p>  {</p>
<p>​    perror(“pthread_cancel”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 等待子线程终止并获取其退出状态</p>
<p>  pthread_join(tid, &amp;res);</p>
<p>  &#x2F;&#x2F; 检查子线程是否被取消</p>
<p>  if (res &#x3D;&#x3D; PTHREAD_CANCELED)</p>
<p>  {</p>
<p>​    printf(“Thread was canceled\n”);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    printf(“Thread was not canceled, exit code: %ld\n”, (long)res);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（5）Makefile</p>
<p>pthread_cancel_async_test: pthread_cancel_async_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（6）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps95.jpg" alt="img"> </p>
<p>取消成功。</p>
<p>（7）创建pthread_cancel_disabled_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>void *task(void *arg)</p>
<p>{</p>
<p>  printf(“Thread started\n”);</p>
<p>  &#x2F;&#x2F; 禁用取消响应</p>
<p>  pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);</p>
<p>  printf(“Thread CancelState is disabled\n”);</p>
<p>  &#x2F;&#x2F; 设置取消类型为异步</p>
<p>  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);</p>
<p>  &#x2F;&#x2F; 模拟工作</p>
<p>  printf(“Working…\n”);</p>
<p>  sleep(1);       &#x2F;&#x2F; 模拟工作</p>
<p>  printf(“After Cancelled\n”);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t tid;</p>
<p>  void *res;</p>
<p>  &#x2F;&#x2F; 创建线程</p>
<p>  pthread_create(&amp;tid, NULL, task, NULL);</p>
<p>  &#x2F;&#x2F; 取消子线程</p>
<p>  if (pthread_cancel(tid) !&#x3D; 0)</p>
<p>  {</p>
<p>​    perror(“pthread_cancel”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 等待子线程终止并获取其退出状态</p>
<p>  pthread_join(tid, &amp;res);</p>
<p>  &#x2F;&#x2F; 检查子线程是否被取消</p>
<p>  if (res &#x3D;&#x3D; PTHREAD_CANCELED)</p>
<p>  {</p>
<p>​    printf(“Thread was canceled\n”);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    printf(“Thread was not canceled, exit code: %ld\n”, (long)res);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（8）Makefile</p>
<p>pthread_cancel_disabled_test: pthread_cancel_disabled_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（9）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps96.jpg" alt="img"> </p>
<p>线程未被取消。</p>
<h3 id="4-3-线程同步"><a href="#4-3-线程同步" class="headerlink" title="4.3 线程同步"></a>4.3 <strong>线程同步</strong></h3><h4 id="4-3-1-竞态条件和锁"><a href="#4-3-1-竞态条件和锁" class="headerlink" title="4.3.1 竞态条件和锁"></a>4.3.1 <strong>竞态条件和锁</strong></h4><p><strong>1）</strong><em><strong>*竞态条件*</strong></em></p>
<p>当多个线程并发访问和修改同一个共享资源（如全局变量）时，如果没有适当的同步措施，就会遇到线程同步问题。这种情况下，程序最终的结果依赖于线程执行的具体时序，导致了竞态条件。</p>
<p>竞态条件（race condition）是一种特定的线程同步问题，指的是两个或者以上进程或者线程并发执行时，其最终的结果依赖于进程或者线程执行的精确时序。它会导致程序的行为和输出超出预期，因为共享资源的最终状态取决于线程执行的顺序和时机。为了确保程序执行结果的正确性和预期一致，需要通过适当的线程同步机制来避免竞态条件。</p>
<p>上一节的测试例程存在竞态条件，如果命令行输入的消息不以r或w开头，输出信息的线程是不确定的。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps97.jpg" alt="img"> </p>
<p>下面的程序没有合理控制线程的并发访问，可能会引发竞态条件。</p>
<p>（1）创建race_condition_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#define THREAD_COUNT 20000</p>
<p>&#x2F;**</p>
<p> * @brief 对传入值累加1</p>
<ul>
<li></li>
</ul>
<p> * @param argv 传入指针</p>
<p> * @return void* 无返回值</p>
<p> *&#x2F;</p>
<p>void *add_thread(void *argv)</p>
<p>{</p>
<p>  int *p &#x3D; argv;</p>
<p>  (*p)++;</p>
<p>  return (void *)0;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t pid[THREAD_COUNT];</p>
<p>  int num &#x3D; 0;</p>
<p>  &#x2F;&#x2F; 用20000个线程对num作累加</p>
<p>  for (int i &#x3D; 0; i &lt; THREAD_COUNT; i++)</p>
<p>  {</p>
<p>​    pthread_create(pid + i, NULL, add_thread, &amp;num);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 等待所有线程结束</p>
<p>  for (int i &#x3D; 0; i &lt; THREAD_COUNT; i++)</p>
<p>  {</p>
<p>​    pthread_join(pid[i], NULL);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 打印累加结果</p>
<p>  printf(“累加结果：%d\n”, num);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>race_condition_test: race_condition_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps98.jpg" alt="img"> </p>
<p>可以看到20000个线程对num的累加结果是不确定的，没有达到我们的预期值20000。这是因为线程之间出现了竞争，不同线程对于num的累加操作可能重叠，这就会导致多次累加操作可能只生效一次。</p>
<p><strong>2）</strong><em><strong>*如何避免竞态条件*</strong></em></p>
<p>上述程序如果想避免竞态条件，有下面两种解决方案：</p>
<p>（1）避免多线程写入一个地址。</p>
<p>（2）给资源加锁，使同一时间操作特定资源的线程只有一个。</p>
<p>方法1可以通过逻辑上组织业务逻辑实现，这里我们讲方法2。</p>
<p>想解决竞争问题，我们需要互斥锁——mutex。</p>
<p><strong>3）</strong><em><strong>*常见的锁机制*</strong></em></p>
<p>锁主要用于互斥，即在同一时间只允许一个执行单元（进程或线程）访问共享资源。包括上面的互斥锁在内，常见的锁机制共有三种：</p>
<p>（1）互斥锁（Mutex）：保证同一时刻只有一个线程可以执行临界区的代码。</p>
<p>（2）读写锁（Reader&#x2F;Writer Locks）：允许多个读者同时读共享数据，但写者的访问是互斥的。</p>
<p>（3）自旋锁（Spinlocks）：在获取锁之前，线程在循环中忙等待，适用于锁持有时间非常短的场景，一般是Linux内核使用。</p>
<h4 id="4-3-2-互斥锁"><a href="#4-3-2-互斥锁" class="headerlink" title="4.3.2 互斥锁"></a>4.3.2 <strong>互斥锁</strong></h4><p><strong>1）</strong><em><strong>*pthread_mutex_t*</strong></em></p>
<p>（1）定义</p>
<p>pthread_mutex_t 是一个定义在头文件&lt;pthreadtypes.h&gt;中的联合体类型的别名，其声明如下。</p>
<p>typedef union</p>
<p>{</p>
<p> struct __pthread_mutex_s __data;</p>
<p> char __size[__SIZEOF_PTHREAD_MUTEX_T];</p>
<p> long int __align;</p>
<p>} pthread_mutex_t;</p>
<p>pthread_mutex_t用作线程之间的互斥锁。互斥锁是一种同步机制，用来控制对共享资源的访问。在任何时刻，最多只能有一个线程持有特定的互斥锁。如果一个线程试图获取一个已经被其他线程持有的锁，那么请求锁的线程将被阻塞，直到锁被释放。</p>
<p>（2）用途</p>
<p>Ø 保护共享数据，避免同时被多个线程访问导致的数据不一致问题。</p>
<p>Ø 实现线程间的同步，确保线程之间对共享资源的访问按照预定的顺序进行。</p>
<p>（3）操作</p>
<p>Ø 初始化（pthread_mutex_init）：创建互斥锁并初始化。</p>
<p>Ø 锁定（pthread_mutex_lock）：获取互斥锁。如果锁已经被其他线程持有，调用线程将阻塞。</p>
<p>Ø 尝试锁定（pthread_mutex_trylock）：尝试获取互斥锁。如果锁已被持有，立即返回而不是阻塞。</p>
<p>Ø 解锁（pthread_mutex_unlock）：释放互斥锁，使其可被其他线程获取。</p>
<p>Ø 销毁（pthread_mutex_destroy）：清理互斥锁资源。</p>
<p><strong>2）</strong><em><strong>*互斥锁操作函数*</strong></em></p>
<p>互斥锁相关的操作函数是POSIX的一部分，默认情况下，当前的Ubuntu系统没有这些函数的手册页。使用指令安装POSIX标准的手册页。</p>
<p>atguigu@ubuntu:~$ sudo apt-get install manpages-posix manpages-posix-dev</p>
<p>查看手册中关于互斥锁操作函数的说明。</p>
<p>atguigu@ubuntu:~$ man 3 pthread_mutex_lock</p>
<p>查看文档可得：</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 获取锁，如果此时锁被占则阻塞</p>
<p> * </p>
<p> * @param mutex 锁</p>
<p> * @return int 获取锁结果</p>
<p> *&#x2F;</p>
<p>int pthread_mutex_lock(pthread_mutex_t *mutex);</p>
<p>&#x2F;**</p>
<p> * @brief 非阻塞式获取锁，如果锁此时被占则返回EBUSY</p>
<p> * </p>
<p> * @param mutex 锁</p>
<p> * @return int 获取锁结果</p>
<p> *&#x2F;</p>
<p>int pthread_mutex_trylock(pthread_mutex_t *mutex);</p>
<p>&#x2F;**</p>
<p> * @brief 释放锁</p>
<p> * </p>
<p> * @param mutex 锁</p>
<p> * @return int 释放锁结果</p>
<p> *&#x2F;</p>
<p>int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<p>（1）pthread_mutex_lock</p>
<p>该函数用于锁定指定的互斥锁。如果互斥锁已经被其他线程锁定，调用此函数的线程将会被阻塞，直到互斥锁变为可用状态。这意味着如果另一个线程持有锁，当前线程将等待直到锁被释放。</p>
<p>成功时返回0；失败时返回错误码。</p>
<p>（2）pthread_mutex_trylock</p>
<p>该函数尝试锁定指定的互斥锁。与pthread_mutex_lock不同，如果互斥锁已经被其他线程锁定，pthread_mutex_trylock不会阻塞调用线程，而是立即返回一个错误码（EBUSY）。</p>
<p>如果成功锁定互斥锁，则返回0；如果互斥锁已被其他线程锁定，返回EBUSY；其他错误情况返回不同的错误码。</p>
<p>（3）pthread_mutex_unlock</p>
<p>该函数用于解锁指定的互斥锁。调用线程必须是当前持有互斥锁的线程；否则，解锁操作可能会失败。</p>
<p>成功时返回0；失败时返回错误码。</p>
<p><strong>3）</strong><em><strong>*初始化互斥锁*</strong></em></p>
<p>PTHREAD_MUTEX_INITIALIZER是POSIX线程（Pthreads）库中定义的一个宏，用于静态初始化互斥锁（mutex）。这个宏为互斥锁提供了一个初始状态，使其准备好被锁定和解锁，而不需要在程序运行时显式调用初始化函数。</p>
<p>当我们使用PTHREAD_MUTEX_INITIALIZER初始化互斥锁时，实际上是将互斥锁设置为默认属性和未锁定状态。这种初始化方式适用于简单的同步问题，我们可以通过以下代码初始化互斥锁。</p>
<p>static pthread_mutex_t counter_mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;</p>
<p><strong>4）</strong><em><strong>*将mutex加入我们刚刚的程序*</strong></em></p>
<p>为了保证计算结果的正确性，很显然，我们应阻塞式获取互斥锁，应调用的是pthread_mutex_lock函数。共享变量修改完成后，应该释放锁。</p>
<p>（1）创建mutex_test.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#define THREAD_COUNT 20000</p>
<p>static pthread_mutex_t counter_mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;</p>
<p>&#x2F;**</p>
<p> * @brief 对传入值累加1</p>
<ul>
<li></li>
</ul>
<p> * @param argv 传入指针</p>
<p> * @return void* 无返回值</p>
<p> *&#x2F;</p>
<p>void *add_thread(void *argv)</p>
<p>{</p>
<p>  int *p &#x3D; argv;</p>
<p>  &#x2F;&#x2F; 累加之前加锁，此时其他获取该锁的线程都会被阻塞</p>
<p>  pthread_mutex_lock(&amp;counter_mutex);</p>
<p>  (*p)++;</p>
<p>  &#x2F;&#x2F; 累加之后释放锁</p>
<p>  pthread_mutex_unlock(&amp;counter_mutex);</p>
<p>  return (void *)0;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t pid[THREAD_COUNT];</p>
<p>  int num &#x3D; 0;</p>
<p>  &#x2F;&#x2F; 用20000个线程对num作累加</p>
<p>  for (int i &#x3D; 0; i &lt; THREAD_COUNT; i++)</p>
<p>  {</p>
<p>​    pthread_create(pid + i, NULL, add_thread, &amp;num);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 等带所有线程结束</p>
<p>  for (int i &#x3D; 0; i &lt; THREAD_COUNT; i++)</p>
<p>  {</p>
<p>​    pthread_join(pid[i], NULL);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 打印累加结果</p>
<p>  printf(“累加结果：%d\n”, num);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>mutex_test: mutex_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）执行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps99.jpg" alt="img"> </p>
<p>累加结果稳定为20000。</p>
<p>（4）注意</p>
<p>上述代码中，互斥锁counter_mutex并未被显式销毁，但这通常不会引起资源泄露问题。上述程序在所有线程执行完毕后直接结束，进程结束时，操作系统会回收该进程的所有资源，包括内存、打开的文件描述符和互斥锁等。因此即便没有显式销毁互斥锁也不会有问题。</p>
<p>在某些情况下，确实需要显式销毁互斥锁资源。如果互斥锁是动态分配的（使用pthread_mutex_init函数初始化），或者互斥锁会被跨多个函数或文件使用，不再需要时必须显式销毁它。但对于静态初始化，并且在程序结束时不再被使用的互斥锁（上述程序中的counter_mutex），显式销毁不是必需的。</p>
<h4 id="4-3-3-读写锁"><a href="#4-3-3-读写锁" class="headerlink" title="4.3.3 读写锁"></a>4.3.3 <strong>读写锁</strong></h4><h5 id="4-3-3-1-工作原理"><a href="#4-3-3-1-工作原理" class="headerlink" title="4.3.3.1 工作原理"></a>4.3.3.1 <strong>工作原理</strong></h5><p>读操作：在读写锁的控制下，多个线程可以同时获得读锁。这些线程可以并发地读取共享资源，但它们的存在阻止了写锁的授予。</p>
<p>写操作：如果至少有一个读操作持有读锁，写操作就无法获得写锁。写操作将会阻塞，直到所有的读锁都被释放。</p>
<h5 id="4-3-3-2-相关调用"><a href="#4-3-3-2-相关调用" class="headerlink" title="4.3.3.2 相关调用"></a>4.3.3.2 <strong>相关调用</strong></h5><p><strong>1）</strong><em><strong>*pthread_rwlock_t*</strong></em></p>
<p>声明如下。</p>
<p>typedef union</p>
<p>{</p>
<p> struct __pthread_rwlock_arch_t __data;</p>
<p> char __size[__SIZEOF_PTHREAD_RWLOCK_T];</p>
<p> long int __align;</p>
<p>} pthread_rwlock_t;</p>
<p><strong>2）</strong><em><strong>*pthread_rwlock_init*</strong></em><em><strong>*()*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 为rwlock指向的读写锁分配所有需要的资源，并将锁初始化为未锁定状态。读写锁的属性由attr参数指定，如果attr为NULL，则使用默认属性。当锁的属性为默认时，可以通过宏PTHREAD_RWLOCK_INITIALIZER初始化，即</p>
<p> * pthread_rwlock_t rwlock &#x3D; PTHREAD_RWLOCK_INITIALIZER; 效果和调用当前方法并为attr传入NULL是一样的</p>
<p> * </p>
<p> * @param rwlock 读写锁</p>
<p> * @param attr 读写锁的属性</p>
<p> * @return int 成功则返回0，否则返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</p>
<p><strong>3）</strong><em><strong>*pthread_rwlock_destroy*</strong></em><em><strong>*()*</strong></em></p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 销毁rwlock指向的读写锁对象，并释放它使用的所有资源。当任何线程持有锁的时候销毁锁，或尝试销毁一个未初始化的锁，结果是未定义的。</p>
<p> * </p>
<p> * @param rwlock </p>
<p> * @return int </p>
<p> *&#x2F;</p>
<p>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</p>
<p><strong>4）</strong><em><strong>*pthread_rwlock_rdlock()*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 应用一个读锁到rwlock指向的读写锁上，并使调用线程获得读锁。如果写线程持有锁，调用线程无法获得读锁，它会阻塞直至获得锁。</p>
<p> * </p>
<p> * @param rwlock 读写锁</p>
<p> * @return int 成功返回0，失败返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</p>
<p><strong>5）</strong><em><strong>*pthread_rwlock_wrlock*</strong></em><em><strong>*()*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 应用一个写锁到rwlock指向的读写锁上，并使调用线程获得写锁。只要任意线程持有读写锁，则调用线程无法获得写锁，它将阻塞直至获得写锁。</p>
<p> * </p>
<p> * @param rwlock 读写锁</p>
<p> * @return int 成功返回0，失败返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</p>
<p><strong>6）</strong><em><strong>*pthread_rwlock_unlock*</strong></em><em><strong>*()*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 释放调用线程锁持有的rwlock指向的读写锁。</p>
<p> * </p>
<p> * @param rwlock 读写锁</p>
<p> * @return int 成功返回0.失败返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</p>
<h5 id="4-3-3-3-写操作不加锁测试"><a href="#4-3-3-3-写操作不加锁测试" class="headerlink" title="4.3.3.3 写操作不加锁测试"></a>4.3.3.3 <strong>写操作不加锁测试</strong></h5><p><strong>1）</strong><em><strong>*创建rwlock_test_writer_unlock.c，此时写操作没有加锁*</strong></em></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pthread_rwlock_t rwlock;</p>
<p>int shared_data &#x3D; 0;</p>
<p>void *lock_reader(void *argv) {</p>
<p>  pthread_rwlock_rdlock(&amp;rwlock);</p>
<p>  printf(“this is %s, value is %d\n”, (char *)argv, shared_data);</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>void *lock_writer(void *argv) {</p>
<p>  int tmp &#x3D; shared_data + 1;</p>
<p>  sleep(1);</p>
<p>  shared_data &#x3D; tmp;</p>
<p>  printf(“this is %s, shared_data++\n”, (char *)argv);</p>
<p>}</p>
<p>int main() {</p>
<p>  pthread_rwlock_init(&amp;rwlock, NULL);</p>
<p>  pthread_t writer1, writer2, reader1, reader2, reader3, reader4, reader5, reader6;</p>
<p>  pthread_create(&amp;writer1, NULL, lock_writer, “writer1”);</p>
<p>  pthread_create(&amp;writer2, NULL, lock_writer, “writer2”);</p>
<p>  sleep(3);</p>
<p>  pthread_create(&amp;reader1, NULL, lock_reader, “reader1”);</p>
<p>  pthread_create(&amp;reader2, NULL, lock_reader, “reader2”);</p>
<p>  pthread_create(&amp;reader3, NULL, lock_reader, “reader3”);</p>
<p>  pthread_create(&amp;reader4, NULL, lock_reader, “reader4”);</p>
<p>  pthread_create(&amp;reader5, NULL, lock_reader, “reader5”);</p>
<p>  pthread_create(&amp;reader6, NULL, lock_reader, “reader6”);</p>
<p>  pthread_join(writer1, NULL);</p>
<p>  pthread_join(writer2, NULL);</p>
<p>  pthread_join(reader1, NULL);</p>
<p>  pthread_join(reader2, NULL);</p>
<p>  pthread_join(reader3, NULL);</p>
<p>  pthread_join(reader4, NULL);</p>
<p>  pthread_join(reader5, NULL);</p>
<p>  pthread_join(reader6, NULL);</p>
<p>  pthread_rwlock_destroy(&amp;rwlock);</p>
<p>}</p>
<p>我们在每个写操作中都将共享变量shared_data的值加一，但这不是个原子操作，分成了两步：①先将其值加一，赋给临时变量tmp，②然后将tmp的值赋给shared_data。在这两步之间睡眠一秒。这样一来，两个写线程只有按照严格的先后顺序执行，shared_data的值才会+2变为2，触发了竞态条件。</p>
<p>为了观察两次写操作之后的数据，我们在创建写线程之后睡眠两秒，确保大多数情况下读操作读到的是两次写操作之后的数据。</p>
<p><strong>2）</strong><em><strong>*在Makefile中新增以下内容*</strong></em></p>
<p>rwlock_test_writer_unlock: rwlock_test_writer_unlock.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>3）</strong><em><strong>*运行*</strong></em></p>
<p>执行上一步的程序，我们可以看到读操作读取到的shared_data均为1，说明两次写操作并没有在前者的基础上+1，实质上两次加一操作只有一次生效。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps100.jpg" alt="img"> </p>
<h5 id="4-3-3-4-写操作添加读写锁"><a href="#4-3-3-4-写操作添加读写锁" class="headerlink" title="4.3.3.4 写操作添加读写锁"></a>4.3.3.4 <strong>写操作添加读写锁</strong></h5><p><strong>1）</strong><em><strong>*创建*</strong></em><em><strong>*rwlock_test.c*</strong></em><em><strong>*，写入以下内容。*</strong></em></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pthread_rwlock_t rwlock;</p>
<p>int shared_data &#x3D; 0;</p>
<p>void *lock_reader(void *argv) {</p>
<p>  pthread_rwlock_rdlock(&amp;rwlock);</p>
<p>  printf(“this is %s, value is %d\n”, (char *)argv, shared_data);</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>void *lock_writer(void *argv) {</p>
<p>  <em>*<em>*<em>pthread_rwlock_wrlock*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>&amp;*<em>***<em>*<em>*<em>rwlock*</em>*</em>*</em>***</em>);*<em>*</em>*</p>
<p>  int tmp &#x3D; shared_data + 1;</p>
<p>  sleep(1);</p>
<p>  shared_data &#x3D; tmp;</p>
<p>  printf(“this is %s, shared_data++\n”, (char *)argv);</p>
<p>  <em>*<em>*<em>pthread_rwlock_unlock*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>&amp;*<em>***<em>*<em>*<em>rwlock*</em>*</em>*</em>***</em>);*<em>*</em>*</p>
<p>}</p>
<p>int main() {</p>
<p>  pthread_rwlock_init(&amp;rwlock, NULL);</p>
<p>  pthread_t writer1, writer2, reader1, reader2, reader3, reader4, reader5, reader6;</p>
<p>  pthread_create(&amp;writer1, NULL, lock_writer, “writer1”);</p>
<p>  pthread_create(&amp;writer2, NULL, lock_writer, “writer2”);</p>
<p>  sleep(3);</p>
<p>  pthread_create(&amp;reader1, NULL, lock_reader, “reader1”);</p>
<p>  pthread_create(&amp;reader2, NULL, lock_reader, “reader2”);</p>
<p>  pthread_create(&amp;reader3, NULL, lock_reader, “reader3”);</p>
<p>  pthread_create(&amp;reader4, NULL, lock_reader, “reader4”);</p>
<p>  pthread_create(&amp;reader5, NULL, lock_reader, “reader5”);</p>
<p>  pthread_create(&amp;reader6, NULL, lock_reader, “reader6”);</p>
<p>  pthread_join(writer1, NULL);</p>
<p>  pthread_join(writer2, NULL);</p>
<p>  pthread_join(reader1, NULL);</p>
<p>  pthread_join(reader2, NULL);</p>
<p>  pthread_join(reader3, NULL);</p>
<p>  pthread_join(reader4, NULL);</p>
<p>  pthread_join(reader5, NULL);</p>
<p>  pthread_join(reader6, NULL);</p>
<p>  pthread_rwlock_destroy(&amp;rwlock);</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>rwlock_test: rwlock_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>3）</strong><em><strong>*运行*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps101.jpg" alt="img"> </p>
<p>此时读到的数据均为2。</p>
<h5 id="4-3-3-5-读写操作执行顺序随机"><a href="#4-3-3-5-读写操作执行顺序随机" class="headerlink" title="4.3.3.5 读写操作执行顺序随机"></a>4.3.3.5 <strong>读写操作执行顺序随机</strong></h5><p>在上一节的基础上，我们对程序做以下改动：</p>
<p>① 删除写操作的sleep()操作</p>
<p>② 删除主线程中创建写线程之后的睡眠操作</p>
<p>③ 将第二次写操作置于第三次读操作之后。</p>
<p>这样做的目的是尽可能让读写操作间隔执行，但要注意的是，线程的执行顺序是由操作系统内核调度的，其运行规律并不简单地为“先创建先执行”。</p>
<p><strong>1）</strong><em><strong>*创建rwlock_rw_alternate.c*</strong></em></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pthread_rwlock_t rwlock;</p>
<p>int shared_data &#x3D; 0;</p>
<p>void *lock_reader(void *argv) {</p>
<p>  pthread_rwlock_rdlock(&amp;rwlock);</p>
<p>  printf(“this is %s, value is %d\n”, (char *)argv, shared_data);</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>void *lock_writer(void *argv) {</p>
<p>  pthread_rwlock_wrlock(&amp;rwlock);</p>
<p>  int tmp &#x3D; shared_data + 1;</p>
<p>  shared_data &#x3D; tmp;</p>
<p>  printf(“this is %s, shared_data++\n”, (char *)argv);</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>int main() {</p>
<p>  pthread_rwlock_init(&amp;rwlock, NULL);</p>
<p>  pthread_t writer1, writer2, reader1, reader2, reader3, reader4, reader5, reader6;</p>
<p>  pthread_create(&amp;writer1, NULL, lock_writer, “writer1”);</p>
<p>  pthread_create(&amp;reader1, NULL, lock_reader, “reader1”);</p>
<p>  pthread_create(&amp;reader2, NULL, lock_reader, “reader2”);</p>
<p>  pthread_create(&amp;reader3, NULL, lock_reader, “reader3”);</p>
<p>  <em>*<em>*<em>pthread_create*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>&amp;*<em>*****<em>*<em>writer2,*</em>*</em></em> <em>*<em>*<em>NULL*</em>*</em>*</em><strong>*<em>, lock_writer,*</em>*</strong> <em>*<em>*</em>“writer2”***</em><strong>*<em>*</em>);***</strong></p>
<p>  pthread_create(&amp;reader4, NULL, lock_reader, “reader4”);</p>
<p>  pthread_create(&amp;reader5, NULL, lock_reader, “reader5”);</p>
<p>  pthread_create(&amp;reader6, NULL, lock_reader, “reader6”);</p>
<p>  pthread_join(writer1, NULL);</p>
<p>  pthread_join(writer2, NULL);</p>
<p>  pthread_join(reader1, NULL);</p>
<p>  pthread_join(reader2, NULL);</p>
<p>  pthread_join(reader3, NULL);</p>
<p>  pthread_join(reader4, NULL);</p>
<p>  pthread_join(reader5, NULL);</p>
<p>  pthread_join(reader6, NULL);</p>
<p>  pthread_rwlock_destroy(&amp;rwlock);</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>rwlock_random_order: rwlock_random_order.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>3）</strong><em><strong>*运行*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps102.jpg" alt="img"> </p>
<p>此时读写进程执行的顺序是不确定的。</p>
<h5 id="4-3-3-6-写饥饿测试"><a href="#4-3-3-6-写饥饿测试" class="headerlink" title="4.3.3.6 写饥饿测试"></a>4.3.3.6 <strong>写饥饿测试</strong></h5><p><strong>1）</strong><em><strong>*创建rwlock_write_hungry.c*</strong></em></p>
<p>在上一节的基础上，在读操作中添加1s的休眠。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pthread_rwlock_t rwlock;</p>
<p>int shared_data &#x3D; 0;</p>
<p>void *lock_reader(void *argv) {</p>
<p>  pthread_rwlock_rdlock(&amp;rwlock);</p>
<p>  printf(“this is %s, value is %d\n”, (char *)argv, shared_data);</p>
<p>  <em>*<em>*<em>sleep*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>1*</em>*******</em>);*<em>*</em>*</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>void *lock_writer(void *argv) {</p>
<p>  pthread_rwlock_wrlock(&amp;rwlock);</p>
<p>  int tmp &#x3D; shared_data + 1;</p>
<p>  shared_data &#x3D; tmp;</p>
<p>  printf(“this is %s, shared_data++\n”, (char *)argv);</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>int main() {</p>
<p>  pthread_rwlock_init(&amp;rwlock, NULL);</p>
<p>  pthread_t writer1, writer2, reader1, reader2, reader3, reader4, reader5, reader6;</p>
<p>  pthread_create(&amp;writer1, NULL, lock_writer, “writer1”);</p>
<p>  pthread_create(&amp;reader1, NULL, lock_reader, “reader1”);</p>
<p>  pthread_create(&amp;reader2, NULL, lock_reader, “reader2”);</p>
<p>  pthread_create(&amp;reader3, NULL, lock_reader, “reader3”);</p>
<p>  pthread_create(&amp;writer2, NULL, lock_writer, “writer2”);</p>
<p>  pthread_create(&amp;reader4, NULL, lock_reader, “reader4”);</p>
<p>  pthread_create(&amp;reader5, NULL, lock_reader, “reader5”);</p>
<p>  pthread_create(&amp;reader6, NULL, lock_reader, “reader6”);</p>
<p>  pthread_join(writer1, NULL);</p>
<p>  pthread_join(writer2, NULL);</p>
<p>  pthread_join(reader1, NULL);</p>
<p>  pthread_join(reader2, NULL);</p>
<p>  pthread_join(reader3, NULL);</p>
<p>  pthread_join(reader4, NULL);</p>
<p>  pthread_join(reader5, NULL);</p>
<p>  pthread_join(reader6, NULL);</p>
<p>  pthread_rwlock_destroy(&amp;rwlock);</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>rwlock_write_hungry: rwlock_write_hungry.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>3）</strong><em><strong>*多次运行*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps103.jpg" alt="img"> </p>
<p>多次运行后，我们发现，此时读操作总是连续执行的，且读操作休眠未结束时，写操作会被阻塞。与工作原理相符：① 读操作可以并发执行，相互之间不必争抢锁，多个读操作可以同时获得读锁；② 只要有一个线程持有读写锁，写操作就会被阻塞。我们在读操作中加了1s休眠，只要有一个读线程获得锁，在1s内写操作是无法执行的，其它读操作就可以有充足的时间执行，因此读操作就会连续发生，写操作必须等待所有读操作执行完毕方可获得读写锁执行写操作。这就是使用读写锁时存在的潜在问题：写饥饿。</p>
<p><strong>4）</strong><em><strong>*写饥饿*</strong></em></p>
<p>① 问题描述</p>
<p>读写锁的写饥饿问题（Writer Starvation）是指在使用读写锁时，写线程可能无限期地等待获取写锁，因为读线程持续地获取读锁而不断地推迟写线程的执行。这种情况通常在读操作远多于写操作时出现。</p>
<p>② 解决方案</p>
<p>Linux提供了可以修改的属性pthread_rwlockattr_t，默认情况下，属性中指定的策略为“读优先”，当写操作阻塞时，读线程依然可以获得读锁，从而在读操作并发较高时导致写饥饿问题。我们可以尝试将策略更改为“写优先”，当写操作阻塞时，读线程无法获取锁，避免了写线程持有锁的时间持续延长，使得写线程获取锁的等待时间显著降低，从而避免写饥饿问题。</p>
<p><strong>5）</strong><em><strong>*写饥饿问题解决方案*</strong></em></p>
<p>（1）pthread_rwlockattr_t</p>
<p>声明如下。</p>
<p>typedef union</p>
<p>{</p>
<p> char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];</p>
<p> long int __align;</p>
<p>} pthread_rwlockattr_t;</p>
<p>（2）pthread_rwlockattr_init</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 用所有属性的默认值初始化attr指向的属性对象</p>
<p> * </p>
<p> * @param attr 读写锁属性对象指针</p>
<p> * @return int 成功返回0，失败返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);</p>
<p>（3）pthread_rwlockattr_destroy</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 销毁读写锁属性对象</p>
<p> * </p>
<p> * @param attr 读写锁属性对象指针</p>
<p> * @return int 成功返回0，失败返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);</p>
<p>（4）pthread_rwlockattr_setkind_np</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将attr指向的属性对象中的”锁类型”属性设置为pref规定的值</p>
<p> * </p>
<p> * @param attr 读写锁属性对象指针</p>
<p> * @param pref 希望设置的锁类型，可以被设置为以下三种取值的其中一种</p>
<p> * PTHREAD_RWLOCK_PREFER_READER_NP: 默认值，读线程拥有更高优先级。当存在阻塞的写线程时，读线程仍然可以获得读写锁。只要不断有新的读线程，写线程将一直保持”饥饿”。</p>
<p> * PTHREAD_RWLOCK_PREFER_WRITER_NP: 写线程拥有更高优先级。这一选项被glibc忽略。</p>
<p> * PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: 写线程拥有更高优先级，在当前系统环境下，它是有效的，将锁类型设置为该值以避免写饥饿。</p>
<p> * @return int 成功返回0，失败返回非零的错误码</p>
<p> *&#x2F;</p>
<p>int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *attr, int pref);</p>
<p>（5）创建rwlock_hungry_solved.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pthread_rwlock_t rwlock;</p>
<p>int shared_data &#x3D; 0;</p>
<p>void *lock_reader(void *argv)</p>
<p>{</p>
<p>  pthread_rwlock_rdlock(&amp;rwlock);</p>
<p>  printf(“this is %s, value is %d\n”, (char *)argv, shared_data);</p>
<p>  sleep(1);</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>void *lock_writer(void *argv)</p>
<p>{</p>
<p>  pthread_rwlock_wrlock(&amp;rwlock);</p>
<p>  int tmp &#x3D; shared_data + 1;</p>
<p>  shared_data &#x3D; tmp;</p>
<p>  printf(“this is %s, shared_data++\n”, (char *)argv);</p>
<p>  pthread_rwlock_unlock(&amp;rwlock);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_rwlockattr_t attr;</p>
<p>  pthread_rwlockattr_init(&amp;attr);</p>
<p>  &#x2F;&#x2F; 设置写优先</p>
<p>  pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);</p>
<p>  pthread_rwlock_init(&amp;rwlock, &amp;attr);</p>
<p>  pthread_rwlockattr_destroy(&amp;attr);</p>
<p>  pthread_t writer1, writer2, reader1, reader2, reader3, reader4, reader5, reader6;</p>
<p>  pthread_create(&amp;writer1, NULL, lock_writer, “writer1”);</p>
<p>  pthread_create(&amp;reader1, NULL, lock_reader, “reader1”);</p>
<p>  pthread_create(&amp;reader2, NULL, lock_reader, “reader2”);</p>
<p>  pthread_create(&amp;reader3, NULL, lock_reader, “reader3”);</p>
<p>  pthread_create(&amp;writer2, NULL, lock_writer, “writer2”);</p>
<p>  pthread_create(&amp;reader4, NULL, lock_reader, “reader4”);</p>
<p>  pthread_create(&amp;reader5, NULL, lock_reader, “reader5”);</p>
<p>  pthread_create(&amp;reader6, NULL, lock_reader, “reader6”);</p>
<p>  pthread_join(writer1, NULL);</p>
<p>  pthread_join(writer2, NULL);</p>
<p>  pthread_join(reader1, NULL);</p>
<p>  pthread_join(reader2, NULL);</p>
<p>  pthread_join(reader3, NULL);</p>
<p>  pthread_join(reader4, NULL);</p>
<p>  pthread_join(reader5, NULL);</p>
<p>  pthread_join(reader6, NULL);</p>
<p>  pthread_rwlock_destroy(&amp;rwlock);</p>
<p>}</p>
<p>（6）Makefile</p>
<p>rwlock_hungry_solved: rwlock_hungry_solved.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（7）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps104.jpg" alt="img"> </p>
<p>可以发现，此时的连续六次读操作间夹杂了写操作，不再连续，写操作不必等待所有读操作完成才可以执行。不必长期等待，写饥饿问题已得到解决。</p>
<h4 id="4-3-4-自旋锁"><a href="#4-3-4-自旋锁" class="headerlink" title="4.3.4 自旋锁"></a>4.3.4 <strong>自旋锁</strong></h4><p>在Linux内核中，自旋锁是一种用于多处理器系统中的低级同步机制，主要用于保护非常短的代码段或数据结构，以避免多个处理器同时访问共享资源。自旋锁相对于其他锁的优点是它们在锁被占用时会持续检查锁的状态（即“自旋”），而不是让线程进入休眠。这使得自旋锁在等待时间非常短的情况下非常有效，因为它避免了线程上下文切换的开销。</p>
<p>自旋锁<strong>主要用于内核模块或驱动程序中</strong>，避免上下文切换的开销。<strong>不能在用户空间</strong>使用。</p>
<h4 id="4-3-5-条件变量"><a href="#4-3-5-条件变量" class="headerlink" title="4.3.5 条件变量"></a>4.3.5 <strong>条件变量</strong></h4><p><strong>1）</strong><em><strong>*restrict关键字*</strong></em></p>
<p>restrict是一个C99标准引入的关键字，用于修饰指针，它的作用是告诉编译器，被修饰的指针是编译器所知的唯一一个可以在其作用域内用来访问指针所指向的对象的方法。这样一来，编译器可以放心地执行代码优化，因为不存在其他的别名（即其他指向同一内存区域的指针）会影响到这块内存的状态。</p>
<p>restrict声明了一种约定，主要目的是允许编译器在生成代码时做出优化假设，而不是在程序的不同部分间强制执行内存访问的规则。程序员需要确保遵守restrict的约定，编译器则依赖这个约定来进行优化。如果restrict约定被违反，可能导致未定义行为。</p>
<p>函数参数使用restrict修饰，相当于约定：函数执行期间，该参数指向的内存区域不会被其它指针修改。</p>
<p><strong>2）</strong><em><strong>*线程间条件切换函数*</strong></em></p>
<p>如果需要两个线程协同工作，可以使用条件变量完成线程切换。查看文档可得：</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 调用该方法的线程必须持有mutex锁。调用该方法的线程会阻塞并临时释放mutex锁，并等待其他线程调用pthread_cond_signal或pthread_cond_broadcast唤醒。被唤醒后该线程会尝试重新获取mutex锁。</p>
<p> * </p>
<p> * @param cond 指向条件变量的指针。条件变量用于等待某个条件的发生。通过某一cond等待的线程需要通过同一cond的signal唤醒</p>
<p> * @param mutex 与条件变量配合使用的互斥锁的指针。在调用pthread_cond_wait之前，线程必须已经获得了这个互斥锁。</p>
<p> * @return int 成功时返回0；失败时返回错误码，而非-1。错误码可能包括EINVAL、EPERM等，具体取决于错误的性质。</p>
<p> *&#x2F;</p>
<p>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</p>
<p>&#x2F;**</p>
<p> * @brief 同pthread_cond_wait相似，但是它添加了超时机制。如果在指定的abstime时间内条件变量没有被触发，函数将返回一个超时错误（ETIMEDOUT）。</p>
<p> * </p>
<p> * @param cond 指向条件变量的指针</p>
<p> * @param mutex 与条件变量配合使用的互斥锁的指针</p>
<p> * @param abstime 指向timespec结构的指针，表示等待条件变量的绝对超时时间。timespec结构包含秒和纳秒两部分，指定了从某一固定点（如UNIX纪元，1970年1月1日）开始的时间。</p>
<p> * @return int 成功时返回0；如果超时则返回ETIMEDOUT；其他错误情况返回相应的错误码。</p>
<p> *&#x2F;</p>
<p>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</p>
<p>&#x2F;**</p>
<p> * @brief 唤醒因cond而阻塞的线程，如果有多个线程因为cond阻塞，那么随机唤醒一个。如果没有线程在等待，这个函数什么也不做。</p>
<p> * </p>
<p> * @param cond 指向条件变量的指针</p>
<p> * @return int 成功时返回0；失败时返回错误码</p>
<p> *&#x2F;</p>
<p>int pthread_cond_signal(pthread_cond_t *cond);</p>
<p>&#x2F;**</p>
<p> * @brief 唤醒所有正在等待条件变量cond的线程。如果没有线程在等待，这个函数什么也不做。</p>
<p> * </p>
<p> * @param cond 指向条件变量的指针。</p>
<p> * @return int 成功时返回0；失败时返回错误码。</p>
<p> *&#x2F;</p>
<p>int pthread_cond_broadcast(pthread_cond_t *cond);</p>
<p>说明：</p>
<p>（1）使用条件变量时，通常涉及到一个或多个线程等待“条件变量”代表的条件成立，而另外一些线程在条件成立时触发条件变量。</p>
<p>（2）条件变量的使用必须与互斥锁配合，以保证对共享资源的访问是互斥的。</p>
<p>（3）条件变量提供了一种线程间的通信机制，允许线程以无竞争的方式等待特定条件的发生。</p>
<p><strong>3）</strong><em><strong>*条件变量*</strong></em><em><strong>*pthread_cond_t*</strong></em></p>
<p>（1）定义</p>
<p>pthread_cond_t是一个条件变量，它是线程间同步的另一种机制。与pthread_mutex_t相同，它也定义在头文件&lt;pthreadtypes.h&gt;中，其声明如下。</p>
<p>typedef union</p>
<p>{</p>
<p> struct __pthread_cond_s __data;</p>
<p> char __size[__SIZEOF_PTHREAD_COND_T];</p>
<p> <strong>extension</strong> long long int __align;</p>
<p>} pthread_cond_t;</p>
<p>条件变量允许线程挂起执行并释放已持有的互斥锁，等待某个条件变为真。条件变量总是需要与互斥锁一起使用，以避免出现竞态条件。</p>
<p>（2）用途</p>
<p>Ø 允许线程等待特定条件的发生。当条件尚未满足时，线程通过条件变量等待，直到其他线程修改条件并通知条件变量。</p>
<p>Ø 通知等待中的线程条件已改变，允许它们重新评估条件。</p>
<p>（3）操作</p>
<p>Ø 初始化（pthread_cond_init）：创建并初始化条件变量。</p>
<p>Ø 等待（pthread_cond_wait）：在给定的互斥锁上等待条件变量。调用时，线程将释放互斥锁并进入等待状态，直到被唤醒。</p>
<p>Ø 定时等待（pthread_cond_timedwait）：等待条件变量或直到超过指定的时间。</p>
<p>Ø 信号（pthread_cond_signal）：唤醒至少一个等待该条件变量的线程。</p>
<p>Ø 广播（pthread_cond_broadcast）：唤醒所有等待该条件变量的线程。</p>
<p>Ø 销毁（pthread_cond_destroy）：清理条件变量资源。</p>
<p><strong>4）</strong><em><strong>*PTHREAD_COND_INITIALIZER*</strong></em></p>
<p>（1）说明及用法</p>
<p>PTHREAD_COND_INITIALIZER是POSIX线程（Pthreads）库中定义的一个宏，用于在声明时静态初始化条件变量（pthread_cond_t类型的变量）。它提供了一种简单、便捷的方式来初始化条件变量，无需调用初始化函数pthread_cond_init。</p>
<p>使用PTHREAD_COND_INITIALIZER可以让条件变量在程序启动时即处于可用状态，这对于全局或静态分配的条件变量尤其有用。</p>
<p>下面的代码展示了PTHREAD_COND_INITIALIZER的用法。</p>
<p>static pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;</p>
<p>（2）注意事项</p>
<p>Ø 使用PTHREAD_COND_INITIALIZER静态初始化的条件变量通常不需要调用pthread_cond_destroy来销毁。但是，如果条件变量在程序执行期间被重新初始化（通过pthread_cond_init），那么在不再需要时应使用pthread_cond_destroy进行清理。</p>
<p>Ø PTHREAD_COND_INITIALIZER只适用于静态或全局变量的初始化。对于动态分配的条件变量（例如，通过malloc分配的条件变量），应使用pthread_cond_init函数进行初始化。</p>
<p>Ø PTHREAD_COND_INITIALIZER提供的是条件变量的默认属性。如果需要自定义条件变量的属性（例如，改变其pshared属性以支持进程间同步），则需要使用pthread_cond_init和pthread_condattr_t类型的属性对象。</p>
<p><strong>5）</strong><em><strong>*范例程序*</strong></em></p>
<p>（1）创建condition_var.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#define BUFFER_SIZE 5</p>
<p>int buffer[BUFFER_SIZE];</p>
<p>int count &#x3D; 0;</p>
<p>&#x2F;&#x2F; 初始化锁</p>
<p>static pthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;</p>
<p>&#x2F;&#x2F; 初始化条件变量</p>
<p>static pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;</p>
<p>&#x2F;&#x2F; 生产者线程</p>
<p>void *producer(void *arg)</p>
<p>{</p>
<p>  int item &#x3D; 1;</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 获取互斥锁 拿不到等</p>
<p>​    pthread_mutex_lock(&amp;mutex);</p>
<p>​    &#x2F;&#x2F; 如果缓冲区满，等消费者读取</p>
<p>​    while (count &#x3D;&#x3D; BUFFER_SIZE)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F; 暂停线程 等待唤醒</p>
<p>​      pthread_cond_wait(&amp;cond, &amp;mutex);</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 能到这里说明缓冲区不满了 可以写一个</p>
<p>​    buffer[count++] &#x3D; item++;</p>
<p>​    printf(“白月光发送一个幸运数字%d\n”, buffer[count - 1]);</p>
<p>​    &#x2F;&#x2F; 通知消费者可以消费数据了</p>
<p>​    &#x2F;&#x2F; 唤醒消费者 同时解锁</p>
<p>​    pthread_cond_signal(&amp;cond);</p>
<p>​    pthread_mutex_unlock(&amp;mutex);</p>
<p>  }</p>
<p>}</p>
<p>void *consumer(void *arg)</p>
<p>{</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 获取互斥锁 拿不到等</p>
<p>​    pthread_mutex_lock(&amp;mutex);</p>
<p>​    &#x2F;&#x2F; 如果缓冲区为空，则等待生产者生产数据</p>
<p>​    while (count &#x3D;&#x3D; 0)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F; 暂停线程 等待唤醒</p>
<p>​      pthread_cond_wait(&amp;cond, &amp;mutex);</p>
<p>​    }</p>
<p>​    printf(“我收到了幸运数字 %d\n”, buffer[–count]);</p>
<p>​    &#x2F;&#x2F; 通知生产者可以发送数据了</p>
<p>​    &#x2F;&#x2F; 唤醒生产者 同时解锁</p>
<p>​    pthread_cond_signal(&amp;cond);</p>
<p>​    pthread_mutex_unlock(&amp;mutex);</p>
<p>  }</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  pthread_t producer_thread, consumer_thread;</p>
<p>  pthread_create(&amp;producer_thread, NULL, producer, NULL);</p>
<p>  pthread_create(&amp;consumer_thread, NULL, consumer, NULL);</p>
<p>  pthread_join(producer_thread, NULL);</p>
<p>  pthread_join(consumer_thread, NULL);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>condition_var: condition_var.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）终止程序</p>
<p>程序运行过快，为了查看控制台数据，终止程序，光标移至控制台，同时按下Ctrl+C。</p>
<p>（4）查看控制台输出</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps105.jpg" alt="img"> </p>
<p>控制台输出如上所示。</p>
<p>可以看到producer线程生产数据，consumer线程消费数据，二者交替工作。</p>
<h4 id="4-3-6-信号量"><a href="#4-3-6-信号量" class="headerlink" title="4.3.6 信号量"></a>4.3.6 <strong>信号量</strong></h4><h5 id="4-3-6-1-信号量相关概念"><a href="#4-3-6-1-信号量相关概念" class="headerlink" title="4.3.6.1 信号量相关概念"></a>4.3.6.1 <strong>信号量相关概念</strong></h5><p>信号量（Semaphore）是一种广泛使用的同步机制，用于控制对共享资源的访问，主要在操作系统和并发编程领域中得到应用。信号量是由Edsger Dijkstra在1960年代提出的，用来解决多个<strong>进程或线程</strong>间的同步与互斥问题。</p>
<p>与共享存储等不同，在Linux中，信号量是用来协调进程或线程的执行的，并不承担传输数据的职责。</p>
<p><strong>1）</strong><em><strong>*基本概念*</strong></em></p>
<p>信号量本质上是一个非负整数变量，可以被用来控制对共享资源的访问。它主要用于两种目的：互斥和同步。</p>
<p>（1）互斥（Mutex）：确保多个进程或线程不会同时访问临界区（即访问共享资源的代码区域）。</p>
<p>（2）同步（Synchronization）：协调多个进程或线程的执行顺序，确保它们按照一定的顺序执行。</p>
<p><strong>2）</strong><em><strong>*基于用途的分类*</strong></em></p>
<p>基于不同的目的，信号量可以分为两类：用于实现互斥的“二进制信号量”和用于同步的“计数信号量”。</p>
<p>（1）二进制信号量（或称作互斥锁）：其值只能是0或1，主要用于实现互斥，即一次只允许一个线程进入临界区。通常用于控制共享资源的访问，避免竞态条件的产生。</p>
<p>（2）计数信号量：其值可以是任意非负整数，表示可用资源的数量。计数信号量允许多个线程根据可用资源的数量进入临界区。通常用于控制不同进程或线程执行的顺序，如消费者必须在生产者发送数据后才可以消费。</p>
<p><strong>3）</strong><em><strong>*基于名称的分类*</strong></em></p>
<p>在Linux中，根据是否具有唯一的名称，分为有名信号量（named semaphore）和无名信号量（unnamed semaphore）。这两种信号量特性有所不同：</p>
<p>（1）无名信号量</p>
<p>无名信号量不是通过名称标识，而是直接通过sem_t结构的内存位置标识。无名信号量在使用前需要初始化，在不再需要时应该销毁。它们不需要像有名信号量那样进行创建和链接，因此设置起来更快，运行效率也更高。</p>
<p>（2）有名信号量</p>
<p>有名信号量在系统范围内是可见的，可以在任意进程之间进行通信。它们通过名字唯一标识，这使得不同的进程可以通过这个名字访问同一个信号量对象。</p>
<p>在当前Linux系统中，有名信号量在临时文件系统中的对应文件位于&#x2F;dev&#x2F;shm目录下，创建它们时可以像普通文件一样设置权限模式，限制不同用户的访问权限。</p>
<p><strong>4）</strong><em><strong>*操作*</strong></em></p>
<p>信号量主要提供了两个操作：P操作和V操作。</p>
<p>（1）P操作（Proberen，尝试）：也称为等待操作（wait），用于减少信号量的值。如果信号量的值大于0，它就减1并继续执行；如果信号量的值为0，则进程或线程阻塞，直到信号量的值变为非零。</p>
<p>（2）V操作（Verhogen，增加）：也称为信号操作（signal），用于增加信号量的值。如果有其他进程或线程因信号量的值为0而阻塞，这个操作可能会唤醒它们。</p>
<h5 id="4-3-6-2-无名信号量"><a href="#4-3-6-2-无名信号量" class="headerlink" title="4.3.6.2 无名信号量"></a>4.3.6.2 <strong>无名信号量</strong></h5><p>无名信号量和有名信号量都可以用作二进制信号量和计数信号量。</p>
<p><strong>1）</strong><em><strong>*知识储备*</strong></em></p>
<p>（1）sem_init()</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 在sem指向的地址初始化一个无名信号量。</p>
<p> * </p>
<p> * @param sem 信号量地址</p>
<p> * @param pshared 指明信号量是线程间共享还是进程间共享的</p>
<p> * 0: 信号量是线程间共享的，应该被置于所有线程均可见的地址（如，全局变量或在堆中动态分配的变量）</p>
<p> * 非0: 信号量是进程间共享的，应该被置于共享内存区域，任何进程只要能访问共享内存区域，即可操作进程间共享的信号量</p>
<p> * @param value 信号量的初始值</p>
<p> * @return int 成功返回0，失败返回-1，同时errno被设置以记录错误信息</p>
<p> *&#x2F;</p>
<p>int sem_init(sem_t *sem, int pshared, unsigned int value);</p>
<p>（2）sem_destroy()</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 销毁sem指向的无名信号量</p>
<p> * </p>
<p> * @param sem 无名信号量</p>
<p> * @return int 成功返回0，失败返回-1，并设置errno指示错误原因</p>
<p> *&#x2F;</p>
<p>int sem_destroy(sem_t *sem);</p>
<p>（3）sem_post()</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将sem指向的信号量加一，如果信号量从0变为1，且其他进程或线程因信号量而阻塞，则阻塞的进程或线程会被唤醒并获取信号量，然后继续执行。POSIX标准并未明确定义唤醒策略，具体唤醒的是哪个进程或线程取决于操作系统的调度策略。</p>
<p> * </p>
<p> * @param sem 信号量指针</p>
<p> * @return int 成功返回0，失败则信号量的值未被修改，返回-1，并设置errno以指明错误原因</p>
<p> *&#x2F;</p>
<p>int sem_post(sem_t *sem);</p>
<p>（4）sem_wait()</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将sem指向的信号量减一。如果信号量的值大于0，函数可以执行减一操作，然后立即返回，调用线程继续执行。如果当前信号量的值是0，则调用阻塞直至信号量的值大于0，或信号处理函数打断当前调用。</p>
<p> * </p>
<p> * @param sem 信号量指针</p>
<p> * @return int 成功返回0，失败则信号量的值保持不变，返回-1，并设置errno以指明错误原因</p>
<p> *&#x2F;</p>
<p>int sem_wait(sem_t *sem);</p>
<p>（5）time_t</p>
<p>本质上就是long int即long类型。</p>
<p>（6）time()</p>
<p>#include &lt;time.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 返回以秒为单位的UNIX时间戳</p>
<p> * </p>
<p> * @param tloc 记录时间的指针，如果不为NULL，则当前的UNIX秒级时间戳也会存在tloc指向的位置，否则不会存储。</p>
<p> * @return time_t 成功则返回以秒为单位的UNIX时间戳，失败则返回(time_t)-1</p>
<p> *&#x2F;</p>
<p>time_t time(time_t *tloc);</p>
<p>（7）rand()</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 返回一个 0-RAND_MAX 之间的伪随机数。当前机器环境下，RAND_MAX为int类型的最大值</p>
<p> * </p>
<p> * @return int 伪随机数</p>
<p> *&#x2F;</p>
<p>int rand(void);</p>
<p>（8）srand()</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将seed设置为rand()生成随机数时使用的随机种子，如果没有设置随机种子，rand()会自动将1作为随机种子</p>
<p> * </p>
<p> * @param seed 随机种子</p>
<p> *&#x2F;</p>
<p>void srand(unsigned int seed);</p>
<p><strong>2）</strong><em><strong>*作为二进制信号量用于线程间通信*</strong></em></p>
<p>二进制信号量的作用和互斥锁是相同的。</p>
<p>（1）存在竞态条件的测试例程</p>
<p>① 创建unnamed_sem_bin_thread_condition.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>int shard_num &#x3D; 0;</p>
<p>void *plusOne(void *argv) {</p>
<p>  int tmp &#x3D; shard_num + 1;</p>
<p>  shard_num &#x3D; tmp;</p>
<p>}</p>
<p>int main() {</p>
<p>  pthread_t tid[10000];</p>
<p>  for (int i &#x3D; 0; i &lt; 10000; i++) {</p>
<p>​    pthread_create(tid + i, NULL, plusOne, NULL);</p>
<p>  }</p>
<p>  for (int i &#x3D; 0; i &lt; 10000; i++) {</p>
<p>​    pthread_join(tid[i], NULL);</p>
<p>  }</p>
<p>  printf(“shard_num is %d\n”, shard_num);</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>unnamed_sem_bin_thread_condition: unnamed_sem_bin_thread_condition.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p>多次执行，我们会发现，所有线程执行完毕之后，shared_num的值并不总是10000，这是因为shared_num的加一并不是原子操作，如果某个线程执行了int num&#x3D;shared_num+1，在它将tmp的值赋给shared_num之前，别的线程执行了第一步，那么加一操作就会被“吞掉”，最终导致10000次加一的结果并未全部生效，因而shared_num小于10000。</p>
<p>结果如下，shared_num的值可能小于10000。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps106.jpg" alt="img"> </p>
<p>（2）解决了竞态条件的测试例程</p>
<p>① 创建unnamed_sem_bin_thread.c，写入以下内容。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p><em>*<em>*<em>sem_t*</em>*</em>* <em>*<em>*<em>unnamed_sem*</em>*</em>*</em></em><em>*</em>;*<em>*</em>*</p>
<p>int shard_num &#x3D; 0;</p>
<p>void *plusOne(void *argv) {</p>
<p>  <em>*<em>*<em>sem_wait*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>&amp;*<em>***<em>*<em>*<em>unnamed_sem*</em>*</em>*</em>***</em>);*<em>*</em>*</p>
<p>  int tmp &#x3D; shard_num + 1;</p>
<p>  shard_num &#x3D; tmp;</p>
<p>  <em>*<em>*<em>sem_post*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>&amp;*<em>***<em>*<em>*<em>unnamed_sem*</em>*</em>*</em>***</em>);*<em>*</em>*</p>
<p>}</p>
<p>int main() {</p>
<p>  <em>*<em>*<em>sem_init*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>&amp;*<em>***<em>*<em>*<em>unnamed_sem*</em>*</em>*</em>***</em>,*<em>*</em>* <em>*<em>*<em>0*</em>*</em>*</em><strong>*<em>,*</em>*</strong> <em>*<em>*<em>1*</em>*</em>*</em><strong>*<em>);*</em>*</strong></p>
<p>  pthread_t tid[10000];</p>
<p>  for (int i &#x3D; 0; i &lt; 10000; i++) {</p>
<p>​    pthread_create(tid + i, NULL, plusOne, NULL);</p>
<p>  }</p>
<p>  for (int i &#x3D; 0; i &lt; 10000; i++) {</p>
<p>​    pthread_join(tid[i], NULL);</p>
<p>  }</p>
<p>  printf(“shard_num is %d\n”, shard_num);</p>
<p>  <em>*<em>*<em>sem_destroy*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>&amp;*<em>***<em>*<em>*<em>unnamed_sem*</em>*</em>*</em>***</em>);*<em>*</em>*</p>
<p>  return 0;</p>
<p>}</p>
<p>在这里，我们通过二进制信号量起到了互斥锁的作用，避免了线程间的竞态条件。</p>
<p>② Makefile</p>
<p>unnamed_sem_bin_thread: unnamed_sem_bin_thread.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps107.jpg" alt="img"> </p>
<p>多次执行，结果稳定在10000。</p>
<p><strong>3）</strong><em><strong>*作为二进制信号量用于进程间通信*</strong></em></p>
<p>需要注意的是，线程比进程的资源共享程度更高，可以用于进程间通信的方式，通常也可以用于线程间通信。</p>
<p>（1）存在竞态条件的例程</p>
<p>① 创建unnamed_sem_bin_process_condition.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main() {</p>
<p>  char *shm_value_name &#x3D; “unnamed_sem_shm_value”;</p>
<p>  &#x2F;&#x2F; 创建内存共享对象</p>
<p>  int value_fd &#x3D; shm_open(shm_value_name, O_CREAT | O_RDWR, 0666);</p>
<p>  &#x2F;&#x2F; 调整内存共享对象的大小</p>
<p>  ftruncate(value_fd, sizeof(int));</p>
<p>  &#x2F;&#x2F; 将内存共享对象映射到共享内存区域</p>
<p>  int *value &#x3D; mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, value_fd, 0);</p>
<p>  &#x2F;&#x2F; 初始化共享变量的值</p>
<p>  *value &#x3D; 0;</p>
<p>  int pid &#x3D; fork();</p>
<p>  if (pid &gt; 0) {</p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>​    </p>
<p>​    &#x2F;&#x2F; 等待子进程执行完毕</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>​    printf(“this is father, child finished\n”);</p>
<p>​    printf(“the final value is %d\n”, *value);</p>
<p>  } else if (pid &#x3D;&#x3D; 0) {</p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>  } else {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 无论父子进程都应该解除共享内存的映射，并关闭共享对象的文件描述符</p>
<p>  if (munmap(value, sizeof(int)) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“munmap value”);</p>
<p>  }</p>
<p>  if (close(value_fd) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“close value”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 如果调用时别的进程仍在使用共享对象，则等待所有进程释放资源后，才会销毁相关资源。</p>
<p>  &#x2F;&#x2F; shm_unlink只能调用一次,这里在父进程中调用shm_unlink</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (shm_unlink(shm_value_name) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“father shm_unlink shm_value_name”);</p>
<p>​    }</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>unnamed_sem_bin_process_condition: unnamed_sem_bin_process_condition.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps108.jpg" alt="img"> </p>
<p>执行后我们发现value指向的位置值为1。两次加一操作只生效一次，出现了竞态条件。</p>
<p>（2）解决了竞态条件的例程</p>
<p>① 创建unnamed_sem_bin_process.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p><em>*<em>*</em>#include***</em>* <em>*<em>*</em>&lt;semaphore.h&gt;***</em>*</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  <strong><em>*<em>char*</em>*</em>* **<em>*</em>***</strong><em><strong><em>*<em>shm_sem_name*</em>*</em>* **<em>*</em>&#x3D;***</strong> <em>*<em>*</em>“unnamed_sem_shm_sem”***</em>***<em>*</em>;*</em>***</p>
<p>  char *shm_value_name &#x3D; “unnamed_sem_shm_value”;</p>
<p>  &#x2F;&#x2F; 创建内存共享对象</p>
<p>  <em>*<em>*<em>int*</em>*</em>* <strong><em>*<em>sem_fd*</em>*</em>* **<em>*</em>&#x3D;***</strong> <em>*<em>*<em>shm_open*</em>*</em>*</em></em><em>*</em>(*<em>***<em>*<em>*<em>shm_sem_name*</em>*</em>*</em>***</em>, O_CREAT*<em>*</em>* <em>*<em>*</em>|***</em>* <em>*<em>*<em>O_RDWR,*</em>*</em>* <em>*<em>*<em>0666*</em>*</em>*</em></em><em>*</em>);*<em>*</em>*</p>
<p>  int value_fd &#x3D; shm_open(shm_value_name, O_CREAT | O_RDWR, 0666);</p>
<p>  &#x2F;&#x2F; 调整内存共享对象的大小</p>
<p>  <em>*<em>*<em>ftruncate*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>sem_fd*</em>*******</em>,*<em>*</em>* <em>*<em>*<em>sizeof*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>sem_t*</em>*******</em>));*<em>*</em>*</p>
<p>  ftruncate(value_fd, sizeof(int));</p>
<p>  &#x2F;&#x2F; 将内存共享对象映射到共享内存区域</p>
<p>  <strong><em>*<em>sem_t*</em>*</em>* **<em>*</em>***</strong><em><strong><em>*<em>sem*</em>*</em>* **<em>*</em>&#x3D;***</strong> <em>*<em>*<em>mmap*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>NULL*</em>*******</em>,*</em>*** <em>*<em>*<em>sizeof*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>sem_t*</em>*******</em>), PROT_READ*<em>*</em>* <em>*<em>*</em>|***</em>* <em>*<em>*<em>PROT_WRITE, MAP_SHARED,*</em>*</em>* <em>*<em>*<em>sem_fd*</em>*</em>*</em></em><em>*</em>,*<em>*</em>* <em>*<em>*<em>0*</em>*</em>*</em><strong>*<em>);*</em>*</strong></p>
<p>  int *value &#x3D; mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, value_fd, 0);</p>
<p>  <em>*<em>*</em>&#x2F;&#x2F; 初始化信号量和共享变量的值***</em>*</p>
<p>  <em>*<em>*<em>sem_init*</em>*</em>*</em><strong>*<em>(sem,*</em>*</strong> <em>*<em>*<em>1*</em>*</em>*</em><strong>*<em>,*</em>*</strong> <em>*<em>*<em>1*</em>*</em>*</em><strong>*<em>);*</em>*</strong></p>
<p>  *value &#x3D; 0;</p>
<p>  int pid &#x3D; fork();</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    <em>*<em>*<em>sem_wait*</em>*</em>*</em><strong>*<em>(sem);*</em>*</strong></p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>​    <em>*<em>*<em>sem_post*</em>*</em>*</em><strong>*<em>(sem);*</em>*</strong></p>
<p>​    &#x2F;&#x2F; 等待子进程执行完毕</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>​    printf(“this is father, child finished\n”);</p>
<p>​    printf(“the final value is %d\n”, *value);</p>
<p>  }</p>
<p>  else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    <em>*<em>*<em>sem_wait*</em>*</em>*</em><strong>*<em>(sem);*</em>*</strong></p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>​    <em>*<em>*<em>sem_post*</em>*</em>*</em><strong>*<em>(sem);*</em>*</strong></p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  <em>*<em>*</em>&#x2F;&#x2F; 父进程执行到这里，子进程已执行完毕，可以销毁信号量***</em>*</p>
<p>  <strong><em>*<em>if*</em>*</em>* **<em>*</em>(***</strong><strong><em>*<em>pid*</em>*</em>* **<em>*</em>&gt;***</strong> <em>*<em>*<em>0*</em>*</em>*</em><strong>*<em>)*</em>*</strong></p>
<p>  <em>*<em>*</em>{***</em>*</p>
<p>​    <strong><em>*<em>if*</em>*</em>* **<em>*</em>(***</strong><em>*<em>*<em>sem_destroy*</em>*</em>*</em><strong>*<em>(sem)*</em>*</strong> <em>*<em>*</em>&#x3D;&#x3D;***</em>* <em>*<em>*</em>-***</em><strong><strong>*<em>1*</em>***</strong><em>*</em>)***</strong></p>
<p>​    <em>*<em>*</em>{***</em>*</p>
<p>​      <em>*<em>*<em>perror*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>“sem_destory”*<em>*******</em>);*<em>*</em>*</p>
<p>​    <em>*<em>*</em>}***</em>*</p>
<p>  <em>*<em>*</em>}***</em>*</p>
<p>  &#x2F;&#x2F; 无论父子进程都应该解除共享内存的映射，并关闭共享对象的文件描述符</p>
<p>  <strong><em>*<em>if*</em>*</em>* **<em>*</em>(***</strong><em>*<em>*<em>munmap*</em>*</em>*</em><strong>*<em>(sem,*</em>*</strong> <em>*<em>*<em>sizeof*</em>*</em>*</em><strong>*<em>(sem))*</em>*</strong> <em>*<em>*</em>&#x3D;&#x3D;***</em>* <em>*<em>*</em>-***</em><strong><strong>*<em>1*</em>***</strong><em>*</em>)***</strong></p>
<p>  <em>*<em>*</em>{***</em>*</p>
<p>​    <em>*<em>*<em>perror*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>“munmap sem”*<em>*******</em>);*<em>*</em>*</p>
<p>  <em>*<em>*</em>}***</em>*</p>
<p>  if (munmap(value, sizeof(int)) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“munmap value”);</p>
<p>  }</p>
<p>  <strong><em>*<em>if*</em>*</em>* **<em>*</em>(***</strong><em>*<em>*<em>close*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>sem_fd*</em>*******</em>)*<em>*</em>* <em>*<em>*</em>&#x3D;&#x3D;***</em>* <em>*<em>*</em>-***</em><strong><strong>*<em>1*</em>***</strong><em>*</em>)***</strong></p>
<p>  <em>*<em>*</em>{***</em>*</p>
<p>​    <em>*<em>*<em>perror*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>“close sem”*<em>*******</em>);*<em>*</em>*</p>
<p>  <em>*<em>*</em>}***</em>*</p>
<p>  if (close(value_fd) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“close value”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 如果调用时别的进程仍在使用共享对象，则等待所有进程释放资源后，才会销毁相关资源。</p>
<p>  &#x2F;&#x2F; shm_unlink只能调用一次,这里在父进程中调用shm_unlink</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    <strong><em>*<em>if*</em>*</em>* **<em>*</em>(***</strong><em>*<em>*<em>shm_unlink*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*<em>shm_sem_name*</em>*******</em>)*<em>*</em>* <em>*<em>*</em>&#x3D;&#x3D;***</em>* <em>*<em>*</em>-***</em><strong><strong>*<em>1*</em>***</strong><em>*</em>)***</strong></p>
<p>​    <em>*<em>*</em>{***</em>*</p>
<p>​      <em>*<em>*<em>perror*</em>*</em>*</em><strong>*<em>(*</em>***</strong><em>*</em>“father shm_unlink shm_sem_name”*<em>*******</em>);*<em>*</em>*</p>
<p>​    <em>*<em>*</em>}***</em>*</p>
<p>​    if (shm_unlink(shm_value_name) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“father shm_unlink shm_value_name”);</p>
<p>​    }</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>unnamed_sem_bin_process: unnamed_sem_bin_process.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps109.jpg" alt="img"> </p>
<p>执行后发现，value指向的位置值为2，竞态条件已被解决。</p>
<p>（3）注意</p>
<p>无名信号量被用于进程间通信时，需要注意两点：</p>
<p>① sem_init()的第二个参数应设置为非零值，来告诉操作系统内核，这个信号量是用来进程间通信的，如果设置为0，则一个进程通过sem_post()释放的信号量无法被其它进程获取，会导致程序卡死。</p>
<p>i）考虑以下程序，创建unnamed_sem_bin_process_illegal.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *shm_sem_name &#x3D; “unnamed_sem_shm_sem”;</p>
<p>  char *shm_value_name &#x3D; “unnamed_sem_shm_value”;</p>
<p>  &#x2F;&#x2F; 创建内存共享对象</p>
<p>  int sem_fd &#x3D; shm_open(shm_sem_name, O_CREAT | O_RDWR, 0666);</p>
<p>  int value_fd &#x3D; shm_open(shm_value_name, O_CREAT | O_RDWR, 0666);</p>
<p>  &#x2F;&#x2F; 调整内存共享对象的大小</p>
<p>  ftruncate(sem_fd, sizeof(sem_t));</p>
<p>  ftruncate(value_fd, sizeof(int));</p>
<p>  &#x2F;&#x2F; 将内存共享对象映射到共享内存区域</p>
<p>  sem_t *sem &#x3D; mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, sem_fd, 0);</p>
<p>  int *value &#x3D; mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, value_fd, 0);</p>
<p>  &#x2F;&#x2F; 初始化信号量和共享变量的值</p>
<p>  <em>*<em>*<em>sem_init*</em>*</em>*</em><strong>*<em>(sem,*</em>*</strong> <em>*<em>*<em>0*</em>*</em>*</em><strong>*<em>,*</em>*</strong> <em>*<em>*<em>1*</em>*</em>*</em><strong>*<em>);*</em>*</strong></p>
<p>  *value &#x3D; 0;</p>
<p>  int pid &#x3D; fork();</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    sem_wait(sem);</p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>​    sem_post(sem);</p>
<p>​    &#x2F;&#x2F; 等待子进程执行完毕</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>​    printf(“this is father, child finished\n”);</p>
<p>​    printf(“the final value is %d\n”, *value);</p>
<p>  }</p>
<p>  else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    sem_wait(sem);</p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>​    sem_post(sem);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 父进程执行到这里，子进程已执行完毕，可以销毁信号量</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (sem_destroy(sem) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“sem_destory”);</p>
<p>​    }</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 无论父子进程都应该解除共享内存的映射，并关闭共享对象的文件描述符</p>
<p>  if (munmap(sem, sizeof(sem)) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“munmap sem”);</p>
<p>  }</p>
<p>  if (munmap(value, sizeof(int)) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“munmap value”);</p>
<p>  }</p>
<p>  if (close(sem_fd) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“close sem”);</p>
<p>  }</p>
<p>  if (close(value_fd) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“close value”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 如果调用时别的进程仍在使用共享对象，则等待所有进程释放资源后，才会销毁相关资源。</p>
<p>  &#x2F;&#x2F; shm_unlink只能调用一次,这里在父进程中调用shm_unlink</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (shm_unlink(shm_sem_name) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“father shm_unlink shm_sem_name”);</p>
<p>​    }</p>
<p>​    if (shm_unlink(shm_value_name) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“father shm_unlink shm_value_name”);</p>
<p>​    }</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>ii）Makefile</p>
<p>unnamed_sem_bin_process_illegal: unnamed_sem_bin_process_illegal.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>iii）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps110.jpg" alt="img"> </p>
<p>执行后，程序卡死。</p>
<p>② 信号量必须置于共享内存区域，以确保多个进程都可以访问，否则每个进程各自管理自己的信号量，后者并没有起到进程间通信的作用。</p>
<p>i）创建unnamed_sem_bin_process_isolate.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *shm_value_name &#x3D; “unnamed_sem_shm_value”;</p>
<p>  &#x2F;&#x2F; 创建内存共享对象</p>
<p>  int value_fd &#x3D; shm_open(shm_value_name, O_CREAT | O_RDWR, 0666);</p>
<p>  &#x2F;&#x2F; 调整内存共享对象的大小</p>
<p>  ftruncate(value_fd, sizeof(int));</p>
<p>  &#x2F;&#x2F; 将内存共享对象映射到共享内存区域</p>
<p>  int *value &#x3D; mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, value_fd, 0);</p>
<p>  **<em>*<em>sem_t*</em>*</em>* **<em>*<em>sem;*</em>*</em>*</p>
<p>  &#x2F;&#x2F; 初始化信号量和共享变量的值</p>
<p>  sem_init(<em>*<em>*</em>&amp;***</em>*****<em>sem*</em>***, 1, 1);</p>
<p>  *value &#x3D; 0;</p>
<p>  int pid &#x3D; fork();</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    sem_wait(<em>*<em>*</em>&amp;***</em>*****<em>sem*</em>***);</p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>​    sem_post(<em>*<em>*</em>&amp;***</em>*****<em>sem*</em>***);</p>
<p>​    &#x2F;&#x2F; 等待子进程执行完毕</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>​    printf(“this is father, child finished\n”);</p>
<p>​    printf(“the final value is %d\n”, *value);</p>
<p>  }</p>
<p>  else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    sem_wait(<em>*<em>*</em>&amp;***</em>*****<em>sem*</em>***);</p>
<p>​    int tmp &#x3D; *value + 1;</p>
<p>​    sleep(1);</p>
<p>​    *value &#x3D; tmp;</p>
<p>​    sem_post(<em>*<em>*</em>&amp;***</em>*****<em>sem*</em>***);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 父进程执行到这里，子进程已执行完毕，可以销毁信号量</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (sem_destroy(<em>*<em>*</em>&amp;***</em>*****<em>sem*</em>***) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“sem_destory”);</p>
<p>​    }</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 无论父子进程都应该解除共享内存的映射，并关闭共享对象的文件描述符</p>
<p>  if (munmap(value, sizeof(int)) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“munmap value”);</p>
<p>  }</p>
<p>  if (close(value_fd) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“close value”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 如果调用时别的进程仍在使用共享对象，则等待所有进程释放资源后，才会销毁相关资源。</p>
<p>  &#x2F;&#x2F; shm_unlink只能调用一次,这里在父进程中调用shm_unlink</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (shm_unlink(shm_value_name) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“father shm_unlink shm_value_name”);</p>
<p>​    }</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>ii）Makefile</p>
<p>unnamed_sem_bin_process_isolate: unnamed_sem_bin_process_isolate.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>iii）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps111.jpg" alt="img"> </p>
<p>执行后，value指向的位置值为1，再次出现了竞态条件。</p>
<p><strong>Tips：</strong>此处为便于讲解，只给出了父子进程间通信的示例，但由于共享内存对象可以被任意进程访问，因此，<strong>无名信号量实际上可以用于任意进程间的通信，而不仅限于父子进程。在非父子进程通信时，共享资源的初始化和释放要格外注意，必须按照合理的顺序进行。</strong></p>
<p><strong>4）</strong><em><strong>*作为计数信号量用于线程间通信*</strong></em></p>
<p>计数信号量主要是用于控制进程或线程执行顺序的。</p>
<p>（1）测试例程</p>
<p>创建unnamed_sem_count_thread.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;time.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>sem_t *full;</p>
<p>sem_t *empty;</p>
<p>int shard_num;</p>
<p>int rand_num()</p>
<p>{</p>
<p>  srand(time(NULL));</p>
<p>  return rand();</p>
<p>}</p>
<p>void *producer(void *argv)</p>
<p>{</p>
<p>  for (int i &#x3D; 0; i &lt; 5; i++)</p>
<p>  {</p>
<p>​    sem_wait(empty);</p>
<p>​    printf(“\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 第 %d 轮数据传输 &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n”, i + 1);</p>
<p>​    sleep(1);</p>
<p>​    shard_num &#x3D; rand_num();</p>
<p>​    printf(“producer has sent data\n”);</p>
<p>​    sem_post(full);</p>
<p>  }</p>
<p>}</p>
<p>void *consumer(void *argv)</p>
<p>{</p>
<p>  for (int i &#x3D; 0; i &lt; 5; i++)</p>
<p>  {</p>
<p>​    sem_wait(full);</p>
<p>​    printf(“consumer has read data\n”);</p>
<p>​    printf(“the shard_num is %d\n”, shard_num);</p>
<p>​    sleep(1);</p>
<p>​    sem_post(empty);</p>
<p>  }</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  full &#x3D; malloc(sizeof(sem_t));</p>
<p>  empty &#x3D; malloc(sizeof(sem_t));</p>
<p>  sem_init(empty, 0, 1);</p>
<p>  sem_init(full, 0, 0);</p>
<p>  pthread_t producer_id, consumer_id;</p>
<p>  pthread_create(&amp;producer_id, NULL, producer, NULL);</p>
<p>  pthread_create(&amp;consumer_id, NULL, consumer, NULL);</p>
<p>  pthread_join(producer_id, NULL);</p>
<p>  pthread_join(consumer_id, NULL);</p>
<p>  sem_destroy(empty);</p>
<p>  sem_destroy(full);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）代码逻辑分析</p>
<p>在上述例程中，我们定义了两个信号量：full和empty，full表示当前的缓冲区（在本例中为shared_num，实质上只能存储一个int类型的数据）是否已满，empty表示缓冲区是否已空。我们启动了一个消费者线程consumer和生产者线程producer，前者用于从缓冲区读取数据（消费），后者用于向缓冲区写入数据（生产）。</p>
<p>① 生产者的逻辑：首先等待缓冲区为空，然后写入数据，最后通过sem_post告诉消费者，缓冲区已满，可以消费数据。</p>
<p>② 消费者的逻辑：首先等待缓冲区满，然后消费数据，最后通过sem_post告诉生产者，缓冲区已空，可以生产数据。</p>
<p>需要注意的是，初始时缓冲区是空的，因此，empty信号量的初值应为1，而full应为0，二者都是用于线程间通信的，sem_init()函数的第二个参数都应该是0。</p>
<p>上述例程通过两个信号量控制生产者和消费者的执行顺序：</p>
<p>① 消费者必须在生产者发送数据后方可消费。</p>
<p>② 除首次发送外，生产者必须等待消费者读取数据后方可发送数据。</p>
<p>（3）Makefile</p>
<p>unnamed_sem_count_thread: unnamed_sem_count_thread.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（4）执行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps112.jpg" alt="img"> </p>
<p>消费者必定在生产者发送数据后才会读取，两个线程的运行顺序被严格控制。</p>
<p>（5）与二进制信号量的区别与联系</p>
<p>上述案例中，信号量的取值仍在0和1之间变动，但这并不意味着本例中的也是二进制信号量。二进制信号量和计数信号量的划分更多地是从控制效果来说的：二进制信号量起到了互斥锁的作用，当多个进程或线程访问共享资源时，确保同一时刻只有一个进程或线程进入了临界区，起到了“互斥”的作用；而计数信号量起到了“控制顺序”的作用，明确了“谁先执行”、“谁后执行”。很显然，本例是通过信号量控制了线程执行的先后顺序，属于计数信号量。</p>
<p>计数信号量和二进制信号量的划分不能只看信号量值的波动范围。</p>
<p>本例只展示了一个生产者和一个消费者在缓冲区为1时的协同工作，如果我们增加生产者和消费者的数量，信号量的取值范围自然就不再是0和1了。</p>
<p><strong>5）</strong><em><strong>*作为计数信号量用于进程间通信*</strong></em></p>
<p>（1）创建unnamed_sem_count_process.c</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *shm_name &#x3D; “unnamed_sem_shm”;</p>
<p>  &#x2F;&#x2F; 创建内存共享对象</p>
<p>  int fd &#x3D; shm_open(shm_name, O_CREAT | O_RDWR, 0666);</p>
<p>  &#x2F;&#x2F; 调整内存共享对象的大小</p>
<p>  ftruncate(fd, sizeof(sem_t));</p>
<p>  &#x2F;&#x2F; 将内存共享对象映射到共享内存区域</p>
<p>  sem_t *sem &#x3D; mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</p>
<p>  &#x2F;&#x2F; 初始化信号量</p>
<p>  sem_init(sem, 1, 0);</p>
<p>  int pid &#x3D; fork();</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    sem_wait(sem);</p>
<p>​    printf(“this is father\n”);</p>
<p>​    &#x2F;&#x2F; 父进程等待子进程退出并回收资源</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>  }</p>
<p>  else if (pid &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    sleep(1);</p>
<p>​    printf(“this is son\n”);</p>
<p>​    sem_post(sem);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 父进程执行到此处，子进程已执行完毕，可以销毁信号量</p>
<p>  &#x2F;&#x2F; 子进程执行到此处，父进程仍在等待信号量，此时销毁会导致未定义行为</p>
<p>  &#x2F;&#x2F; 只有父进程中应该销毁信号量</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (sem_destroy(sem) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“father sem_destroy”);</p>
<p>​    }</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 父子进程都应该解除映射，关闭文件描述符</p>
<p>  if (munmap(sem, sizeof(sem)) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“munmap”);</p>
<p>  }</p>
<p>  if (close(fd) &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“close”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; shm_unlink只能调用一次，只在父进程中调用</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (shm_unlink(shm_name) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“father shm_unlink”);</p>
<p>​    }</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>unnamed_sem_count_process: unnamed_sem_count_process.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p>上述案例中，我们通过计数信号量控制父进程必须在子进程之后执行。如果没有信号量，子进程先休眠1s的情况下，父进程大概率是要先于子进程执行的（取决于操作系统的调度机制和策略），通过信号量，我们确保子进程先于父进程执行。</p>
<p>执行结果如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps113.jpg" alt="img"> </p>
<h5 id="4-3-6-3-有名信号量"><a href="#4-3-6-3-有名信号量" class="headerlink" title="4.3.6.3 有名信号量"></a>4.3.6.3 <strong>有名信号量</strong></h5><p>有名信号量的名称形如&#x2F;somename，是一个以斜线（&#x2F;）打头，\0字符结尾的字符串，打头的斜线之后可以有若干字符但不能再出现斜线，长度上限为NAME_MAX-4（即251）。不同的进程可以通过相同的信号量名称访问同一个信号量。</p>
<p>有名信号量<strong>通常用于进程间通信</strong>，这是因为线程间通信可以有更高效快捷的方式（全局变量等），不必“杀鸡用牛刀”。但要注意的是，正如上文提到的，<strong>可以用于进程间通信的方式通常也可以用于线程间通信</strong>。</p>
<p>有名信号量可以用于任意进程间的通信，为了简化程序，此处以父子进程间通信为例。</p>
<p><strong>1）</strong><em><strong>*知识储备*</strong></em></p>
<p>（1）sem_open()</p>
<p>#include &lt;fcntl.h&gt;      &#x2F;* For O_* constants *&#x2F;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;     &#x2F;* For mode constants *&#x2F;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 创建或打开一个已存在的POSIX有名信号量。</p>
<p> * </p>
<p> * @param name 信号量的名称</p>
<p> * @param oflag 标记位，控制调用函数的行为。是一个或多个值或操作的结果。常用的是O_CREAT。</p>
<p> * O_CREAT: 如果信号量不存在则创建，指定了这个标记，必须提供mode和value</p>
<p> * @param mode 有名信号量在临时文件系统中对应文件的权限。需要注意的是，应确保每个需要访问当前有名信号量的进程都可以获得读写权限。</p>
<p> * @param value 信号量的初始值</p>
<p> * @return sem_t* 成功则返回创建的有名信号量的地址，失败则返回SEM_FAILED，同时设置errno以指出错误原因</p>
<p> *&#x2F;</p>
<p>sem_t *sem_open(const char *name, int oflag,</p>
<p>​    mode_t mode, unsigned int value);</p>
<p>&#x2F;**</p>
<p> * @brief 见四个参数的sem_open()</p>
<p> * </p>
<p> * @param name 同上</p>
<p> * @param oflag 同上</p>
<p> * @return sem_t* 同上</p>
<p> *&#x2F;</p>
<p>sem_t *sem_open(const char *name, int oflag);</p>
<p>（2）sem_close()</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 关闭对于sem指向的有名信号量的引用，每个打开了有名信号量的进程在结束时都应该关闭引用</p>
<p> * </p>
<p> * @param sem 有名信号量指针</p>
<p> * @return int 成功返回0，失败返回-1，并设置errno以指明错误原因</p>
<p> *&#x2F;</p>
<p>int sem_close(sem_t *sem);</p>
<p>（3）sem_unlink()</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 移除内存中的有名信号量对象，&#x2F;dev&#x2F;shm下的有名信号量文件会被清除。当没有任何进程引用该对象时才会执行清除操作。只应该执行一次。</p>
<p> * </p>
<p> * @param name 有名信号量的名称</p>
<p> * @return int 成功返回0，失败返回-1，并设置errno以指明错误原因</p>
<p> *&#x2F;</p>
<p>int sem_unlink(const char *name);</p>
<p><strong>2）</strong><em><strong>*有名信号量用作二进制信号量*</strong></em></p>
<p>（1）创建named_sem_bin.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *sem_name &#x3D; “&#x2F;named_sem”;</p>
<p>  char *shm_name &#x3D; “&#x2F;named_sem_shm”;</p>
<p>  &#x2F;&#x2F; 初始化有名信号量</p>
<p>  sem_t *sem &#x3D; sem_open(sem_name, O_CREAT, 0666, 1);</p>
<p>  &#x2F;&#x2F; 初始化内存共享对象</p>
<p>  int fd &#x3D; shm_open(shm_name, O_CREAT | O_RDWR, 0666);</p>
<p>  &#x2F;&#x2F; 调整内存共享对象的大小</p>
<p>  ftruncate(fd, sizeof(int));</p>
<p>  &#x2F;&#x2F; 将内存共享对象映射到内存空间</p>
<p>  int *value &#x3D; mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</p>
<p>  &#x2F;&#x2F; 初始化共享变量指针指向位置的值</p>
<p>  *value &#x3D; 0;</p>
<p>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &lt; 0)</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  sem_wait(sem);</p>
<p>  int tmp &#x3D; *value + 1;</p>
<p>  sleep(1);</p>
<p>  *value &#x3D; tmp;</p>
<p>  sem_post(sem);</p>
<p>  &#x2F;&#x2F; 每个进程都应该在使用完毕后关闭对信号量的连接</p>
<p>  sem_close(sem);</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>​    printf(“子进程执行结束，value &#x3D; %d\n”, *value);</p>
<p>​    &#x2F;&#x2F; 有名信号量的取消链接只能执行一次</p>
<p>​    sem_unlink(sem_name);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 父子进程都解除内存共享对象的映射，并关闭相应的文件描述符</p>
<p>  munmap(value, sizeof(int));</p>
<p>  close(fd);</p>
<p>  &#x2F;&#x2F; 只有父进程应该释放内存共享对象</p>
<p>  if (pid &gt; 0)</p>
<p>  {</p>
<p>​    if (shm_unlink(shm_name) &#x3D;&#x3D; -1)</p>
<p>​    {</p>
<p>​      perror(“shm_unlink”);</p>
<p>​    }</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>named_sem_bin: named_sem_bin.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）执行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps114.jpg" alt="img"> </p>
<p>通过信号量避免了竞态条件，确保输出的结果为2。</p>
<p><strong>3）</strong><em><strong>*有名信号量用作计数信号量*</strong></em></p>
<p>（1）创建named_sem_count.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *sem_name &#x3D; “&#x2F;named_sem”;</p>
<p>  &#x2F;&#x2F; 初始化有名信号量</p>
<p>  sem_t *sem &#x3D; sem_open(sem_name, O_CREAT, 0666, 0);</p>
<p>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &gt; 0) {</p>
<p>​    sem_wait(sem);</p>
<p>​    printf(“this is father\n”);</p>
<p>​    </p>
<p>​    &#x2F;&#x2F; 等待子进程执行完毕</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>​    </p>
<p>​    &#x2F;&#x2F; 释放引用</p>
<p>​    sem_close(sem);</p>
<p>​    &#x2F;&#x2F; 释放有名信号量</p>
<p>​    if(sem_unlink(sem_name) &#x3D;&#x3D; -1) {</p>
<p>​      perror(“sem_unlink”);</p>
<p>​    }</p>
<p>  } else if(pid &#x3D;&#x3D; 0) {</p>
<p>​    sleep(1);</p>
<p>​    printf(“this is son\n”);</p>
<p>​    sem_post(sem);</p>
<p>​    &#x2F;&#x2F; 释放引用</p>
<p>​    sem_close(sem);</p>
<p>  } else</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>named_sem_count: named_sem_count.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）执行结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps115.jpg" alt="img"> </p>
<p>通过有名信号量，确保父进程在子进程在控制台打印数据之后再打印。</p>
<p><strong>4）</strong><em><strong>*有名信号量在文件系统的表示*</strong></em></p>
<p>（1）创建named_sem_no_unlink.c，复制上述代码，注释sem_unlink操作。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;semaphore.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *sem_name &#x3D; “&#x2F;named_sem”;</p>
<p>  &#x2F;&#x2F; 初始化有名信号量</p>
<p>  sem_t *sem &#x3D; sem_open(sem_name, O_CREAT, 0666, 0);</p>
<p>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &gt; 0) {</p>
<p>​    sem_wait(sem);</p>
<p>​    printf(“this is father\n”);</p>
<p>​    </p>
<p>​    &#x2F;&#x2F; 等待子进程执行完毕</p>
<p>​    waitpid(pid, NULL, 0);</p>
<p>​    </p>
<p>​    &#x2F;&#x2F; 释放引用</p>
<p>​    sem_close(sem);</p>
<p>​    &#x2F;&#x2F; 释放有名信号量</p>
<p>​    <em>*<em>*</em>&#x2F;&#x2F; if(sem_unlink(sem_name) &#x3D;&#x3D; -1) {***</em>*</p>
<p>​    <em>*<em>*</em>&#x2F;&#x2F;   perror(“sem_unlink”);***</em>*</p>
<p>​    <em>*<em>*</em>&#x2F;&#x2F; }***</em>*</p>
<p>  } else if(pid &#x3D;&#x3D; 0) {</p>
<p>​    sleep(1);</p>
<p>​    printf(“this is son\n”);</p>
<p>​    sem_post(sem);</p>
<p>​    &#x2F;&#x2F; 释放引用</p>
<p>​    sem_close(sem);</p>
<p>  } else</p>
<p>  {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）Makefile</p>
<p>named_sem_no_unlink: named_sem_no_unlink.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）重新执行后查看&#x2F;dev&#x2F;shm目录，如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps116.jpg" alt="img"> </p>
<p>可以看到，我们创建了名为&#x2F;named_sem的信号量，将信号量名称去掉’&#x2F;‘后补充’sem.’前缀得到的字符串就是它在tmpfs中的对应文件名。</p>
<h5 id="4-3-6-4-关于信号量的总结"><a href="#4-3-6-4-关于信号量的总结" class="headerlink" title="4.3.6.4 关于信号量的总结"></a>4.3.6.4 <strong>关于信号量的总结</strong></h5><p>（1）可用于进程间通信的方式通常都可以用于线程间通信。</p>
<p>（2）无名信号量和有名信号量均可用于进程间通信，有名信号量是通过唯一的信号量名称在操作系统中唯一标识的。无名信号量用于进程间通信时必须将信号量存储在进程间可以共享的内存区域，作为内存地址直接在进程间共享。而内存区域的共享是通过内存共享对象的唯一名称来实现的。</p>
<p>（3）无名信号量和有名信号量都可以作为二进制信号量和计数信号量使用。</p>
<p>（4）二进制信号量和计数信号量的区别在于前者起到了互斥锁的作用，而后者起到了控制进程或线程执行顺序的作用。而不仅仅是信号量取值范围的差异。</p>
<p>（5）信号量是用来协调进程或线程协同工作的，本身并不用于传输数据。</p>
<p>（6）通常，从编码复杂度和效率的角度考虑，进程间通信使用有名信号量，线程间通信使用无名信号量。</p>
<p>（7）信号量用于跨进程通信时，要格外注意共享资源的创建和释放顺序，避免资源泄露或在不恰当的时机释放资源从而导致未定义行为。</p>
<p>（8）在生产环境的开发中，对于关键的步骤应当补充充分的错误处理，以便在错误发生时及时告警和响应。包括根据函数的返回值进行检查，结合使用 perror 或类似机制及时输出错误日志，以便快速排查和解决问题。此外，应确保适当释放资源以避免资源泄露。本文省略了这些步骤，这是为了使代码结构更加清晰以降低学习成本。</p>
<h3 id="4-4-线程池"><a href="#4-4-线程池" class="headerlink" title="4.4 线程池"></a>4.4 <strong>线程池</strong></h3><h4 id="4-4-1-简介"><a href="#4-4-1-简介" class="headerlink" title="4.4.1 简介"></a>4.4.1 <strong>简介</strong></h4><p>线程池是一种用于管理和重用多个线程的设计模式。它通过维护一个线程池（线程的集合），可以有效地处理并发任务而无需每次都创建和销毁线程。这种方法可以减少线程创建和销毁的开销，提高性能和资源利用率。</p>
<h4 id="4-4-2-Glib库"><a href="#4-4-2-Glib库" class="headerlink" title="4.4.2 Glib库"></a>4.4.2 <strong>G<strong><strong>l</strong></strong>ib库</strong></h4><p>官方文档链接：<a target="_blank" rel="noopener" href="https://docs.gtk.org/glib/">https://docs.gtk.org/glib/</a></p>
<p>GLib 是 GNOME 项目的一部分，是一个通用的底层库，提供数据结构、实用工具和系统相关的功能。它最初是为了 GIMP（GNU Image Manipulation Program）而开发的，但现在已经成为许多其他应用程序的基础。</p>
<h4 id="4-4-3-Glib库线程池工作流程"><a href="#4-4-3-Glib库线程池工作流程" class="headerlink" title="4.4.3 Glib库线程池工作流程"></a>4.4.3 <strong>Glib库线程池工作流程</strong></h4><p>（1）线程池创建：首先创建一个线程池，指定任务函数和其他参数。线程池会创建一定数量的线程，这些线程进入等待状态，准备执行任务，或在提交任务后才创建线程（取决于配置）。线程池中的所有任务执行的都是同一个任务函数。</p>
<p>（2）任务队列：线程池维护一个任务队列。当我们向线程池提交任务时，任务会被放入这个队列中。实际上，放入任务队列的是我们在提交任务时传递的任务数据。</p>
<p>（3）线程执行任务：线程池中的线程从任务队列中取出任务数据，然后调用任务函数，执行任务。执行完成后，线程不会退出，而是继续从任务队列中取下一个任务执行。如果没有待执行的任务，线程通常在等待一段时间后被回收（取决于具体的配置）。</p>
<h4 id="4-4-4-相关数据类型"><a href="#4-4-4-相关数据类型" class="headerlink" title="4.4.4 相关数据类型"></a>4.4.4 <strong>相关数据类型</strong></h4><p><strong>1）</strong><em><strong>*GFunc*</strong></em></p>
<p>&#x2F;&#x2F; 此处的 data 是在启动任务时，传递给每个任务的，而 user_data 是在创建线程池时传入的共享数据，对于每个任务都是一样的</p>
<p>typedef void (*GFunc)(gpointer data, gpointer user_data);</p>
<p><strong>2）</strong><em><strong>*gpointer*</strong></em></p>
<p>typedef void *gpointer;</p>
<p><strong>3）</strong><em><strong>*gint*</strong></em></p>
<p>typedef int gint;</p>
<p><strong>4）</strong><em><strong>*gboolean*</strong></em></p>
<p>typedef gint gboolean;</p>
<p>#define TRUE        1</p>
<p>#define FALSE        0</p>
<p><strong>5）</strong><em><strong>*Gerror*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 记录已发生的错误信息</p>
<p> * domain: 表示错误的域（或命名空间）。GQuark 是一个无符号整数，用于唯一标识一个字符串。它通常用来区分不同的错误类别，例如文件操作错误、网络错误等。</p>
<p> * code: 表示错误的代码。这是一个整型值，用于具体描述错误。每个域中的错误代码应该是唯一的，并且通常有一组预定义的错误代码。</p>
<p> * gchar: 表示错误消息。gchar 是 char 的别名，用于在 GLib 中统一字符类型。message 是一个字符串指针，包含了详细的错误描述信息。</p>
<p> *&#x2F;</p>
<p>struct GError {</p>
<p>  GQuark domain;</p>
<p>  gint code;</p>
<p>  gchar *message;</p>
<p>}</p>
<p><strong>6）</strong><em><strong>*GThreadPool*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 线程池对象</p>
<p> * func：线程池中执行的任务</p>
<p> * user_data：线程池中共享的用户数据指针，会在每个任务函数调用时传递给任务函数。</p>
<p> * exclusive：标记当前线程池是否独占线程</p>
<p> *&#x2F;</p>
<p>struct GThreadPool {</p>
<p>  GFunc func;</p>
<p>  gpointer user_data;</p>
<p>  gboolean exclusive;</p>
<p>}</p>
<h4 id="4-4-5-相关函数"><a href="#4-4-5-相关函数" class="headerlink" title="4.4.5 相关函数"></a>4.4.5 <strong>相关函数</strong></h4><p><strong>1）</strong><em><strong>*g_thread_pool_new*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 创建新的线程池</p>
<ul>
<li></li>
</ul>
<p> * @param func 池中线程执行的函数</p>
<p> * @param user_data 传递给func的数据，可以为NULL，这里的user_data最终会被存储在GThreadPool结构体的user_data属性中</p>
<p> * @param max_threads 线程池容量，即当前线程池中可以同时运行的线程数。-1表示没有限制</p>
<p> * @param exclusive 独占标记位。决定当前的线程池独占所有的线程还是与其它线程池共享这些线程。取值可以是TRUE或FALSE</p>
<p> *  TRUE：立即启动数量为max_threads的线程，且启动的线程只能被当前线程池使用</p>
<p> *  FALSE：只有在需要时，即需要执行任务时才创建线程，且线程可以被多个非独享资源的线程池共用</p>
<p> * @param error 用于报告错误信息，可以是NULL，表示忽略错误</p>
<p> * @return GThreadPool* 线程池实例指针。无论是否发生错误，都会返回有效的线程池</p>
<p> *&#x2F;</p>
<p>GThreadPool *g_thread_pool_new(</p>
<p>  GFunc func,</p>
<p>  gpointer user_data,</p>
<p>  gint max_threads,</p>
<p>  gboolean exclusive,</p>
<p>  GError **error);</p>
<p><strong>2）</strong><em><strong>*g_thread_pool_push*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 向pool指向的线程池实例添加数据，这一行为实际上会向任务队列添加新的任务。当存在可用线程时任务立即执行，否则任务数据会一直待在队列中，直至腾出可用线程执行任务</p>
<p> * </p>
<p> * @param pool 指向线程池实例的指针</p>
<p> * @param data 传递给每个任务的独享数据</p>
<p> * @param error 错误信息</p>
<p> * @return gboolean 成功返回TRUE，失败返回FALSE</p>
<p> *&#x2F;</p>
<p>gboolean g_thread_pool_push(</p>
<p>  GThreadPool *pool,</p>
<p>  gpointer data,</p>
<p>  GError **error);</p>
<p><strong>3）</strong><em><strong>*g_thread_pool_free*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 释放为pool指向的线程池分配的所有资源</p>
<p> * </p>
<p> * @param pool 线程池指针</p>
<p> * @param immediate 是否立即释放线程池</p>
<p> *  TRUE：立即释放所有资源，未处理的数据不被处理</p>
<p> *  FALSE：在最后一个任务执行完毕之前，线程池不会被释放</p>
<p> *  需要注意的是：执行任务时，线程池的任何一个线程都不会被打断。无论这个参数是何取值，都可以保证至少线程池释放前正在运行的线程可以完成它们的任务。</p>
<p> * @param wait_ 当前函数是否阻塞等待所有任务完成</p>
<p> *  TRUE：所有需要处理的任务执行完毕当前函数才会返回</p>
<p> *  FALSE：当前函数立即返回</p>
<p> *&#x2F;</p>
<p>void g_thread_pool_free (</p>
<p> GThreadPool* pool,</p>
<p> gboolean immediate,</p>
<p> gboolean wait_</p>
<p>);</p>
<h4 id="4-4-6-测试例程"><a href="#4-4-6-测试例程" class="headerlink" title="4.4.6 测试例程"></a>4.4.6 <strong>测试例程</strong></h4><p><strong>1）</strong><em><strong>*创建*</strong></em><em><strong>*thread_pool_test.c*</strong></em></p>
<p>#include &lt;glib.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>&#x2F;&#x2F; 任务函数</p>
<p>void task_func(gpointer data, gpointer user_data) {</p>
<p>  int task_num &#x3D; <em>(int</em>)data;</p>
<p>  free(data);</p>
<p>  printf(“Executing task is %d…\n”, task_num);</p>
<p>  sleep(1);</p>
<p>  printf(“Task %d completed\n”, task_num);</p>
<p>}</p>
<p>int main() {</p>
<p>  &#x2F;&#x2F; 创建线程池</p>
<p>  GThreadPool *thread_pool &#x3D; g_thread_pool_new(task_func, NULL, 5, TRUE, NULL);</p>
<p>  &#x2F;&#x2F; 向线程池添加任务</p>
<p>  for (int i &#x3D; 0; i &lt; 10; i++) {</p>
<p>​    int *tmp &#x3D; malloc(sizeof(int));</p>
<p>​    *tmp &#x3D; i + 1;</p>
<p>​    g_thread_pool_push(thread_pool, tmp, NULL);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 等待所有任务完成</p>
<p>  g_thread_pool_free(thread_pool, FALSE, TRUE);</p>
<p>  printf(“All tasks completed\n”);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>thread_pool_test: thread_pool_test.c</p>
<p>  -$(CC) -o $@ $^ <code>pkg-config --cflags --libs glib-2.0</code></p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（1）标志</p>
<p>在编译和链接过程中，标志（Flags）是传递给编译器和链接器的参数，它们指示编译器和链接器如何处理源代码和目标代码。</p>
<p>Ø 编译标志（Compiler Flags）</p>
<p>编译标志用于告诉编译器如何处理源代码。这些标志包括头文件的搜索路径、预处理器宏定义等。-I&#x2F;usr&#x2F;include&#x2F;glib-2.0就是一个编译标志，-I是gcc编译时的一个参数，用于指定头文件的搜索路径。</p>
<p>Ø 链接标志（Linker Flags）</p>
<p>链接标志用于告诉链接器如何处理目标文件和库文件。这些标志包括库文件的搜索路径和库文件名等。-lglib-2.0是一个链接标志，-l参数在第一章已有介绍，这个标志表示链接libglib-2.0.so库。</p>
<p>（2）pkg-config</p>
<p>Ø pkg-config是一个用于从已安装库中检索编译器和链接器标志的工具。它帮助开发者轻松地获取用于编译和链接程序所需的库信息。</p>
<p>Ø –cflags：打印编译包时所需的预处理器和编译器标志。示例如下</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install libglib2.0-dev</p>
<p>atguigu@ubuntu:~&#x2F;thread_test$ pkg-config –cflags glib-2.0<br>-I&#x2F;usr&#x2F;include&#x2F;glib-2.0 -I&#x2F;usr&#x2F;<strong>lib</strong>&#x2F;<strong>x86_64</strong>-<strong>linux</strong>-<strong>gnu</strong>&#x2F;<strong>glib</strong>-2.0&#x2F;<strong>include</strong></p>
<p>返回了预处理器需要的标志，用于指明额外的头文件搜索路径。</p>
<p>Ø –libs：用于打印链接器所需的标志。示例如下</p>
<p>atguigu@ubuntu:~&#x2F;thread_test$ pkg-config –libs glib-2.0<br>-lglib-2.0</p>
<p>返回了链接器需要的标志，用于指明所需的动态链接库。表示链接libglib-2.0.so库。</p>
<p>Ø pkg-config –cflags –libs glib-2.0实际上是pkg-config –cflags glib-2.0和pkg-config –libs glib-2.0的整合，二者是等价的，如下。</p>
<p>atguigu@ubuntu:~&#x2F;thread_test$ pkg-config –cflags –libs glib-2.0<br>-I&#x2F;usr&#x2F;include&#x2F;glib-2.0 -I&#x2F;usr&#x2F;<strong>lib</strong>&#x2F;<strong>x86_64</strong>-<strong>linux</strong>-<strong>gnu</strong>&#x2F;<strong>glib</strong>-2.0&#x2F;<strong>include</strong> -<strong>lglib</strong>-2.0</p>
<p>（3）Shell中的飘号或反引号（&#96;）</p>
<p><code>cmd</code>的作用是执行命令（cmd），将命令的标准输出作为变量或其他命令的参数。</p>
<p>  -$(CC) -o $@ $^ <code>pkg-config --cflags --libs glib-2.0</code></p>
<p>等价于</p>
<p>  -$(CC) -o $@ $^ -I&#x2F;usr&#x2F;include&#x2F;glib-2.0 -I&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;glib-2.0&#x2F;include -lglib-2.0</p>
<p>实际上是通过pkg-config命令帮助我们指明了编译Glib所需的额外的头文件搜索路径和需要链接动态链接库。</p>
<p><strong>3）</strong><em><strong>*运行*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps117.jpg" alt="img"> </p>
<h1 id="第-5-章-进程和线程"><a href="#第-5-章-进程和线程" class="headerlink" title="第 5 章 进程和线程"></a>第 5 章 <strong>进程和线程</strong></h1><p>在&#x2F;home&#x2F;atguigu目录下创建process_thread_theory目录，本章的所有测试例程都置于该目录下。</p>
<h3 id="5-1-计算机系统的软件分层"><a href="#5-1-计算机系统的软件分层" class="headerlink" title="5.1 计算机系统的软件分层"></a>5.1 <strong>计算机系统的软件分层</strong></h3><p><strong>1）</strong><em><strong>*软件分层*</strong></em></p>
<p>在单片机学习中我们使用代码直接与硬件交互，对于这种方式的缺点深有体会：</p>
<p>（1）复杂度高，调用难度高，需要深入理解硬件的工作原理和细节。</p>
<p>（2）细节繁琐，特别是在处理底层寄存器和端口配置时，极易出错。</p>
<p>（3）出错时调试难度也很高，因为涉及到底层硬件的交互，定位问题相对困难。</p>
<p>（4）更换芯片时，往往需要重写驱动，导致代码的可移植性很差，增加了开发和维护的成本。</p>
<p>为了解决这些问题，操作系统应运而生。后者在硬件之上做了一层抽象，提供了统一的接口和服务，隐藏了硬件的复杂性和差异性，从而简化了程序对硬件资源的访问和管理，使得开发者能够更加专注于应用逻辑的实现，而不必深入到复杂的硬件操作细节中。因此，它为上层应用程序提供了一个统一、稳定、高效的运行环境，极大地提升了软件开发的效率和可靠性。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps118.png" alt="img"></p>
<p><strong>2）</strong><em><strong>*内核*</strong></em></p>
<p>内核是操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、存储设备和其他外围设备。内核提供系统服务的基础，如进程管理、内存管理、设备驱动、文件系统和网络通信等。</p>
<p>内核作为硬件和应用程序之间的中介，提供一个抽象层，使得应用程序不需要直接与硬件交互。</p>
<p><strong>3）</strong><em><strong>*应用程序*</strong></em></p>
<p>应用程序是运行在操作系统之上的软件，用于执行特定的任务，如文本编辑、图像处理、网络通信等。</p>
<p>应用程序提供用户所需的功能，依赖于操作系统提供的接口与硬件资源进行交互。</p>
<h3 id="5-2-进程和程序"><a href="#5-2-进程和程序" class="headerlink" title="5.2 进程和程序"></a>5.2 <strong>进程和程序</strong></h3><p>程序是存储在硬盘等存储介质的代码，是一串二进制机器码，是静态的。</p>
<p>进程是正在运行的程序及相关资源的总称，是一种抽象，是动态的。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps119.png" alt="img"></p>
<h3 id="5-3-进程控制块PCB"><a href="#5-3-进程控制块PCB" class="headerlink" title="5.3 进程控制块PCB"></a>5.3 <strong>进程控制块PCB</strong></h3><p>内核会保存每个进程的一些信息，称为进程控制块（Process Control Block，PCB），方便管理进程，内容如下：</p>
<p>（1）进程编号（PID），每个进程对应的唯一编号，一般为正整数形式。</p>
<p>（2）进程状态信息。</p>
<p>（3）进程切换时需要保存和恢复的一些CPU寄存器，其中关键的有程序计数器（Program Counter）的值，用于记录进程恢复时应执行的指令地址。</p>
<p>（4）内存管理信息，如<strong>页表</strong>、内存限制、段表等。</p>
<p>（5）当前工作目录（Current Working Directory）。</p>
<p>（6）进程调度信息，包括进程优先级、调度队列指针等。</p>
<p>（7）I&#x2F;O状态信息，包括分配给进程的I&#x2F;O设备列表，<strong>打开的****文件描述符表</strong>等，后者包含很多指向file结构体的指针。</p>
<p>（8）同步和通信信息，包括信号量、信号、等用于进程同步和通信机制的信息。</p>
<p>（9）用户id和组id。</p>
<p>在Linux内核中，进程控制块的实现是struct task_struct，上述信息都存储在这个结构体中。</p>
<h3 id="5-4-进程的内存模型"><a href="#5-4-进程的内存模型" class="headerlink" title="5.4 进程的内存模型"></a>5.4 <strong>进程的内存模型</strong></h3><h4 id="5-4-1-内存模型"><a href="#5-4-1-内存模型" class="headerlink" title="5.4.1 内存模型"></a>5.4.1 <strong>内存模型</strong></h4><p>一个进程在内存中的布局如下所示：</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps120.png" alt="img"></p>
<h4 id="5-4-2-相关概念"><a href="#5-4-2-相关概念" class="headerlink" title="5.4.2 相关概念"></a>5.4.2 <strong>相关概念</strong></h4><p><strong>1）</strong><em><strong>*栈帧*</strong></em></p>
<p>（1）栈</p>
<p>栈（Stack）是个FILO（First In Last Out）即先进后出类型的数据结构，在进程的内存模型中有一块区域作为用户栈，最先进入的数据位于栈底，最后进入的数据位于栈顶。</p>
<p>（2）栈帧</p>
<p>栈帧（Stack Frame）是程序在调用函数时用于存储函数调用和局部变量的一块内存。每次函数调用时，都会在调用者的栈上创建一个新的栈帧。这个栈帧包含了函数的返回地址、参数、局部变量以及保存的必要的寄存器值。</p>
<p>每个栈帧对应于一个函数调用的上下文，它是程序运行时栈内存组织的基本单元。栈帧允许函数调用彼此隔离，同时支持递归调用和嵌套调用。</p>
<p>调用函数时，会在栈顶为函数分配一帧，然后移动栈指针，指向新的栈顶，称为压栈。函数调用结束（返回）时，会释放函数的栈帧，称为弹栈。</p>
<p>（3）栈指针</p>
<p>专用寄存器——栈指针（Stack Pointer，SP）用于记录栈顶位置。</p>
<p>（4）帧指针</p>
<p>专用寄存器——帧指针（Frame Pointer，FP，有些架构中也叫Base Pointer，BP）用于记录调用者栈帧的位置。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps121.png" alt="img"></p>
<p><strong>2）</strong><em><strong>*内核空间*</strong></em></p>
<p>内核空间是进程虚拟内存中保留给操作系统内核的部分，用于存放内核代码和数据。这部分空间对用户程序是不可见、不可直接访问的。内核空间具有最高的访问权限，只有内核态下的代码可以执行这里的操作。</p>
<p>所有进程的内核空间是共享的。</p>
<p><strong>3）</strong><em><strong>*用户空间*</strong></em></p>
<p>用户空间是内存中分配给用户程序的部分，与内核空间相隔离。用户程序和库函数在这里执行。用户空间的代码运行在用户态，拥有较低的权限，不能直接执行特权操作或访问内核空间。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps122.png" alt="img"></p>
<h3 id="5-5-进程的状态"><a href="#5-5-进程的状态" class="headerlink" title="5.5 进程的状态"></a>5.5 <strong>进程的状态</strong></h3><h4 id="5-5-1-CPU虚拟化"><a href="#5-5-1-CPU虚拟化" class="headerlink" title="5.5.1 CPU虚拟化"></a>5.5.1 <strong>CPU虚拟化</strong></h4><p>理论上，同一时刻单核CPU只能运行一个进程，但很多时候，我们可以同时运行的程序数量远大于CPU的核心数。这是因为，操作系统的CPU调度单元对CPU的资源做了时间分片，即在时间尺度上对CPU做了划分，如15:15到15:16执行进程A，15:16到15:17执行进程B。实际上进程间的切换是非常迅速的，在用户的角度，就好像多个进程在同一时间运行。因此，看起来好像计算机可以同时运行的进程数远大于CPU核心数。</p>
<p>进程的切换是由操作系统的CPU调度器完成的。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps123.png" alt="img"></p>
<h4 id="5-5-2-CPU调度"><a href="#5-5-2-CPU调度" class="headerlink" title="5.5.2 CPU调度"></a>5.5.2 <strong>CPU调度</strong></h4><p><strong>1）</strong><em><strong>*调度和调度器*</strong></em></p>
<p>在上面的场景中，进程执行到某一时刻，被内核中断，然后内核可以重新开始之前被中断的进程，这种决策就是调度（Scheduling），是由内核中称为调度器（Scheduler）的代码处理的。当内核选择一个新的进程时，我们说内核调度了这个进程。</p>
<p><strong>2）</strong><em><strong>*题外话*</strong></em></p>
<p>实际上，进程的调度是通过时钟中断实现的。设想一下，如果没有中断，当用户进程执行死循环时，CPU会被一直占用，内核是无法夺回控制权的。通过设置时钟中断，每隔一段时间，内核就可以收回CPU的控制权，决定接下来哪个进程可以占用CPU（运行），从而实现进程的调度。</p>
<h4 id="5-5-3-抽象的进程状态模型"><a href="#5-5-3-抽象的进程状态模型" class="headerlink" title="5.5.3 抽象的进程状态模型"></a>5.5.3 <strong>抽象的进程状态模型</strong></h4><p>进程状态是指一个进程在其生命周期中所处的不同阶段或状况。一些权威的操作系统教材对进程状态的抽象模型做了如下介绍： </p>
<p><strong>1）</strong><em><strong>*初始态（Initial）*</strong></em></p>
<p>这是进程生命周期的开始阶段，进程被创建时处于初始态，或者叫创建态。在这个阶段，操作系统为新进程分配资源。</p>
<p><strong>2）</strong><em><strong>*就绪态（Ready）*</strong></em></p>
<p>就绪态意味着进程已准备好运行，但由于CPU调度算法或其他正在运行的进程，它当前没有运行。</p>
<p><strong>3）</strong><em><strong>*运行态（Running）*</strong></em></p>
<p>当进程正在CPU上执行时，它处于运行态。</p>
<p><strong>4）</strong><em><strong>*阻塞态（Blocked）*</strong></em></p>
<p>进程由于等待某个事件（如IO操作完成）而无法继续执行时，它就处于阻塞态。</p>
<p><strong>5）</strong><em><strong>*终止态（Final）*</strong></em></p>
<p>进程执行完毕，并释放其占用的所有资源，进行必要的清理工作。此时，虽然进程已结束了所有活动，但操作系统内核仍保留它的PCB，进程处于终止态。通常，终止态持续时间非常短暂，PCB很快会被内核释放。</p>
<p><strong>6）</strong><em><strong>*僵尸态（Zombie）*</strong></em></p>
<p>僵尸态与终止态非常相似，区别是，如果进程结束了所有工作后PCB长期未被释放，它就处于僵尸态。在进程状态机中，我们对终止态和僵尸态不作区分，因为二者都是进程任务执行完毕之后的状态，意味着进程生命周期的终止。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps124.png" alt="img"></p>
<p><strong>7）</strong><em><strong>*注意*</strong></em></p>
<p>初始态非常短暂，通常是看不到的。终止态和僵尸态实际上都是进程执行完毕之后的状态，严格意义上讲，并不属于进程运行时状态。因此，部分操作系统资料在介绍进程状态时不会在进程转换状态机中包含。下图是《操作系统导论》中的进程转换状态机。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps125.jpg" alt="img"> </p>
<h4 id="5-5-4-Linux进程状态实现"><a href="#5-5-4-Linux进程状态实现" class="headerlink" title="5.5.4 Linux进程状态实现"></a>5.5.4 <strong>Linux进程状态实现</strong></h4><p>（1）D： 不可中断睡眠状态（通常是在进行IO操作）</p>
<p>（2）I： 空闲的内核线程</p>
<p>（3）R： 运行或可运行状态（在运行队列中）</p>
<p>（4）S： 可中断睡眠状态（等待事件完成）</p>
<p>（5）T： 由工作控制信号停止</p>
<p>（6）t： 在跟踪过程中由调试器停止</p>
<p>（7）W： 分页（从2.6.xx内核版本开始就不再有效）</p>
<p>（8）X： 死亡状态（永远不应该被看到），PCB已被清理</p>
<p>（9）Z： 僵尸进程，已经终止但尚未被父进程回收</p>
<h4 id="5-5-5-二者的统一"><a href="#5-5-5-二者的统一" class="headerlink" title="5.5.5 二者的统一"></a>5.5.5 <strong>二者的统一</strong></h4><table>
<thead>
<tr>
<th><em><strong>*抽象理论*</strong></em></th>
<th><em><strong>*L*</strong></em><em><strong>*i*</strong></em><em><strong>*nux实现*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*初始态*</strong></em></td>
<td>这个阶段通常很短暂，不对应于Linux的特定进程状态。</td>
</tr>
<tr>
<td><em><strong>*就绪态*</strong></em></td>
<td>对应于R</td>
</tr>
<tr>
<td><em><strong>*运行态*</strong></em></td>
<td>对应于R</td>
</tr>
<tr>
<td><em><strong>*阻塞态*</strong></em></td>
<td>D、S、T、t均属于阻塞态</td>
</tr>
<tr>
<td><em><strong>*僵尸态*</strong></em></td>
<td>Z</td>
</tr>
</tbody></table>
<p>内核线程执行内核级任务，不属于用户线程。</p>
<p>X表示PCB已被清理，不应被看到。</p>
<h4 id="5-5-6-调度队列"><a href="#5-5-6-调度队列" class="headerlink" title="5.5.6 调度队列"></a>5.5.6 <strong>调度队列</strong></h4><p>Linux的进程PCB底层数据结构是task_struct，操作系统调度器将task_struct实例组织到不同的队列，以支持调度器的决策。这些队列基于进程状态区分，常见的如就绪、等待、终止队列等。</p>
<p><strong>1）</strong><em><strong>*就绪队列*</strong></em></p>
<p>存放处于就绪态的进程。</p>
<p><strong>2）</strong><em><strong>*等待队列*</strong></em></p>
<p>存放处于阻塞态的进程。</p>
<p><strong>3）</strong><em><strong>*终止队列*</strong></em></p>
<p>存放处于终止态或僵尸态，等待被回收的进程。</p>
<h3 id="5-6-虚拟内存和物理内存"><a href="#5-6-虚拟内存和物理内存" class="headerlink" title="5.6 虚拟内存和物理内存"></a>5.6 <strong>虚拟内存和物理内存</strong></h3><h4 id="5-6-1-案例"><a href="#5-6-1-案例" class="headerlink" title="5.6.1 案例"></a>5.6.1 <strong>案例</strong></h4><p><strong>1）</strong><em><strong>*创建virtual_memory_test.c*</strong></em></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main() {</p>
<p>  int val &#x3D; 123;</p>
<p>  &#x2F;&#x2F; 定义变量接收子进程PID</p>
<p>  __pid_t pid;</p>
<p>  &#x2F;&#x2F; 创建一个子进程</p>
<p>  if ((pid &#x3D; fork()) &gt; 0 ){</p>
<p>​    sleep(1);</p>
<p>​    printf(“父进程中val 的内容是: %d\nval 所在的地址是: %p\n”, val, &amp;val);</p>
<p>  } else if (pid &#x3D;&#x3D; 0) {</p>
<p>​    val &#x3D; 321;</p>
<p>​    printf(“子进程中val 的内容是: %d\nval 所在的地址是: %p\n”, val, &amp;val);</p>
<p>  } else {</p>
<p>​    printf(“子进程创建失败\n”);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>我们通过fork创建了一个子进程，子进程会继承父进程的资源，包括val变量。</p>
<p><strong>2）</strong><em><strong>*创建Makefile*</strong></em></p>
<p>CC:&#x3D;gcc</p>
<p>virtual_memory_test: virtual_memory_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>3）</strong><em><strong>*运行结果如下*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps126.jpg" alt="img"> </p>
<p>父子进程中各自打印了val变量的值和内存地址。子进程将val变量更改为321，我们特意让父进程休眠了一秒，确保子进程的更改先于父进程的输出。我们发现子进程修改了val变量的值，而父进程的val未受影响，说明两个进程的val变量是完全独立的。但是，二者的内存地址却完全相同。既然内存地址是相同的，父子进程中的val变量不就应该是同一个吗？但子进程修改了自己的val，父进程的val却未受影响，从这个角度看，二者又是完全独立的变量？这不是矛盾了吗？</p>
<p>要明白这个问题，我们需要了解操作系统的虚拟内存机制。</p>
<h4 id="5-6-2-虚拟内存映射"><a href="#5-6-2-虚拟内存映射" class="headerlink" title="5.6.2 虚拟内存映射"></a>5.6.2 <strong>虚拟内存映射</strong></h4><p><strong>1）</strong><em><strong>*知识储备*</strong></em></p>
<p>（1）虚拟内存</p>
<p>虚拟内存是计算机系统内存管理的一种技术，它为每个进程提供了一种“虚拟”的地址空间，这个地址空间对于每个程序来说看起来都是连续的，但实际上可能被分散地存储在物理内存和磁盘上（如交换空间或页面文件）。虚拟内存允许系统超额分配内存，即分配的内存总量可以超过物理内存的实际容量。虚拟内存简化了内存的管理，使得应用程序不需要关心物理内存的实际情况。</p>
<p>（2）物理内存</p>
<p>物理内存指的是计算机中安装的实际RAM（随机访问存储器）模块。它是系统用来存储正在运行的程序和数据的硬件资源。</p>
<p>物理内存直接影响到计算机能够同时处理的信息量。更多的物理内存意味着可以同时运行更多的程序，或者处理更大的数据集。</p>
<p>（3）MMU</p>
<p>进程可以直接操作的只有虚拟内存，那么，虚拟内存毕竟是“虚拟”的，进程的代码段、数据、栈等最终一定要存储到真正的物理内存，那么，我们就要建立虚拟内存和物理内存之间的映射关系。在操作系统中，这件事是由MMU来完成的。</p>
<p>MMU（Memory Management Unit）是CPU的一个组成部分，负责处理虚拟地址到物理地址的转换。当程序试图访问一个虚拟内存地址时，MMU会查询页表来找到对应的物理内存地址，然后完成内存访问。MMU还负责检查访问权限，确保程序不会访问未授权的内存区域。</p>
<p>此外，当所请求的虚拟地址没有映射到物理地址或虚拟页对应的数据位于磁盘的交换空间中时，即产生缺页故障，MMU会通知操作系统，由操作系统来处理这种情况，为虚拟页分配页帧，或将数据从硬盘加载到内存的一个页帧中，然后更新页表以建立新的映射关系。完成这些操作后，当程序再次尝试访问原来的虚拟地址时，可以正确地访问到映射后的物理页帧中的数据 。</p>
<p>MMU本身是硬件组件，操作系统负责配置和管理MMU使用的数据结构（如页表），以及处理MMU生成的各种内存管理相关的异常（如缺页故障）。这种协作机制允许操作系统利用MMU提供的硬件支持，实现虚拟内存、内存保护和其他高级内存管理功能。</p>
<p>（4）页</p>
<p>在操作系统的上下文中，“页”（Page）是虚拟内存管理中的一个基本单位，通常大小为4KB或2MB等，具体大小依赖于处理器和操作系统的设计。操作系统使用页来实现虚拟内存。</p>
<p>（5）页帧</p>
<p>页帧（Page Frame），也称为物理页（Physical Page），是物理内存中的一个固定大小的区块。在虚拟内存系统中，物理内存被划分为许多这样大小相等的页帧，以便于内存的管理和映射。</p>
<p>（6）页表</p>
<p>页表是操作系统用于管理虚拟内存系统中的虚拟地址到物理地址映射的数据结构。页表包含页表项（Page Table Entries, PTEs），每个PTE对应一个页，包含该页映射到的页帧的物理地址及访问该页的权限和状态（如是否在物理内存中，是否可写等）。在x86-64架构下，页表大小为4K。</p>
<p>（7）TLB</p>
<p>TLB全称为Translation-Lookaside Buffer，即地址转换旁路缓存。是MMU中一个组成部分，是硬件为提升虚拟内存到物理内存地址映射的效率而提供的硬件支持。</p>
<p>（8）多级页表</p>
<p>在32位系统中，每个进程的虚拟内存地址空间为4GB，假设页大小为4KB，则一个进程的虚拟地址空间要分为1M页，假定每个PTE的大小为4字节，每个进程就需要占用4MB的空间来存储页表，启动100个进程，仅页表就要占用400MB的内存空间。而很少有进程会用到所有的虚拟页，这样无疑会带来巨大的内存浪费。</p>
<p>为了解决这个问题，引入了多级页表。此处不做展开。多级页表中，除最后一级外，都可以叫做页目录（Page Directory）。</p>
<p><strong>2）</strong><em><strong>*虚拟内存映射*</strong></em></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps127.png" alt="img"></p>
<h4 id="5-6-3-再看进程共享存储"><a href="#5-6-3-再看进程共享存储" class="headerlink" title="5.6.3 再看进程共享存储"></a>5.6.3 <strong>再看进程共享存储</strong></h4><p>有了知识储备，我们再回头来看进程共享内存映射的实现，这一过程分为两个步骤。</p>
<p>（1）通过shm_open创建内存共享对象，这一步实际上是内核创建了一个匿名文件，它不与文件系统的具体文件直接关联，只是存在于内核的一个对象。内存共享对象是通过文件名来唯一标识的。</p>
<p>（2）通过mmap()将进程的虚拟内存映射到上一步的共享对象。当多个进程映射到相同的共享对象时，内核会根据后者的文件名确定这一点，并将多个进程的虚拟内存映射到相同的物理内存，这样就实现了进程间内存共享。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps128.png" alt="img"></p>
<h3 id="5-7-异常和中断"><a href="#5-7-异常和中断" class="headerlink" title="5.7 异常和中断"></a>5.7 <strong>异常和中断</strong></h3><h4 id="5-7-1-相关概念"><a href="#5-7-1-相关概念" class="headerlink" title="5.7.1 相关概念"></a>5.7.1 <strong>相关概念</strong></h4><p><strong>1）</strong><em><strong>*内核态和用户态*</strong></em></p>
<p>（1）内核态</p>
<p>内核态是CPU的一种运行模式，具有执行所有指令和访问所有硬件资源的权限。在这种模式下，操作系统内核执行其核心功能。所有与硬件交互的操作都必须在内核态下执行。</p>
<p>由于具有完全的系统控制权，任何在内核态执行的代码都必须是高度可靠的，以避免系统崩溃或安全漏洞。</p>
<p>（2）用户态</p>
<p>用户态是CPU的另一种运行模式，权限受限。应用程序在用户态下运行，不能直接执行特权指令或访问受保护的内存区域。</p>
<p>用户态为应用程序提供了一个安全的执行环境，通过系统调用请求操作系统提供的服务。</p>
<p>（3）特权指令</p>
<p>特权指令是指只有在内核态下才可以执行的指令。这些指令提供了对硬件和关键系统资源的直接控制能力，因此它们的执行被严格限制在操作系统内核中，以防止恶意软件或错误的程序代码破坏系统的稳定性和安全性。</p>
<p><strong>只有在内核态下才可以执行特权指令。</strong></p>
<p><strong>2）</strong><em><strong>*中断和异常的分类*</strong></em></p>
<table>
<thead>
<tr>
<th><em><strong>*大类*</strong></em></th>
<th><em><strong>*子类*</strong></em></th>
<th><em><strong>*原因*</strong></em></th>
<th><em><strong>*异步&#x2F;同步*</strong></em></th>
<th><em><strong>*返回行为*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*中断（Interrupt）*</strong></em></td>
<td>中断</td>
<td>来自硬件的信号</td>
<td>异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td><em><strong>*异常（Exception）*</strong></em></td>
<td>陷阱</td>
<td>进程主动触发的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
<td></td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
<td></td>
</tr>
</tbody></table>
<p>（1）中断</p>
<p>中断（Interrupt）通常是I&#x2F;O设备或时钟触发的，信号来自处理器外部，不是由任何一条指令造成的，从这个角度讲，它是异步的。中断处理完毕后总是执行下一条指令。</p>
<p>（2）异常</p>
<p>异常是（Exception）CPU执行指令时检测到特定条件触发的。x86-64架构定义了三种异常：陷入（Trap）、故障（Fault）和终止（Abort）。</p>
<p>① 陷入</p>
<p>是由进程执行陷入指令（可以切换到内核态的指令）主动触发的，是同步的，执行完毕后总是执行下一条指令。</p>
<p>② 故障</p>
<p>故障由错误情况引起，可能被故障处理程序修正，如上文提到的缺页故障就是故障的一种。故障发生时，处理器将控制权交由故障处理程序，如果故障被修复，则返回引起故障的指令，并重新执行。否则，处理程序返回到内核中的abort例程，后者终止引起故障的进程。</p>
<p>③ 终止</p>
<p>终止是不可恢复的致命错误造成的结果。如底层硬件错误，或者进程产生的算数异常，无法被修复。终止发生时，CPU将控制权交由终止处理程序，这个程序不会将CPU的控制权返还给应用程序，而是返回到内核中的abort例程，后者终止进程。</p>
<p><strong>3）</strong><em><strong>*中断和异常的区别*</strong></em></p>
<p>在x86-64架构中，中断和异常区别在于：中断处理例程被调用时，CPU会清除EFLAGS寄存器中的IF（Interrupt Enable）位，避免其它中断干扰当前中断处理例程的执行。而异常处理例程被调用时IF不会被清除。</p>
<p><strong>4）</strong><em><strong>*中断描述符表（Interrupt Descriptor Table）*</strong></em></p>
<p>操作系统为每种中断或异常都分配了唯一的中断向量（Vector），它是一个非负整数。一部分中断向量是由CPU的设计者分配的（如被零除、缺页、内存访问违例即算术运算溢出等），另一部分中断向量是由操作系统内核的设计者分配的（包括系统调用和来自外部I&#x2F;O设备的信号）。</p>
<p>操作系统启动时，内核会分配和初始化一张称为<strong>中断描述符表（Interrupt</strong> <strong>Descriptor</strong> <strong>Table</strong> <strong>IDT****）</strong>的跳转表，将中断向量和中断或异常处理程序映射。IDT中的每一项（entry）对应一种中断或异常。</p>
<p><strong>中断描述符表寄存器（****Interrupt</strong> <strong>Descriptor</strong> <strong>Table</strong> <strong>Register</strong> <strong>IDTR）</strong>指明了IDT的基地址和边界。</p>
<h4 id="5-7-2-中断和异常处理"><a href="#5-7-2-中断和异常处理" class="headerlink" title="5.7.2 中断和异常处理"></a>5.7.2 <strong>中断和异常处理</strong></h4><p>CPU以相同的方式处理中断和异常。当中断或异常发生的时候，CPU暂停当前程序或任务的执行，通过IDTR定位IDT，通过中断号检索IDT，确定中断或异常处理例程的入口。CPU切换到中断或异常处理例程，执行完毕后，回到被中断的程序或任务。</p>
<p><strong>1）</strong><em><strong>*段寄存器*</strong></em></p>
<p>x86-64架构中，段寄存器（CS、DS、SS、ES、FS和GS）是16位的段选择器。</p>
<p>现代Linux系统内存管理的方式是分页，早期的操作系统曾经通过分段管理内存，与分页不同，分段是将内存空间切分为几个大段，内存模型中的每个部分占据一块。x86-64架构的Linux使用的也是分页，保留段寄存器，一方面是为了向前兼容，另一方面是用于存储一些关键的系统状态信息（如特权级信息）。</p>
<p><strong>2）</strong><em><strong>*TSS*</strong></em></p>
<p>任务状态段（Task State Segment TSS）是x86-64架构中用于支持任务切换和状态管理的数据结构，在早期的操作系统设计中，它被用于实现硬件级的任务切换功能，但在现代操作系统中，主要用于管理内核栈的切换。</p>
<p><strong>3）</strong><em><strong>*内核栈*</strong></em></p>
<p>在x86-64架构下，对于每个线程维护一个内核栈，这些内核栈的大小为2页，即8K。内核栈存储在内核空间。</p>
<p>内核栈用于在中断或异常处理和CPU调度切换线程时保存当前正在执行的进程的状态，并在内核线程的工作中发挥作用。</p>
<p>当线程在用户空间执行时，内核栈中只有thread_info对象。</p>
<p><strong>4）</strong><em><strong>*中断或异常处理程序的调用流程*</strong></em></p>
<p>（1）临时存储当前CPU寄存器SS，RSP（栈指针）、RFLAGS（状态寄存器）、CS、RIP（程序计数器）等寄存器的值。</p>
<p>（2）从TSS加载段选择器的信息和栈指针到SS和ESP寄存器，切换到内核栈，并为中断或异常处理例程开辟栈帧，此时切换至内核态。</p>
<p>（3）将第一步临时存储的寄存器值压入内核栈。</p>
<p>（4）将error code压入内核栈。</p>
<p>① error code是硬件层面由CPU自动处理和生成的，与特定的中断或异常关联，错误码包含了导致中断或异常的具体原因。</p>
<p>② 而在讲解perror()时用到的errno是C标准库提供的全局变量。二者是不同的。</p>
<p>（5）更新程序计数器，指向中断或异常处理例程。</p>
<p>（6）如果是中断处理例程，清除RFLAGS寄存器中的IF标志位。</p>
<p>（7）在内核态下开始执行中断或异常处理例程。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps129.png" alt="img"></p>
<p><strong>5）</strong><em><strong>*中断或异常处理程序的返回*</strong></em></p>
<p>中断或异常处理程序的返回是通过执行IRET指令开始的。要注意，如果触发的是终止（Abort），则不会返回用户进程。</p>
<p>（1）执行权限检查。这一步是为了确保接下来的操作在内核态下进行。</p>
<p>（2）恢复CS和RIP寄存器的值。</p>
<p>（3）恢复RFLAGS寄存器的值。</p>
<p>（4）恢复SS和RSP寄存器的值，内核栈中异常处理程序的栈帧弹栈。栈指针重新指向进程用户空间中的用户栈，由内核态切换到用户态。</p>
<p>（5）在用户态下继续执行被中断的程序。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps130.png" alt="img"></p>
<p><strong>6）</strong><em><strong>*中断上文*</strong></em></p>
<p>中断上文是指在异常发生之前，处理器的状态。即中断处理时最先压入内核栈的数据，包括段选择器的值、栈指针、程序计数器、状态相关寄存器等的值。</p>
<p><strong>7）</strong><em><strong>*中断下文*</strong></em></p>
<p>中断下文是指涉及中断或异常处理时内核所处的环境和状态，包括内核栈中保存的用户线程状态、状态寄存器、段选择器和内核栈指针等寄存器、内核态下执行的中断或异常处理函数等内容。</p>
<h4 id="5-7-3-案例"><a href="#5-7-3-案例" class="headerlink" title="5.7.3 案例"></a>5.7.3 <strong>案例</strong></h4><p><strong>1）</strong><em><strong>*页表基地址*</strong></em></p>
<p>页表负责虚拟地址到物理地址的映射。地址转换首先要找到页表所在的地址。x86-64架构实现了四级页表，一级页表的地址存储在CR3寄存器，这个寄存器的值会被记录在PCB中，在进程切换时会被保存和更新。MMU可以访问CR3定位一级页表，然后逐级检索，完成地址转换。</p>
<p><strong>2）</strong><em><strong>*缺页故障*</strong></em></p>
<p>执行用户代码时，进程工作在用户态，进程访问虚拟内存，MMU首先查询TLB，若TLB命中则将虚拟地址转换为物理地址，对这块地址执行操作。若TLB未命中则会访问CR3寄存器定位一级页表，多级检索定位页帧，最终将虚拟地址转换为物理地址，继续后续操作。</p>
<p>如果查询操作的虚拟内存页尚未映射到物理页帧，则MMU无法在页表中查到相应的PTE，此时会触发缺页故障（Page Fault），操作系统会介入，为虚拟页分配页帧，而后回到触发故障的指令继续执行。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps131.png" alt="img"></p>
<h3 id="5-8-进程创建过程"><a href="#5-8-进程创建过程" class="headerlink" title="5.8 进程创建过程"></a>5.8 <strong>进程创建过程</strong></h3><h4 id="5-8-1-进程"><a href="#5-8-1-进程" class="headerlink" title="5.8.1 进程"></a>5.8.1 <strong>进程</strong></h4><p>进程是操作系统中的一个基本概念，代表了操作系统中正在运行的一个程序的实例。进程不仅包括代码本身，还包括运行该程序所需的各种资源，如虚拟内存空间、文件描述符、环境变量等。每个进程都有一个独立的虚拟地址空间，这意味着一个进程无法直接访问另一个进程的内存。</p>
<p>当一个新进程被创建时，操作系统会为其分配一个唯一的进程标识符（PID）和一个新的虚拟地址空间。随后，操作系统会加载程序代码到虚拟内存中，并设置初始的堆栈和寄存器，包括程序计数器（PC）和栈指针（SP）。通过fork创建的子进程将继承父进程的资源副本，包括打开的文件描述符和环境变量。</p>
<h4 id="5-8-2-进程创建"><a href="#5-8-2-进程创建" class="headerlink" title="5.8.2 进程创建"></a>5.8.2 <strong>进程创建</strong></h4><p>上文讲解进程树时，我们通过ps -ef看到的信息可以分为两类：进程信息和内核线程的信息，进程工作在用户态，执行用户程序，内核线程工作在内核态，执行内核任务。内核启动时会创建1号进程和2号内核线程，通常1号进程名为systemd，2号内核线程名为kthreadd，其它进程全部由systemd及其子进程通过fork()+execve()的方式创建，其它内核线程都是由kthreadd及其创建的内核线程通过kthread_create()这样的方式创建的。fork()和kthread_create()是通过创建系统调用clone()实现的，这里不做展开。</p>
<p>上文已经介绍了fork()和execve()的用法，接下来我们将了解进程创建时，操作系统内核做了什么事。</p>
<p><strong>1）</strong><em><strong>*task_struct*</strong></em></p>
<p>上文已多次提及，在Linux中，进程PCB的实现是struct task_struct类型的实例，该结构体定义在&#x2F;usr&#x2F;src&#x2F;linux-hwe-6.5-headers-6.5.0-28&#x2F;include&#x2F;linux&#x2F;sched.h文件中，主要字段入下。</p>
<p>struct task_struct {</p>
<p>  struct thread_info thread_info; &#x2F;&#x2F; 执行环境的必要信息</p>
<p>  ……</p>
<p>  void *stack; &#x2F;&#x2F; 内核栈</p>
<p>  ……</p>
<p>  unsigned int flags; &#x2F;&#x2F; 标志位信息</p>
<p>  ……</p>
<p>  &#x2F;* Filesystem information: *&#x2F;</p>
<p>  struct fs_struct *fs; &#x2F;&#x2F; 文件系统信息</p>
<p>  ……</p>
<p>  struct mm_struct *mm; &#x2F;&#x2F; 内存管理信息（包含指向内存区描述符的指针</p>
<p>  ……</p>
<p>  &#x2F;* Open file information: *&#x2F;</p>
<p>  struct files_struct *files; &#x2F;&#x2F; 包含指向打开的文件描述符表的指针</p>
<p>  ……</p>
<p>  pid_t pid; &#x2F;&#x2F; 进程ID</p>
<p>  pid_t tgid; &#x2F;&#x2F; 线程组ID</p>
<p>  &#x2F;* Objective and real subjective task credentials (COW): *&#x2F;</p>
<p>  const struct cred __rcu *real_cred; &#x2F;&#x2F; 真正的证书，包含用户和用户组的信息</p>
<p>  &#x2F;* Effective (overridable) subjective task credentials (COW): *&#x2F;</p>
<p>  const struct cred __rcu *cred; &#x2F;&#x2F; 当前有效的证书</p>
<p>  ……</p>
<p>  &#x2F;* Signal handlers: *&#x2F;</p>
<p>  struct signal_struct *signal; &#x2F;&#x2F; 与信号处理相关的信息，关注信号状态管理</p>
<p>  struct sighand_struct __rcu *sighand; &#x2F;&#x2F; 与信号处理函数相关的信息</p>
<p>};</p>
<p><strong>2）</strong><em><strong>*fork()*</strong></em></p>
<p>fork()主要完成了以下工作：</p>
<p>（1）为子进程创建内核栈、thread_info实例。</p>
<p>（2）复制父进程的task_struct，后者包含了内核栈、虚拟内存管理信息、打开的文件描述符表等的指针，此时子进程只是复制了这些资源的引用。</p>
<p>（3）清除子进程的统计信息，更新子进程task_struct的标志位。</p>
<p>（4）为子进程分配新的PID，将子进程的PPID设置为调用fork()的进程。</p>
<p>（5）清除与fork()返回值相关的寄存器，使得子进程中fork()返回的是0。</p>
<p>（6）复制打开的文件描述符表，这一过程底层被指向的struct file实例中引用计数加一。复制文件系统信息、复制地址空间（页表相关信息），复制信号处理信息。</p>
<p>（7）最后，如果子进程成功创建则被唤醒，处于就绪态。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps132.png" alt="img"></p>
<p><strong>3）</strong><em><strong>*COW*</strong></em></p>
<p>写时复制机制（Copy on Write COW）可以提高进程创建效率。子进程完整地复制了父进程的地址空间，此时父子进程的虚拟内存空间映射到相同的物理内存空间。只有当二者之一执行了写入操作才会复制写入区域的内容，为父子进程维护不同的物理页帧。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps133.png" alt="img"></p>
<p><strong>4）</strong><em><strong>*execve()*</strong></em></p>
<p>（1）参数和环境准备</p>
<p>内核检查传递给execve()的参数，包括可执行文件的路径、环境变量和命令行参数，以确保它们的有效性和安全性。这个阶段内核会在内核空间中准备一份新程序需要的命令行参数和环境变量的备份。</p>
<p>（2）打开和验证可执行文件</p>
<p>打开指定的二进制文件，验证其格式是否支持（例如，ELF格式），并检查执行权限。如果这一步找不到可执行文件的路径，就会直接终止。</p>
<p>下面的例子中，可执行文件路径有误导致execve()失败。</p>
<p>① 创建execve_invalid_path.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *argv[] &#x3D; {“ping”, “-c”, “10”, “baidu.com”, NULL};</p>
<p>  &#x2F;&#x2F; 环境变量可以不传</p>
<p>  char *envp[] &#x3D; {NULL};</p>
<p>  int re &#x3D; execve(argv[0], argv, envp);</p>
<p>  if (re &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“execve”);</p>
<p>​    return -1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>execve_invalid_path: execve_invalid_path.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 测试结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps134.jpg" alt="img"> </p>
<p>这里的问题是没有指明ping的路径，导致execve执行时找不到可执行文件。在内核尝试打开可执行文件的环节被终止了。</p>
<p>将ping替换为&#x2F;usr&#x2F;bin&#x2F;ping即可。</p>
<p>④ 创建execve_full_path.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  char *argv[] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;ping”, “-c”, “10”, “baidu.com”, NULL};</p>
<p>  &#x2F;&#x2F; 环境变量可以不传</p>
<p>  char *envp[] &#x3D; {NULL};</p>
<p>  int re &#x3D; execve(argv[0], argv, envp);</p>
<p>  if (re &#x3D;&#x3D; -1)</p>
<p>  {</p>
<p>​    perror(“execve”);</p>
<p>​    return -1;</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>⑤ Makefile</p>
<p>execve_full_path: execve_full_path.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>⑥ 结果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps135.jpg" alt="img"> </p>
<p>（3）创建新的内存映射</p>
<p>清除进程当前的内存映射，包括用户空间中的代码、数据、堆和栈。</p>
<p>根据新的程序建立新的代码段、数据段、堆和栈等。</p>
<p>需要注意的是，内存映射不包含内核空间，内核空间的映射是由操作系统内核管理的，对所有进程是共享的。execve切换的只是用户空间。</p>
<p>（4）复制参数和环境变量</p>
<p>在新的地址空间中为命令行参数和环境变量分配空间，并将内核中它们的备份复制到新的位置。</p>
<p>（5）初始化进程上下文</p>
<p>设置新的程序计数器、栈指针等，以便新程序可以正确执行。</p>
<p>清理和重设进程的各种内核资源，如文件描述符表。根据文件描述符的 close-on-exec 标志（FD_CLOEXEC）进行处理，如果有该标志，则文件描述符被关闭。</p>
<p>（6）更新 task_struct 和其他内核结构</p>
<p>更新 task_struct 中关于进程地址空间、堆栈、命令行参数、环境变量的指针。</p>
<p>重置信号控制信息到默认状态。</p>
<p>清理进程的各种内核状态，如未处理的信号、定时器等。</p>
<p>（7）执行新程序</p>
<p>跳转到新加载程序的入口点开始执行。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps136.png" alt="img"></p>
<h4 id="5-8-3-ps命令"><a href="#5-8-3-ps命令" class="headerlink" title="5.8.3 ps命令"></a>5.8.3 <strong>ps命令</strong></h4><p>上文我们通过ps -ef查看当前的进程信息，看不到进程组ID，通过以下命令查看进程组ID。</p>
<p>atguigu@ubuntu:~$ ps -eo uid,pid,pgid,ppid,cmd</p>
<p>Ø -e：选择所有进程</p>
<p>Ø -o：用户自定义输出格式，该选项后可以跟一个以逗号分隔的格式化字符串，指明要打印的字段信息，上述命令的字段信息如下。</p>
<p>Ø uid：User ID，用户ID</p>
<p>Ø pid：Process ID，进程ID</p>
<p>Ø pgid：Process Group ID，进程组ID</p>
<p>Ø ppid：Parent Process ID，父进程ID</p>
<p>Ø cmd：Command，进程启动命令。</p>
<p>命令行输出如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps137.jpg" alt="img"> </p>
<h4 id="5-8-4-进程组"><a href="#5-8-4-进程组" class="headerlink" title="5.8.4 进程组"></a>5.8.4 <strong>进程组</strong></h4><p>进程组ID（Process Group ID，简称PGID）在UNIX和类UNIX系统（如Linux）中用来标识一个或多个进程的集合。进程组用于信号传递和终端控制（如作业控制）。在很多方面，进程组的概念是为了更好地支持在终端中运行的交互式作业。</p>
<p>（1）会话（Session）</p>
<p>会话是一个或多个进程组的集合。通常，当用户登录到系统时，登录shell会成为一个新会话的领导。这个新会话会创建一个新的进程组，该组包含shell进程及其子进程。</p>
<p>（2）进程所属的进程组</p>
<p>① 一个进程的所属的进程组可能是自己，也可能是它的父进程，默认情况下，应该是它的父进程。但是在某些场景下如创建新的会话或终端时，进程所属的进程组可能是自己。在VSCode中运行main()函数启动一个进程，如下。</p>
<p>创建process_group_block_test.c</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  while(1);</p>
<p>  return 0;</p>
<p>}</p>
<p>Makefile</p>
<p>process_group_block_test: process_group_block_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>启动后，通过以下命令查看进程组ID。</p>
<p>atguigu@ubuntu:~$ ps -eo uid,pid,pgid,ppid,cmd</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps138.jpg" alt="img"> </p>
<p>此时，进程组ID是main进程自己的PID。</p>
<p>② 更改程序，在main函数中创建子进程。</p>
<p>创建process_group_father_son_test.c</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  pid_t son_pid &#x3D; fork();</p>
<p>  if (son_pid &gt; 0) {</p>
<p>​    waitpid(son_pid, NULL, 0);</p>
<p>  } else if (son_pid &#x3D;&#x3D; 0) {</p>
<p>​    char *str &#x3D; malloc(100);</p>
<p>​    fgets(str, 100, stdin);</p>
<p>​    printf(“收到子进程数据: %s\n”, str);</p>
<p>​    free(str);</p>
<p>​    str &#x3D; NULL;</p>
<p>  } else {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>Makefile</p>
<p>process_group_father_son_test: process_group_father_son_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>启动后，查看进程信息。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps139.jpg" alt="img"> </p>
<p>两个进程同属于一个进程组。通过fork()创建的子进程属于父进程创建的进程组，父进程是该组的组长。</p>
<p>③ 通过setpgid()将PID设置为各自的PGID，两个进程各自创建一个进程组。</p>
<p>创建process_group_two_group.c</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>  pid_t son_pid &#x3D; fork();</p>
<p>  setpgid(getpid(), getpid());</p>
<p>  if (son_pid &gt; 0) {</p>
<p>​    waitpid(son_pid, NULL, 0);</p>
<p>  } else if (son_pid &#x3D;&#x3D; 0) {</p>
<p>​    char *str &#x3D; malloc(100);</p>
<p>​    fgets(str, 100, stdin);</p>
<p>​    printf(“收到子进程数据: %s\n”, str);</p>
<p>​    free(str);</p>
<p>​    str &#x3D; NULL;</p>
<p>  } else {</p>
<p>​    perror(“fork”);</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p>Makefile</p>
<p>process_group_two_group: process_group_two_group.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>运行查看进程</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps140.jpg" alt="img"> </p>
<p>两个进程各自创建了一个进程组，进程组ID等于各自的进程ID。</p>
<p>（3）进程组领导</p>
<p>每个进程组都有一个进程组组长，其进程ID（PID）与进程组ID（PGID）相同。进程组组长是最先创建的进程，但它退出并不意味着进程组的消失。只要进程组中还有其他进程，该进程组就会继续存在。</p>
<p>（4）信号传递</p>
<p>可以向一个进程组中的所有进程发送信号，而不是单独向每个进程发送。</p>
<h3 id="5-9-进程切换过程"><a href="#5-9-进程切换过程" class="headerlink" title="5.9 进程切换过程"></a>5.9 <strong>进程切换过程</strong></h3><h4 id="5-9-1-进程切换"><a href="#5-9-1-进程切换" class="headerlink" title="5.9.1 进程切换"></a>5.9.1 <strong>进程切换</strong></h4><p><strong>1）</strong><em><strong>*进程切换的场景*</strong></em></p>
<p>如果进程的运行不会被打断，那么操作系统内核想要回CPU的控制权就只能寄希望于进程主动归还，或者强制重启计算机。现代计算机提供了中断和异常机制，二者都可以打断正在执行的进程，将CPU的控制权交还给内核。进程的切换需要内核介入，必然要通过中断或异常来实现。进程切换主要在以下几种情况下发生。</p>
<p>（1）时钟中断触发，被中断的进程获得的CPU时间片耗尽，操作系统决定切换进程。</p>
<p>（2）当前进程发生故障，内核夺回CPU控制权，如果故障无法被修复，则内核终止该进程，切换至其它进程。</p>
<p>（3）时钟中断触发，当前进程在等待IO操作，为避免资源浪费，切换至其他进程。</p>
<p>（4）时钟中断触发，高优先级进程处于就绪状态，内核将CPU使用权由当前进程转交给高优先级进程。</p>
<p><strong>2）</strong><em><strong>*进程切换过程*</strong></em></p>
<p>进程的切换需要借助中断或异常，流程如下。假设正在运行的进程A要被切换到进程B。</p>
<p>（1）CPU暂存栈指针、程序计数器、段选择器和状态寄存器的值。</p>
<p>（2）栈指针由进程A的用户栈切换至它的内核栈，操作系统切换至内核态。</p>
<p>（3）CPU将第一步暂存的寄存器值压入内核栈。</p>
<p>（4）将错误码压入内核栈。</p>
<p>（5）程序计数器指向中断或异常处理程序。</p>
<p>（6）操作系统执行中断或异常处理程序。</p>
<p>（7）在中断或异常处理程序中，调度器会判断是否满足进程切换条件，如果满足则执行以下操作：</p>
<p>① 将进程A所有相关寄存器的值保存至进程A的PCB（Linux底层实现为struct task_struct）。这会包含它的页表基址。</p>
<p>② 有些架构会清除TLB。</p>
<p>③ 将进程B的PCB中记录的页表基址、栈指针等寄存器信息加载（恢复）到对应寄存器。此时栈指针指向进程B的内核栈。进程A回到调度队列。如果进程A是因为CPU时间片耗尽，则处于就绪状态，回到就绪队列。</p>
<p>要注意，打开的文件描述符表等相关资源的切换不需要通过寄存器实现，这些资源存储在struct task_struct结构体中，调度器可以从调度队列获得task_struct，完成资源切换。</p>
<p>（8）执行权限检查，判断当前是否处于内核态。</p>
<p>（9）从进程B的内核栈恢复CS和程序计数器，后者指向B的用户进程代码。</p>
<p>（10）恢复进程B的状态寄存器RFLAGS。</p>
<p>（11）从进程B的内核栈恢复SS和栈指针，后者指向进程B的用户栈，此时切换到用户态。</p>
<p>（12）在用户态下继续进程B的执行，进程切换完成。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps141.png" alt="img"></p>
<h4 id="5-9-2-进程上下文"><a href="#5-9-2-进程上下文" class="headerlink" title="5.9.2 进程上下文"></a>5.9.2 <strong>进程上下文</strong></h4><p><strong>1）</strong><em><strong>*进程上文*</strong></em></p>
<p>进程上文是指进程被挂起时其执行状态的集合，这使得进程能够在未来某个时间点继续执行。它包括进程的程序计数器、栈指针等寄存器状态，进程的内核栈和用户栈的信息、内存映射信息（如页表条目），打开的文件描述符表等。</p>
<p><strong>2）</strong><em><strong>*进程下文*</strong></em></p>
<p>进程下文是指将要被加载和执行的挂起进程的执行状态集合。包括将要被执行的进程的程序计数器、栈指针等寄存器状态，进程的内核栈和用户栈的信息、内存映射信息（如页表条目），打开的文件描述符表等。</p>
<h3 id="5-10-系统调用和库函数"><a href="#5-10-系统调用和库函数" class="headerlink" title="5.10 系统调用和库函数"></a>5.10 <strong>系统调用和库函数</strong></h3><p>（1）系统调用</p>
<p>系统调用是操作系统提供的服务接口，允许用户空间的应用程序请求操作系统执行特定的功能，这些功能通常涉及到资源管理、文件操作、进程控制等更深层次的系统任务。系统调用是操作系统内核功能的直接接口。</p>
<p>用户在程序中执行系统调用，CPU会执行陷入指令，切换到内核态，执行相应的异常处理程序，实现用户进程对于内核功能的调用。</p>
<p>系统调用运行在内核态，具有访问硬件和管理系统资源的权限。涉及用户态到内核态的切换，执行开销较大。</p>
<p>（2）库函数</p>
<p>库函数通常是用高级语言编写，库函数存储在函数库中，最常见的是C标准函数库。</p>
<p>在使用标准输入输出的时候，我们都需要引入一个头文件：stdio.h，这个头文件是C标准库的IO接口的声明。</p>
<p>C标准函数库(C Standard Library，简称libc)是一个由ANSI C标准定义的函数库集合，它为C语言程序员提供了一组标准化的程序接口，这些接口实现了基础的程序功能，如输入输出处理、字符串操作、数学计算等。这个库是C语言标准的一部分，所有遵循标准的C语言实现都必须提供这个库的功能。</p>
<p>在现代Linux发行版中，使用最多的libc实现为GNU C函数库，简称glibc，它是C标准库的一个实现，它是自由软件基金会（Free Software Foundation, FSF）GNU项目的一部分。glibc为C语言提供了标准库所要求的所有功能，并且还包括了一些扩展功能和优化，以支持GNU&#x2F;Linux系统和其他类UNIX系统。</p>
<p>我们可以用下面的命令查看自己系统的glibc版本：</p>
<p>atguigu@ubuntu:~ $ &#x2F;<strong>lib</strong>&#x2F;<strong>x86-64_64</strong>-<strong>linux</strong>-<strong>gnu</strong>&#x2F;<strong>libc</strong>.<strong>so</strong>.6</p>
<p>命令反馈如下：</p>
<p>GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.6) stable release version 2.35.</p>
<p>Copyright (C) 2022 Free Software Foundation, Inc.</p>
<p>This <strong>is</strong> free software; see the source <strong>for</strong> copying conditions.</p>
<p>There <strong>is</strong> NO warranty; <strong>not</strong> even <strong>for</strong> MERCHANTABILITY <strong>or</strong> FITNESS FOR A</p>
<p>PARTICULAR PURPOSE.</p>
<p>Compiled by GNU CC version 11.4.0.</p>
<p>libc ABIs: UNIQUE IFUNC ABSOLUTE</p>
<p>For bug reporting instructions, please see:</p>
<p><a target="_blank" rel="noopener" href="https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs">https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs</a>.</p>
<p>可以看到我们的Linux中使用的glibc版本为2.35。</p>
<p>库函数运行在用户态，不涉及用户态和内核态的切换，执行开销较小。许多库函数在内部使用系统调用实现其功能。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps142.png" alt="img"></p>
<h3 id="5-11-进程和线程"><a href="#5-11-进程和线程" class="headerlink" title="5.11 进程和线程"></a>5.11 <strong>进程和线程</strong></h3><h4 id="5-11-1-线程"><a href="#5-11-1-线程" class="headerlink" title="5.11.1 线程"></a>5.11.1 <strong>线程</strong></h4><p>（1）概念</p>
<p>线程是进程中的执行单元，它共享进程的资源和地址空间，但拥有自己的执行堆栈、程序计数器和一组寄存器。由于线程共享相同进程内的资源，它们之间的通信和数据共享相对容易。在很多类Unix系统中，线程被称为轻量级的进程，创建和上下文切换的开销小于进程。</p>
<p>（2）Shell中查看线程</p>
<p>执行以下命令。</p>
<p>atguigu@ubuntu:~$ ps -eo uid,lwp,tid,tgid,pid,pgid,ppid,cmd</p>
<p>出现了几个新的字段名。</p>
<p>Ø lwp：Low Weight Process ID，轻量级线程ID，Linux中等同于线程ID。</p>
<p>Ø tid：Thread ID，线程ID。</p>
<p>Ø tgid：Thread Group ID，线程组ID。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps143.jpg" alt="img"> </p>
<p>对于只有一个线程的进程，它的线程ID等于进程ID。对于拥有多个线程的进程，主线程的线程ID等于进程ID，主线程是该进程的第一个线程，是创建其它线程的线程。</p>
<h4 id="5-11-2-线程和进程的区别与联系"><a href="#5-11-2-线程和进程的区别与联系" class="headerlink" title="5.11.2 线程和进程的区别与联系"></a>5.11.2 <strong>线程和进程的区别与联系</strong></h4><p>在Linux中，线程等同于轻量级进程，二者都有独立的task_struct结构体实例。线程创建和进程创建在技术上是完全等同的，fork()和进程创建函数pthread_create()底层都调用了系统调用clone()。</p>
<p><strong>1）</strong><em><strong>*创建进程*</strong></em></p>
<p>当我们调用fork()时，等同于调用clone(SIGCHLD, 0)，SIGCHLD标志的作用是告诉操作系统：当子进程终止时，父进程应当接收到SIGCHLD信号。这个信号是默认的方式，用于通知父进程其子进程已经结束。这样一来，父进程就可以在子进程退出后执行清理操作。</p>
<p><strong>2）</strong><em><strong>*创建线程*</strong></em></p>
<p>创建线程时，底层会调用clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)，这些Flag的含义如下。</p>
<p>Ø CLONE_VM：共享地址空间。从技术上将，被创建的线程和创建者的struct task_struct实例中struct mm_struct指针类型的字段mm和active_mm指向相同的实例。</p>
<p>Ø CLONE_FS：共享文件系统信息。从技术上将，被创建的线程和创建者的struct task_struct实例中struct fs_struct指针类型的字段fs指向相同的实例。</p>
<p>Ø CLONE_FILES：共享打开的文件描述符表，从技术上讲，被创建的线程和创建者的struct task_struct实例中struct files_struct指针类型的字段files指向相同的实例。</p>
<p>Ø CLONE_SIGHAND：共享信号处理函数表。从技术上讲，被创建的线程和创建者的struct task_struct实例中struct signal_struct指针类型的字段和struct sighand_struct指针类型的字段指向相同的实例。</p>
<p><strong>3）</strong><em><strong>*进程创建和线程创建的区别*</strong></em></p>
<p>从clone()系统调用的角度，我们可以得出结论：如果多个进程共享了地址空间、文件系统信息、打开的文件信息、信号处理信息，那么他们就是同属于一个进程的线程。</p>
<p>task_struct结构体中的pid实际上表示的是进程或线程ID，tgid字段表示的是线程组ID，等同于传统意义上的线程ID。对于单线程的进程，pid字段和tgid字段相同。对于多线程进程，主线程的pid等于tgid，pid此时可以理解为主线程的线程ID或者进程ID，普通线程的tgid等于主线程的pid和tgid，即当前线程所属的线程组ID和进程ID，而pid字段此时相当于线程ID。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps144.png" alt="img"></p>
<h4 id="5-11-3-线程的特点"><a href="#5-11-3-线程的特点" class="headerlink" title="5.11.3 线程的特点"></a>5.11.3 <strong>线程的特点</strong></h4><p><strong>1）</strong><em><strong>*资源共享*</strong></em></p>
<p>线程之间共享进程资源，包括地址空间、文件系统信息、打开的文件描述符和信号处理函数，而不同进程之间的资源是隔离的。</p>
<p><strong>2）</strong><em><strong>*通信*</strong></em></p>
<p>线程间的通信通常比进程间的通信（例如，通过管道、共享内存）更为高效。因为地址空间是共享的，线程间可以直接通过如全局变量这样的方式通信。</p>
<p><strong>3）</strong><em><strong>*创建和管理开销*</strong></em></p>
<p>线程的创建和上下文切换通常比进程更轻量级，因此在需要频繁创建和销毁执行单元的场景中，线程可能是更合适的选择。</p>
<p>5.11.4 <strong>线程组</strong></p>
<p>在操作系统中，线程组（Thread Group）是一种将多个线程组织在一起的机制，使得它们可以作为一个单元进行管理和操作。Linux中，同一进程的所有线程同属于一个线程组。线程组ID（Thread Group ID，TGID）用于标识一个线程组，它等于进程号，等于主线程（该进程的第一个线程，创建其它线程的线程）的线程ID（TID）。</p>
<p>5.11.5 <strong>内核线程</strong></p>
<p>上文我们不止一次提到了内核线程。Linux的内核线程是在内核空间中运行的轻量级进程，它们没有独立的地址空间和大部分用户空间资源。内核线程是操作系统内核功能的一部分，主要用于管理和执行内核级任务，如硬件中断处理、系统调用服务、内存管理等。</p>
<p><strong>1）</strong><em><strong>*内核栈*</strong></em></p>
<p>内核线程拥有自己的内核栈。</p>
<p><strong>2）</strong><em><strong>*控制内核线程的数据结构*</strong></em></p>
<p>内核线程的信息也存储在task_struct结构体中。</p>
<p><strong>3）</strong><em><strong>*地址空间*</strong></em></p>
<p>不同于普通进程，struct mm_struct类型的字段mm及active_mm取值为NULL，它们通常共享内核的全局地址空间。</p>
<p><strong>4）</strong><em><strong>*标记字段*</strong></em></p>
<p>内核线程的task_struct中flags字段被标记为PF_KTHREAD，用于表示这是一个内核线程。</p>
<p><strong>5）</strong><em><strong>*内核线程的ID*</strong></em></p>
<p>内核线程工作在内核态，相互之间地位是等同的，因此，任意内核线程的TID、TGID、PID都是相同的。并且，所有内核线程的PGID都是0。这是因为内核线程不与任何特定的终端相关联，也不参与普通的作业控制和信号处理，这些通常是用户空间进程的特性。PGID设置为0是设计上的选择，用于确保内核线程在操作系统中的特殊性和隔离性。</p>
<p>通过以下命令查看。</p>
<p>atguigu@ubuntu:~$ ps -eo uid,tid,tgid,pid,pgid,ppid,cmd</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps145.jpg" alt="img"> </p>
<p><strong>6）</strong><em><strong>*打开的文件描述*</strong></em></p>
<p>此外，内核进程不需要执行I&#x2F;O操作或者直接操作文件描述符，因此，不需要文件描述符表，它的task_struct中，指向struct files_struct实例的字段为NULL。</p>
<p><strong>7）</strong><em><strong>*文件系统信息*</strong></em></p>
<p>同样地，指向struct fs_struct实例的字段也通常是NULL。fs_struct用于管理文件系统相关的信息。内核线程不与特定的文件系统路径交互，所以不需要此信息。</p>
<p><strong>8）</strong><em><strong>*信号处理信息*</strong></em></p>
<p>struct signal_struct和struct sighand_struct实例主要用于处理用户级信号，因此，内核线程的task_struct实例中，指向它们的指针也通常为NULL。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps146.png" alt="img"></p>
<h1 id="第-6-章-Socket-编程"><a href="#第-6-章-Socket-编程" class="headerlink" title="第 6 章 Socket****编程"></a>第 6 章 <strong>Socket****编程</strong></h1><p>在&#x2F;home&#x2F;atguigu下创建socket_test目录，本章的所有测试例程均置于该目录下。</p>
<h3 id="6-1-计算机网络的分类"><a href="#6-1-计算机网络的分类" class="headerlink" title="6.1 计算机网络的分类"></a>6.1 <strong>计算机网络的分类</strong></h3><h4 id="6-1-1-按地理范围分类"><a href="#6-1-1-按地理范围分类" class="headerlink" title="6.1.1 按地理范围分类"></a>6.1.1 <strong>按地理范围分类</strong></h4><p><strong>1）</strong><em><strong>*个人区域网（PAN） - Personal Area Network*</strong></em></p>
<p>（1）范围：通常是几米到十几米。</p>
<p>（2）用途：连接个人设备，如手机、平板、笔记本电脑、智能手表等。</p>
<p>（3）示例：蓝牙（Bluetooth）、红外线通信（Infrared Communication）。</p>
<p><strong>2）</strong><em><strong>*局域网（LAN） - Local Area Network*</strong></em></p>
<p>（1）范围：通常覆盖一个建筑物、办公室或校园。</p>
<p>（2）用途：在小范围内实现高速数据传输和资源共享。</p>
<p>（3）示例：以太网（Ethernet）、Wi-Fi（Wireless Fidelity）。</p>
<p><strong>3）</strong><em><strong>*城域网（MAN） - Metropolitan Area Network*</strong></em></p>
<p>（1）范围：覆盖一个城市或多个相邻的城市。</p>
<p>（2）用途：连接多个局域网，提供城域范围内的数据传输服务。</p>
<p>（3）示例：光纤网络（Fiber Optic Network）、有线电视和DSL（Digital Subscriber Line）连接。</p>
<p><strong>4）</strong><em><strong>*广域网（WAN） - Wide Area Network*</strong></em></p>
<p>（1）范围：覆盖国家、洲际甚至全球范围。</p>
<p>（2）用途：连接多个局域网和城域网，实现长距离数据传输。</p>
<p>（3）示例：互联网（Internet）、企业专用网（Enterprise Private Network）。</p>
<h4 id="6-1-2-按网络拓扑分类"><a href="#6-1-2-按网络拓扑分类" class="headerlink" title="6.1.2 按网络拓扑分类"></a>6.1.2 <strong>按网络拓扑分类</strong></h4><p><strong>1）</strong><em><strong>*总线型拓扑（Bus Topology）*</strong></em></p>
<p>所有设备共享一条通信介质（总线）。</p>
<p>（1）优点：布线简单，成本低。</p>
<p>（2）缺点：总线故障会导致整个网络瘫痪。</p>
<p><strong>2）</strong><em><strong>*星型拓扑（Star Topology）*</strong></em></p>
<p>所有设备通过单独的通信链路连接到一个中央节点（如交换机）。</p>
<p>（1）优点：易于管理和扩展，单个设备故障不会影响整个网络。</p>
<p>（2）缺点：中央节点故障会导致整个网络瘫痪。</p>
<p><strong>3）</strong><em><strong>*环型拓扑（Ring Topology）*</strong></em></p>
<p>每个设备连接到两个相邻设备，形成一个环。</p>
<p>（1）优点：数据传输延迟低，适合实时通信。</p>
<p>（2）缺点：任何一个节点或链路故障都会影响整个网络。</p>
<p><strong>4）</strong><em><strong>*网状拓扑（Mesh Topology）*</strong></em></p>
<p>每个设备都有多个连接点，与多个其他设备直接相连。</p>
<p>（1）优点：高度冗余，可靠性强，任意节点或链路故障不影响整体通信。</p>
<p>（2）缺点：布线复杂，成本高。</p>
<h4 id="6-1-3-按网络用途分类"><a href="#6-1-3-按网络用途分类" class="headerlink" title="6.1.3 按网络用途分类"></a>6.1.3 <strong>按网络用途分类</strong></h4><p><strong>1）</strong><em><strong>*互联网（Internet）*</strong></em></p>
<p>全球范围内连接各种网络的集合。</p>
<p>用途：提供全球范围的通信和信息共享。</p>
<p><strong>2）</strong><em><strong>*企业内部网（Intranet）*</strong></em></p>
<p>仅限于企业或组织内部使用的网络。</p>
<p>用途：提供内部资源共享和通信。</p>
<p><strong>3）</strong><em><strong>*外联网（Extranet）*</strong></em></p>
<p>连接企业内部网与外部合作伙伴或客户的网络。</p>
<p>用途：在安全受控的环境下，与外部实体进行通信和协作。</p>
<h4 id="6-1-4-按网络的交换技术分类"><a href="#6-1-4-按网络的交换技术分类" class="headerlink" title="6.1.4 按网络的交换技术分类"></a>6.1.4 <strong>按网络的交换技术分类</strong></h4><p><strong>1）</strong><em><strong>*电路交换网络（Circuit-Switched Network）*</strong></em></p>
<p>通信路径在传输前建立，并在通信期间保持不变。</p>
<p>示例：传统电话网络（Traditional Telephone Network）。</p>
<p><strong>2）</strong><em><strong>*分组交换网络（Packet-Switched Network）*</strong></em></p>
<p>数据分成小包（分组）传输，每个分组可以通过不同的路径到达目的地。</p>
<p>示例：互联网（Internet）。</p>
<p><strong>3）</strong><em><strong>*报文交换网络（Message-Switched Network）*</strong></em></p>
<p>整个消息作为一个单元传输，通过节点存储并转发。</p>
<p>示例：早期的电报网络（Early Telegraph Networks）。</p>
<h4 id="6-1-5-按网络的通信方式分类"><a href="#6-1-5-按网络的通信方式分类" class="headerlink" title="6.1.5 按网络的通信方式分类"></a>6.1.5 <strong>按网络的通信方式分类</strong></h4><p><strong>1）</strong><em><strong>*广播网络（Broadcast Network）*</strong></em></p>
<p>一个节点发送的数据包可以被网络中所有节点接收到。</p>
<p>示例：以太网（Ethernet）、Wi-Fi（Wireless Fidelity）。</p>
<p><strong>2）</strong><em><strong>*点对点网络（Point-to-Point Network）*</strong></em></p>
<p>数据包从一个节点直接发送到目标节点。</p>
<p>示例：点对点协议（PPP - Point-to-Point Protocol）、专用线路（Leased Line）。</p>
<h3 id="6-2-计算机网络分层模型"><a href="#6-2-计算机网络分层模型" class="headerlink" title="6.2 计算机网络分层模型"></a>6.2 <strong>计算机网络分层模型</strong></h3><h4 id="6-2-1-相关概念"><a href="#6-2-1-相关概念" class="headerlink" title="6.2.1 相关概念"></a>6.2.1 <strong>相关概念</strong></h4><p>计算机网络分层模型是网络通信的基础框架，它将复杂的网络通信过程划分为若干层次，每一层都执行特定的功能，并为上一层提供服务。这种分层的目的是简化网络设计，确保不同网络技术之间的兼容性和互操作性。与分层模型相关的概念包括分层、实体、协议、接口和服务。</p>
<p><strong>1）</strong><em><strong>*分层（*</strong></em><em><strong>*Layer*</strong></em><em><strong>*）*</strong></em></p>
<p>分层是将网络通信过程划分为多个层次的过程。每一层关注网络通信的一个特定方面，比如物理传输、数据链路、网络路由、传输可靠性等。最著名的分层模型是OSI（开放系统互连）模型，它包含七层，以及TCP&#x2F;IP模型，通常被认为包含四层。前者是学术和法律上的国际标准，后者是事实上的国际标准，即现实生活中被广泛遵循的分层模型。</p>
<p><strong>2）</strong><em><strong>*实体（Entity）*</strong></em></p>
<p>在分层模型中，每一层都有实体，这些实体指的是执行特定层次功能的硬件或软件组件。同一层内的实体可以在不同的机器上，通过遵循相同层的协议进行通信。例如，两台计算机上的传输层实体可以是负责建立端到端连接的软件。同一层次的实体为对等实体。</p>
<p><strong>3）</strong><em><strong>*协议（Protocol）*</strong></em></p>
<p>协议是一套规则和标准，用于控制同一层次内的实体如何相互通信。协议定义了通信的格式、时序、错误处理等。例如，TCP（传输控制协议）定义了如何在网络中的两个点之间可靠地传输数据。</p>
<p><strong>4）</strong><em><strong>*接口（Interface）*</strong></em></p>
<p>接口是网络分层模型中，定义相邻两层之间如何交互的规范。它规定了一层如何向另一层提出服务请求，以及这些请求怎样被另一层接收和响应。接口包含了一系列的规则、命令、数据格式和过程，确保不同网络层之间的有效通信和数据交换。</p>
<p>服务访问点（Service Access Point，SAP）是接口概念的一个组成部分，具体化了接口在实现层次服务中的作用。</p>
<p>接口定义了相邻层之间交互的规范和方式，而SAP则是这种交互发生的具体逻辑位置。换句话说，SAP为接口提供了一个具体的实施机制，使得上层能够访问下层提供的服务。</p>
<p><strong>5）</strong><em><strong>*服务（Service）*</strong></em></p>
<p>服务是指下层为紧邻上层提供的功能调用，是垂直方向的。描述了上层可以利用的具体功能和操作，但不涉及这些功能是如何实现的。服务强调的是功能性的提供，而不是实现细节。服务描述了“做什么”（功能），而不是“如何做”（实现细节）。服务是抽象的，隐藏了下层如何完成这些任务的具体细节，使得上层可以不依赖于下层的具体实现来进行设计和开发。</p>
<p>上层是通过SAP访问下层服务的。</p>
<h4 id="6-2-2-OSI七层模型"><a href="#6-2-2-OSI七层模型" class="headerlink" title="6.2.2 OSI七层模型"></a>6.2.2 <strong>OSI七层模型</strong></h4><p>OSI（Open Systems Interconnection，开放系统互联）模型是由国际标准化组织（ISO）在1984年提出的一个网络架构模型，它将网络通信分为七个层次，每层都定义了特定的网络功能。自下而上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps147.jpg" alt="img"> </p>
<p><strong>1）</strong><em><strong>*物理层（Physical Layer）*</strong></em></p>
<p>负责传输原始比特流。它涉及的是物理设备及介质，如电缆类型、电信号传输和接收等。</p>
<p><strong>2）</strong><em><strong>*数据链路层（Data Link Layer）*</strong></em></p>
<p>确保物理链路上的无误传输。它提供了如帧同步、流量控制和错误检测等功能。</p>
<p><strong>3）</strong><em><strong>*网络层（Network Layer）*</strong></em></p>
<p>负责数据包从源到目的地的传输和路由选择。它定义了地址和路由的概念，如IP协议。</p>
<p><strong>4）</strong><em><strong>*传输层（Transport Layer）*</strong></em></p>
<p>提供端到端的数据传输服务，保证数据的完整性。它定义了如TCP和UDP协议。</p>
<p><strong>5）</strong><em><strong>*会话层（Session Layer）*</strong></em></p>
<p>管理会话，控制建立、维护和终止会话。</p>
<p><strong>6）</strong><em><strong>*表示层（Presentation Layer）*</strong></em></p>
<p>处理数据的表示、编码和解码，如加密和解密。</p>
<p><strong>7）</strong><em><strong>*应用层（Application Layer）*</strong></em></p>
<p>提供网络服务给终端用户的应用程序，如HTTP、FTP、SMTP等协议。</p>
<h4 id="6-2-3-五层模型"><a href="#6-2-3-五层模型" class="headerlink" title="6.2.3 五层模型"></a>6.2.3 <strong>五层模型</strong></h4><p>五层模型是将OSI模型的应用层、表示层和会话层合并为应用层，其它层不变。是为了教学而设计的一种网络分层模型。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps148.jpg" alt="img"> </p>
<p><strong>本文基于五层模型对网络分层进行介绍。</strong></p>
<h4 id="6-2-4-TCP-IP四层模型"><a href="#6-2-4-TCP-IP四层模型" class="headerlink" title="6.2.4 TCP&#x2F;IP四层模型"></a>6.2.4 <strong>TCP&#x2F;IP四层模型</strong></h4><p>TCP&#x2F;IP四层模型，亦称互联网协议套件（Internet Protocol Suite），是一种按照功能标准组织互联网及类似计算机网络中使用的一系列通信协议的框架。该套件中的基础协议包括传输控制协议（TCP）、用户数据报协议（UDP）和互联网协议（IP）。</p>
<p>TCP&#x2F;IP协议栈（Protocol Stack）是指TCP&#x2F;IP协议套件的软件实现。</p>
<p><strong>1）</strong><em><strong>*应用层（Application Layer）*</strong></em></p>
<p>（1）定义</p>
<p>这层是用户最直接交互的部分，是软件应用通过网络进行通信的地方。应用层使用下层提供的服务来创建用户数据，将这些数据传输给同一台机器上或远程机器上的其他应用。</p>
<p>（2）协议</p>
<p>该层包括了SMTP、FTP、SSH、HTTP等协议，这些协议都在应用层上实现，以实现客户端与服务器之间的通信和数据交换。</p>
<p><strong>2）</strong><em><strong>*传输层（Transport Layer）*</strong></em></p>
<p>（1）定义</p>
<p>传输层管理着端到端的通信，即主机到主机的通信。它的主要职责是为不同主机上的应用程序提供数据传输，同时保证这些数据的完整性和可靠性。</p>
<p>（2）协议</p>
<p>在传输层，主要的协议有TCP（Transmission Control Protocol），它提供顺序的、可靠的、双向的连接流，并管理报文段的发送，确保无错误、不丢失、不重复、按序到达；以及UDP（User Datagram Protocol），它提供一种无连接的服务，数据以数据报的形式发送，不保证顺序或响应。</p>
<p><strong>3）</strong><em><strong>*互联网层（Internet Layer）*</strong></em></p>
<p>（1）定义</p>
<p>互联网层处理跨网络界限的数据包交换，负责将数据报文段从源地址路由到目的地址。这层抽象了实际的物理网络拓扑结构，并且定义了如何在各种网络结构中发送和接收数据包。</p>
<p>网络层的IP协议是构成Internet的基础。Internet上的主机都是通过IP地址来互相识别。IP协议不保证传输数据的可靠性，可能出现丢包等情况。</p>
<p>（2）协议</p>
<p>主要协议是IP（Internet Protocol），它定义了数据包的路由方式和网络地址。其他重要的协议包括ICMP（Internet Control Message Protocol），用于错误报告和网络诊断。</p>
<p><strong>4）</strong><em><strong>*链路层（Link Layer）*</strong></em></p>
<p>（1）定义</p>
<p>链路层涉及到在物理网络上的数据通信。链路层确保网络层传来的IP数据报可以在网络的物理链接上进行传输，不管是通过有线还是无线媒介。它还负责处理与物理网络链接相关的问题，例如MAC（Media Access Control）地址寻址、帧同步、错误检测和校正。</p>
<p>（2）协议</p>
<p>它包括了在物理网络链接中使用的所有协议，如以太网（Ethernet）、Wi-Fi以及PPP（Point-to-Point Protocol）。</p>
<h4 id="6-2-5-OSI七层模型和TCP-IP四层模型对比以及TCP-IP协议栈"><a href="#6-2-5-OSI七层模型和TCP-IP四层模型对比以及TCP-IP协议栈" class="headerlink" title="6.2.5 OSI七层模型和TCP&#x2F;IP四层模型对比以及TCP&#x2F;IP协议栈"></a>6.2.5 <strong>OSI七层模型和TCP&#x2F;IP四层模型对比以及TCP&#x2F;IP协议栈</strong></h4><p>OSI模型是学术和法律上的国际标准，TCP&#x2F;IP模型是事实上的国际标准，是现实生活中被广泛遵循的分层模型。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps149.png" alt="img"></p>
<h4 id="6-2-6-网络传输中的数据单元"><a href="#6-2-6-网络传输中的数据单元" class="headerlink" title="6.2.6 网络传输中的数据单元"></a>6.2.6 <strong>网络传输中的数据单元</strong></h4><p><strong>1）</strong><em><strong>*PDU*</strong></em></p>
<p>协议数据单元（Protocol Data Unit，PDU），计算机网络各层对等实体间交换信息的数据单位。PDU包括头部（PCI）和负载（SDU）。不同层次的PDU有专门的术语，例如在网络层，PDU称为数据包，在传输层，PDU称为报文段或数据报，在数据链路层，PDU称为帧（frame）。</p>
<p>（1）数据包（Packet）</p>
<p>通常指网络层（如IP网络层）的数据单位。</p>
<p>（2）报文段（Segment）</p>
<p>通常用于描述传输层（TCP传输层）的数据单位。</p>
<p>（3）数据报（Datagram）</p>
<p>通常用于描述UDP协议的数据单位，它也是传输层的一个概念。</p>
<p><strong>2）</strong><em><strong>*SDU*</strong></em></p>
<p>服务数据单元（Service Data Unit，SDU）是在通信协议的特定层次上传递的数据单元。这些数据被传递给下一层，由下一层进行处理或封装，并附加控制信息（PCI），将其转换为那一层的PDU。SDU是用户数据或者来自上一层的PDU，未包括当前层可能添加的头部或其他控制信息。</p>
<p><strong>3）</strong><em><strong>*PCI*</strong></em></p>
<p>协议控制信息（Protocol Control Information，PCI）是PDU中的元数据部分，它包括用于在网络中传输数据的控制信息，比如地址、端口号、控制标志、协议类型等。它与SDU一起被封装成PDU。PCI基本上是头部和尾部信息，它使得网络或传输实体能够理解如何处理包含的SDU。</p>
<p>PDU&#x3D;SDU+PCI。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps150.jpg" alt="img"> </p>
<p><strong>4）</strong><em><strong>*头部、尾部与PCI*</strong></em></p>
<p>头部（Header）和尾部（Trailer）都属于PCI。</p>
<p>头部和尾部是物理的，实际上是SDU前面或后面附加的一系列比特。而PCI是逻辑的，它是协议控制信息的集合，指导网络中的各层对数据做正确处理，确保网络协议正常运作。</p>
<p>通常PCI只包含头部，一个特例是以太网的数据帧不止包含头部，还包含尾部的帧检验序列（FCS，Frame Check Sequence，用于差错控制）。以太网帧的头部和尾部共同构成了它的PCI。</p>
<p>网络分层模型的层与层之间相互依赖，数据由上层到底层的过程中，每层都要加上该层协议的Header，我们称之为封装。</p>
<h4 id="6-2-7-基于以太网的通信流程示例"><a href="#6-2-7-基于以太网的通信流程示例" class="headerlink" title="6.2.7 基于以太网的通信流程示例"></a>6.2.7 <strong>基于以太网的通信流程示例</strong></h4><p>假设我们的设备接入了以太网，通过浏览器访问<a target="_blank" rel="noopener" href="http://www.atguigu.com/%EF%BC%8C%E8%BF%99%E4%B8%80%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BC%9A%E5%90%91%E7%BD%91%E7%AB%99%E5%90%8E%E5%8F%B0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%9C%A8TCP/IP%E6%A8%A1%E5%9E%8B%E4%B8%AD%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%E3%80%82">http://www.atguigu.com/，这一过程中，我们会向网站后台的服务器发送数据，在TCP/IP模型中，数据的传输过程如下所示。</a></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps151.png" alt="img"></p>
<h4 id="6-2-8-服务、协议和接口的关系"><a href="#6-2-8-服务、协议和接口的关系" class="headerlink" title="6.2.8 服务、协议和接口的关系"></a>6.2.8 <strong>服务、协议和接口的关系</strong></h4><p>服务描述了下层可以为相邻上层提供的功能，是抽象的。而接口提供了<strong>访问这些功能</strong>的方法。接口是实现服务交付的框架，如网络编程框架（API库）。要实现服务，需要遵循特定的协议，协议定义了实现服务所需的数据格式、操作顺序、错误处理等规则。</p>
<p>服务告诉我们“可以提供什么功能”，接口解决的是“如何调用功能”，而协议定义了“如何实现功能”。 </p>
<p>通过接口，上层不需要知道服务是如何实现的，只需要知道如何通过接口访问这些服务。而服务的具体实现需要遵循相应的协议。</p>
<p>以OSI七层模型中的传输层和网络层为例。</p>
<p>Ø 服务：网络层提供的服务是数据包的传输和路由选择。传输层可能会请求网络层提供的传输和路由服务来将数据包传输到目的地址。传输层不关心网络层如何实现这些服务，它只关心如何使用这些服务。</p>
<p>Ø 接口：在上述过程中，传输层使用的是网络层暴露的接口（比如使用IP协议栈的API）来发送和接收IP数据包。接口定义了传输层和网络层之间的交互方式，包括传输层如何向网络层提交数据包，以及网络层提供反馈信息的方式。这些API以一种对传输层透明的方式遵循网络层的协议。</p>
<p>Ø 协议：传输层通过网络层的接口发送数据时，实际上是在使用网络层的协议。网络层遵循的IP协议定义了如何在设备间路由数据包，包括如何寻址、打包和处理数据传输中的错误。实现IP协议栈时，必须遵守IP协议。</p>
<h3 id="6-3-传输层-TCP协议"><a href="#6-3-传输层-TCP协议" class="headerlink" title="6.3 传输层-TCP协议"></a>6.3 <strong>传输层-TCP协议</strong></h3><h4 id="6-3-1-什么是TCP协议"><a href="#6-3-1-什么是TCP协议" class="headerlink" title="6.3.1 什么是TCP协议"></a>6.3.1 <strong>什么是TCP协议</strong></h4><p>TCP（传输控制协议，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，广泛应用于互联网中。它旨在提供可靠的端到端通信，在发送数据之前，需要在两个通信端点之间建立连接。TCP通过一系列机制确保数据的可靠传输，这些机制包括序列号、确认应答、重传控制、流量控制和拥塞控制。</p>
<h4 id="6-3-2-TCP协议的特征"><a href="#6-3-2-TCP协议的特征" class="headerlink" title="6.3.2 TCP协议的特征"></a>6.3.2 <strong>TCP协议的特征</strong></h4><p><strong>1）</strong><em><strong>*面向连接*</strong></em></p>
<p>TCP是一种面向连接的协议，这意味着在数据交换之前，两个通信端必须先建立连接。这个连接通过一个三次握手过程（SYN、SYN-ACK、ACK）来建立，确保双方都准备好数据交换。</p>
<p><strong>2）</strong><em><strong>*可靠传输*</strong></em></p>
<p>TCP通过序列号和确认应答机制确保数据的可靠传输。发送方为每个报文段分配一个序列号，接收方通过发送确认应答（ACK）来确认已经收到特定序列号的报文段。如果发送方没有在合理的超时时间内收到确认应答，它将重传该报文段。</p>
<p><strong>3）</strong><em><strong>*流量控制*</strong></em></p>
<p>TCP使用窗口大小调整机制来进行流量控制，防止发送方过快地发送数据，导致接收方来不及处理。通过调整窗口大小，TCP能够动态地管理数据的传输速率，避免网络拥塞和数据丢失。</p>
<p><strong>4）</strong><em><strong>*拥塞控制*</strong></em></p>
<p>TCP实现了拥塞控制算法（如慢启动、拥塞避免、快重传和快恢复），以避免网络中的过度拥塞。这些算法可以根据网络条件动态调整数据的发送速率，从而提高整个网络的效率和公平性。</p>
<p><strong>5）</strong><em><strong>*数据排序*</strong></em></p>
<p>由于网络延迟和路由变化，TCP报文段可能会乱序到达接收方。TCP能够根据序列号重新排序乱序到达的报文段，确保数据以正确的顺序交付给应用层。</p>
<p><strong>6）</strong><em><strong>*端到端通信*</strong></em></p>
<p>TCP提供端到端的通信。每个TCP连接由四个关键元素唯一确定：源IP地址、源端口号、目标IP地址、目标端口号。这种方式确保了数据能够在复杂的网络环境中准确地从一个端点传输到另一个端点。</p>
<h4 id="6-3-3-TCP报文段格式"><a href="#6-3-3-TCP报文段格式" class="headerlink" title="6.3.3 TCP报文段格式"></a>6.3.3 <strong>TCP报文段格式</strong></h4><p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps152.png" alt="img"></p>
<p>头部字段介绍如下：</p>
<p><strong>1）</strong><em><strong>*源端口号（Source Port）和目标端口号（Destination Port）:*</strong></em></p>
<p>每个字段都是16位，用于标识发送和接收数据的应用层服务。端口号允许操作系统区分不同的网络服务。</p>
<p><strong>2）</strong><em><strong>*序列号（sequence number field）*</strong></em></p>
<p>一个32位的数，用于标识从TCP源到目标的数据字节流，它用于确保数据的有序传输和重组。</p>
<p>TCP把数据看成一个无结构的、有序的字节流。TCP的序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。<strong>一个报文段的序号是该报文段首字节的字节流编号。</strong>举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流是一个包含1000字节的序列，每次传输的报文段长度为100个字节，数据流的首字节编号是0。将为该数据流构建10个报文段。给第一个报文段分配序号0，第二个报文段分配序号100，第三个报文段分配序号200，以此类推。每一个序号被写入相应TCP报文段首部的序列号字段中。</p>
<p><strong>3）</strong><em><strong>*确认号（acknowledgement number field）*</strong></em></p>
<p>也是一个32位的数，如果设置了ACK标志，<strong>报文段的确认号是发送方期望从对方收到的下一字节的序号。</strong>它是对之前接收到的数据的确认。假设主机A上的一个进程通过一条TCP连接和主机B上的一个进程通信，主机A已经收到了来自主机B的序号为0~122的所有字节，同时假设主机A接下来将要发送一个报文段给主机B，主机A等待主机B的数据流中序号为123及之后的所有字节，因此主机A将要发送给主机B的报文段中确认号应为123。</p>
<p><strong>4）</strong><em><strong>*数据偏移（Data Offset）*</strong></em></p>
<p>一个4位字段，表示TCP头部的长度（以32位字为单位）。TCP头部可能包含可变数量的选项，因此长度是不确定的，需要这个字段记录长度信息。</p>
<p><strong>5）</strong><em><strong>*保留（Reserved）*</strong></em></p>
<p>这是一个预留的6位字段，当前必须设置为0。</p>
<p><strong>6）</strong><em><strong>*控制位（Control Bits）*</strong></em></p>
<p>标志字段共有六个比特，每个比特对应一个标志：URG、ACK、PSH、RST、SYN、FIN。这些标志用于控制TCP的不同行为，例如建立连接（SYN），终止连接（FIN），指示数据急迫性（URG）等。</p>
<p>Ø URG：紧急标志，为1表示当前报文段存在被发送端上层实体置为“紧急”的数据。接收方应当优先处理这些数据。紧急指针字段指出了这部分数据的结束位置。</p>
<p>Ø ACK：确认标志，为1指示确认字段的值是有效的。该报文段包含对已被成功接收报文段的确认。连接建立后，直至释放前传输的所有报文段ACK标志均为1。</p>
<p>Ø PSH：为1指示接收方应立即将数据交给上层。</p>
<p>Ø RST：为1表示链接出现错误，要求接收方终止连接，并重新建立连接。</p>
<p>Ø SYN：该标志位用于建立连接。TCP连接建立时的前两次握手SYN为1。</p>
<p>Ø FIN：为1表示发送方已经没有数据发送，想要断开连接。</p>
<p><strong>7）</strong><em><strong>*窗口大小（Window Size）*</strong></em></p>
<p>一个16位的数值，用于控制对方发送的数据量，以避免接收方缓冲区溢出。窗口大小是流量控制的一部分，可以动态调整。</p>
<p><strong>8）</strong><em><strong>*校验和（Checksum）*</strong></em></p>
<p>一个16位的字段，用于检查整个TCP报文段的错误。校验和确保数据在传输过程中的完整性。</p>
<p><strong>9）</strong><em><strong>*紧急指针（Urgent Pointer）*</strong></em></p>
<p>一个16位的字段，如果URG标志被设置则为正数，表明从当前序列号开始的紧急数据的字节偏移量。</p>
<p><strong>10）</strong><em><strong>*选项（Options）*</strong></em></p>
<p>TCP头部可能包含各种可选字段，这些字段不是固定的，可能包括如最大报文段大小（MSS）、窗口缩放选项、选择性确认（SACK）等，用于优化TCP连接的性能。</p>
<p><strong>11）</strong><em><strong>*填充（Padding）*</strong></em></p>
<p>TCP是在32位体系结构上设计的，为了内存对齐以提升处理效率，需要确保它的头部长度为32位的整数倍。选项长度可变，填充的目的是确保TCP头部的长度按照32位字对齐，填充位于TCP头部的末尾。</p>
<p>注意：TCP数据部分不要求按照32位字对齐。</p>
<h4 id="6-3-4-TCP状态"><a href="#6-3-4-TCP状态" class="headerlink" title="6.3.4 TCP状态"></a>6.3.4 <strong>TCP状态</strong></h4><p>在TCP连接的生命周期中，根据不同的操作和事件，会经历多种状态。以下是TCP协议定义的11种状态，每种状态对应连接的不同阶段：</p>
<p><strong>1）</strong><em><strong>*CLOSED*</strong></em></p>
<p>这是初始状态和最终状态，表示没有活动的连接，也没有正在进行的通信。</p>
<p><strong>2）</strong><em><strong>*LISTEN*</strong></em></p>
<p>在服务器端监听来自客户端的连接请求。服务器在这个状态下等待进入的SYN报文。</p>
<p><strong>3）</strong><em><strong>*SYN_SENT*</strong></em></p>
<p>客户端发送一个连接请求到服务器（SYN包），然后转入SYN_SENT状态等待服务器确认。</p>
<p><strong>4）</strong><em><strong>*SYN_RECEIVED*</strong></em></p>
<p>服务器接收到客户端的SYN报文后，响应一个SYN+ACK报文，同时进入SYN_RECEIVED状态。这个状态表明服务器端已响应连接请求。</p>
<p><strong>5）</strong><em><strong>*ESTABLISHED*</strong></em></p>
<p>连接已建立成功，数据可以开始传输。这是在三次握手成功完成后，双方都会进入的状态。</p>
<p><strong>6）</strong><em><strong>*FIN_WAIT_1*</strong></em></p>
<p>在一个TCP连接中，当一端完成它的数据发送任务后，它会发送一个FIN报文，表示它已经完成数据发送，进入FIN_WAIT_1状态。</p>
<p><strong>7）</strong><em><strong>*FIN_WAIT_2*</strong></em></p>
<p>在发送了FIN报文并接收到对方的ACK响应后，进入FIN_WAIT_2状态。在这个状态下，连接一端等待对方的FIN报文。</p>
<p><strong>8）</strong><em><strong>*CLOSE_WAIT*</strong></em></p>
<p>在接收到对方的FIN报文后，进入CLOSE_WAIT状态。在这个状态下，TCP连接的这一端知道对方已经没有数据发送，但本地可能还有数据需要发送。</p>
<p><strong>9）</strong><em><strong>*CLOSING*</strong></em></p>
<p>在同时关闭的情况下，当两端几乎同时发送FIN报文时，可能会进入CLOSING状态，表示双方都在等待对方的FIN报文的确认。</p>
<p><strong>10）</strong><em><strong>*LAST_ACK*</strong></em></p>
<p>在发送完自己的所有数据并发送了FIN报文后，如果还需要等待来自对方的最后一个ACK，就会进入LAST_ACK状态。</p>
<p><strong>11）</strong><em><strong>*TIME_WAIT*</strong></em></p>
<p>当TCP连接的一端接收到对方的FIN报文并发送了ACK报文后，它会进入TIME_WAIT状态。该状态会持续一段时间（2倍的MSL，最大报文生存时间），以确保对方接收到最后一个ACK报文。这样可以正确地关闭连接，并确保旧的重复报文不会在网络中造成混乱。</p>
<h4 id="6-3-5-TCP连接的建立和释放"><a href="#6-3-5-TCP连接的建立和释放" class="headerlink" title="6.3.5 TCP连接的建立和释放"></a>6.3.5 <strong>T<strong><strong>CP</strong></strong>连接的建立和释放</strong></h4><p><strong>1）</strong><em><strong>*TCP连接建立过程*</strong></em></p>
<p>TCP的连接建立过程又称为三次握手。</p>
<p><strong>我们用小写的seq表示TCP报文头部的序号，用小写的ack表示确认号。未提到的标志位均为0。</strong></p>
<p>（1）TCP服务器准备好接受连接，进入LISTEN状态，这一过程称为被动打开。</p>
<p>（2）第一次握手：客户端发送SYN标志为1（表示这是一个同步报文段），且seq随机的报文段，请求建立连接。此时的seq记为ISN(c)（Initial Sequence Number，初始序列号），括号中的c表示这是和客户端的序列号。客户端发送后变为SYN-SENT状态。</p>
<p>（3）第二次握手：服务端收到客户端的第一次握手信号，变为SYN-RCVD状态。随即确认客户端的SYN报文段，发送一个ACK和SYN标志均为1的报文段。该报文段中ack&#x3D;ISN(c)+1，seq随机，标记为ISN(s)，此处的s表示这是服务端的序列号。服务端变为SYN-RCVD状态。</p>
<p>（4）第三次握手：客户端收到服务端的第二次握手信号，变为ESTABLISHED状态，随即确认服务端的报文段，发送ACK标志为1的报文段。该报文段中ack&#x3D;ISN(s)+1，seq&#x3D;ISN(c)+1。服务端收到客户端的第三次握手信号之后变为ESTABLISHED状态。</p>
<p>下面的PPT中，<strong>大写字母组合表示相应标志位为1。</strong></p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps153.png" alt="img"></p>
<p><strong>2）</strong><em><strong>*TCP连接释放过程*</strong></em></p>
<p>TCP的连接释放过程又称为四次挥手。</p>
<p>四次挥手可以由客户端发起，也可以由服务端发起。此处假设连接请求的断开操作由客户端发起。连接断开前，双方都处于ESTABLISHED状态。需要注意的是，连接建立后，即客户端和服务端处于ESTABLISHED时，双方发送的报文段ACK标志均为1。</p>
<p><strong>我们用小写的seq表示TCP报文头部的序号，用小写的ack表示确认号。未提到的标志位均为0。</strong></p>
<p>（1）第一次挥手：客户端发送FIN标志为1（即FINISH，表示通信结束）的报文段，请求断开连接，执行主动关闭（active close）。此时，报文段中包含对于服务端数据的确认，ACK为 1，假设ack&#x3D;V。连接断开前已经历了一系列的数据传输，seq取决于之前已发送的报文段，假设seq&#x3D;U。客户端状态变为FIN-WAIT-1。</p>
<p>（2）第二次挥手：服务端接收到第一次挥手信息，切换为CLOSE-WAIT状态，随即发送ACK标志为1，ack&#x3D;U+1的报文段，此时seq&#x3D;V。客户端接收到服务端的第二次挥手信号，变为FIN-WAIT-2状态。第二次挥手后，服务端仍可发送数据，客户端仍可接收。</p>
<p>（3）第三次挥手：服务端完成数据传送后，发送FIN标志和ACK标志均为1的报文段，ack&#x3D;U+1，seq大于V，假设为W，请求断开连接，这一过程称为被动关闭。服务端发送第三次挥手信号后，变为LAST-ACK状态。</p>
<p>（4）第四次挥手：客户端收到第三次挥手信号，随即发送ACK标志为1，seq&#x3D;U+1，ack&#x3D;W+1的报文段，变为TIME-WAIT状态。服务端收到第四次挥手信号，变为CLOSED状态。客户端从变为TIME-WAIT状态开始计时，等待2MSL（2倍最大报文时长，约定值）后进入CLOSED状态。四次挥手结束。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps154.png" alt="img"></p>
<h4 id="6-3-6-TCP数据传输"><a href="#6-3-6-TCP数据传输" class="headerlink" title="6.3.6 TCP数据传输"></a>6.3.6 <strong>TCP数据传输</strong></h4><h5 id="6-3-6-1-可靠传输保障"><a href="#6-3-6-1-可靠传输保障" class="headerlink" title="6.3.6.1 可靠传输保障"></a>6.3.6.1 <strong>可靠传输保障</strong></h5><p><strong>1）</strong><em><strong>*累积确认*</strong></em></p>
<p>上文介绍了TCP连接的建立和释放，当客户端或服务器接收到来自对方的FIN报文或SYN报文后，会立即发送一条ACK报文，ACK的值为接收到的FIN或SYN报文中seq+1。在数据传输过程中，ack也会根据接收到的报文段中seq的值发生变化。</p>
<p>TCP的累积确认（Cumulative Acknowledgment）是指接收方发送的ACK报文中的确认号表示的是接收方期望接收的下一个字节的序列号。这意味着所有比这个确认号小的字节都已经被成功接收。</p>
<p><strong>2）</strong><em><strong>*延时确认*</strong></em></p>
<p>接收方在接收到每个报文段后，不会立即发送确认报文（ACK），而是会等待一段时间，看是否有其他报文段到达或者接收方是否有数据要发送。在这种情况下，接收方可以将多个确认合并为一个ACK报文。这种机制被称为延迟确认，目的是减少ACK报文的数量，从而降低网络开销。</p>
<p><strong>3）</strong><em><strong>*超时重传*</strong></em></p>
<p>当发送方发送数据后，如果在预定时间内未收到接收方的确认（ACK），发送方会假设该数据段丢失，并重新发送该数据段。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps155.png" alt="img"></p>
<h5 id="6-3-6-2-滑动窗口"><a href="#6-3-6-2-滑动窗口" class="headerlink" title="6.3.6.2 滑动窗口"></a>6.3.6.2 <strong>滑动窗口</strong></h5><p>在TCP通信中，双方各自维护一个缓冲区。当发送速率大于接收速率时，接收方的缓冲区可能会被填满。如果发送方继续发送数据，后面的数据只能被丢弃，造成资源浪费。为了避免这种情况，TCP提供了滑动窗口机制来控制发送方的发送速率。</p>
<p>TCP报文段的头部有一个字段是窗口大小（Window Size），这里的窗口是指接收窗口（Receive Window，rwnd）。接收方可以在返回的ACK报文段中通过窗口大小字段告诉发送方当前可用的缓冲区即接收窗口大小。接收窗口大小随数据传输动态变化，当窗口大小变为0时，发送方会暂停数据发送。一段时间后，接收方腾出了足够的空间来接收数据，它会发送报文段通知发送方继续发送。</p>
<p>滑动窗口机制通过动态调整窗口大小，确保发送的数据不会超出接收方的处理能力，从而避免数据丢失和资源浪费，同时保证了TCP连接的可靠性，实现了流量控制。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps156.png" alt="img"></p>
<h5 id="6-3-6-3-拥塞控制"><a href="#6-3-6-3-拥塞控制" class="headerlink" title="6.3.6.3 拥塞控制"></a>6.3.6.3 <strong>拥塞控制</strong></h5><p>上文提到，基于接收窗口，TCP实现了滑动窗口机制，限制了发送方在某一时刻可以发送的数据量，从而有效地进行流量控制。接收窗口是根据接收方的处理能力计算的。</p>
<p>设想这样的场景：rwnd为1000B，每个报文段大小为100B，发送方可以同时发送10个报文段，而此时网络环境较差，同时发送5个报文段已经达到了网络传输能力的极限。那么10个报文段必然会发生拥堵和丢失，发送方无法在超时前收到ACK，不断重传，进一步加剧拥堵，恶性循环。</p>
<p>为了避免这样的情况，TCP维护了拥塞窗口（Congestion Window，cwnd）。拥塞窗口是发送方根据网络状况计算得到的，是发送方用来实现流量控制的基础，它的大小可以动态调整。基于拥塞窗口，结合下面的五种机制或策略，发送方实现了流量控制。</p>
<p><strong>1）</strong><em><strong>*慢启动*</strong></em></p>
<p>连接建立后将拥塞窗口的初始大小cwnd设置为一倍的SMSS（发送方最大报文段大小）（协议的实现可能并不是一倍，为了便于讨论，我们假设为一倍），即cwnd&#x3D;1*SMSS。为了便于分析，我们省略SMSS，称初始的cwnd为1，下文同理。</p>
<p>在慢启动阶段，每接收到一个ACK，cwnd翻倍，这一阶段窗口大小呈指数增长。</p>
<p><strong>2）</strong><em><strong>*拥塞避免*</strong></em></p>
<p>当cwnd达到慢启动阈值ssthresh（Slow Start Threshold）时，进入拥塞避免阶段。此阶段每接收到一个ACK，cwnd+1。</p>
<p><strong>3）</strong><em><strong>*超时重传*</strong></em></p>
<p>随着窗口的增长，网络中传输的数据越来越多，最终超出带宽限制，就会出现报文段的丢失。发送方为每条数据维护一个定时器，如果限定时间内未收到ACK则判定超时。发送端检测到超时，将ssthresh调整为当前cwnd的一半，然后将cwnd重置为1，重新开始慢启动过程。</p>
<p><strong>4）</strong><em><strong>*快速重传*</strong></em></p>
<p>我们知道，TCP采用了累积确认的方式，如果某个报文段发生了丢失，即便收到了后面的数据，接收方返回的ACK也是一样的。当发送方连续收到3个重复的ACK时，判定相应的报文段丢失，立即重传。这样可以在不等待超时的情况下重传丢失的报文段，避免了数据丢失时的长期等待，提升传输效率。</p>
<p><strong>5）</strong><em><strong>*快速恢复*</strong></em></p>
<p>当快速重传发生时，sshthresh调整为当前cwnd的一半，cwnd不必重新从1开始，而是与新的sshthresh相等，重新执行拥塞避免策略。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps157.png" alt="img"></p>
<h5 id="6-3-6-4-发送窗口"><a href="#6-3-6-4-发送窗口" class="headerlink" title="6.3.6.4 发送窗口"></a>6.3.6.4 <strong>发送窗口</strong></h5><p>接收窗口保证发送的数据不会超过接收方的处理能力，拥塞窗口保证发送的数据不会超过网络的承载能力，那么发送方发送数据时应该以哪个窗口为准呢？很显然，我们既要保证数据传输不能超出接收方的处理能力，又要保证不能超出网络的承载能力。发送方可用的窗口应该是拥塞窗口和接收窗口的最小值，这就是发送窗口（Send Window，swnd），这个窗口真正决定了可以发送的数据量。真正的TCP协议实现中，滑动窗口和拥塞控制机制是协同工作的。</p>
<h4 id="6-3-7-TCP开发常用函数"><a href="#6-3-7-TCP开发常用函数" class="headerlink" title="6.3.7 TCP开发常用函数"></a>6.3.7 <strong>TCP开发常用函数</strong></h4><p>根据以上图示，TCP协议通讯需要用到的函数如下：</p>
<p><strong>1）</strong><em><strong>*socket*</strong></em></p>
<p>（1）套接定义</p>
<p>套接字（Socket）是计算机网络数据通信的基本概念和编程接口，允许不同主机上的进程（运行中的程序）通过网络进行数据交换。它为应用层软件提供了发送和接收数据的能力，使得开发者可以在不用深入了解底层网络细节的情况下进行网络编程。socket英文直译为“插座”，可以理解为应用层调用网络服务的接口。</p>
<p>（2）套接字的组成</p>
<p>一个套接字主要由以下三个属性组成：</p>
<p>Ø 网络地址：通常是IP地址，用于标识网络上的设备。</p>
<p>Ø 端口号：用于标识设备上的特定应用或进程。端口号是一个16位的数字，范围从0到65535。</p>
<p>Ø 协议：如TCP（传输控制协议）或UDP（用户数据报协议），定义了数据传输的规则和格式。</p>
<p>（3）套接字的类型</p>
<p>根据数据传输方式的不同，主要有两种类型的套接字：</p>
<p>Ø 流套接字（Stream Sockets）：基于TCP协议，提供面向连接、可靠的数据传输服务。数据像流水一样连续传输，接收方按发送顺序接收数据，适用于需要准确无误传输数据的应用，如网页服务器。</p>
<p>Ø 数据报套接字（Datagram Sockets）：基于UDP协议，提供无连接的数据传输服务。每个报文段独立传输，可能会丢失或无法保证顺序，适用于对传输速度要求高但可以容忍一定丢包率的应用，如在线视频会议。</p>
<p>（4）套接字的工作原理</p>
<p>套接字通过封装TCP&#x2F;IP协议细节，提供了一组API，允许应用程序创建套接字、绑定地址和端口、监听连接、接受连接、发送和接收数据等。在网络通信中，通常一个套接字负责监听和接受外部连接（服务器套接字），另一个套接字负责发起连接（客户端套接字）。</p>
<p>（5）为何使用套接字</p>
<p>套接字的引入极大地简化了网络编程的复杂度，使得开发者可以专注于应用逻辑的实现，而无需深入了解网络协议栈的内部工作原理。通过使用套接字，可以轻松实现不同计算机之间的数据交换，支持构建分布式系统和多种网络应用。</p>
<p>（6）socket函数</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 在通信域中创建一个未绑定的socket，并返回一个文件描述符，该描述符可以在后续对socket进行操作的函数调用中使用</p>
<p> * </p>
<p> * @param domain 指定要创建套接字的通信域。</p>
<p> *    AF_UNIX：本地通信，通常用于 UNIX 系统间的进程间通信。</p>
<p> *    AF_LOCAL：AF_UNIX 的别名。</p>
<p> *    AF_INET：IPv4 互联网协议。</p>
<p> *    AF_AX25：业余无线电 AX.25 协议。</p>
<p> *    AF_IPX：IPX - Novell 协议。</p>
<p> *    AF_APPLETALK：AppleTalk 协议。</p>
<p> *    AF_X25：ITU-T X.25 &#x2F; ISO-8208 协议。</p>
<p> *    AF_INET6：IPv6 互联网协议。</p>
<p> *    AF_DECnet：DECnet 协议套接字。</p>
<p> *    AF_KEY：密钥管理协议，最初用于 IPsec。</p>
<p> *    AF_NETLINK：内核用户接口设备。</p>
<p> *    AF_PACKET：低级报文段接口。</p>
<p> *    AF_RDS：可靠数据报套接字（RDS）协议。</p>
<p> *    AF_PPPOX：通用 PPP 传输层，用于设置 L2 隧道（L2TP 和 PPPoE）。</p>
<p> *    AF_LLC：逻辑链路控制（IEEE 802.2 LLC）协议。</p>
<p> *    AF_IB：InfiniBand 本机寻址。</p>
<p> *    AF_MPLS：多协议标签交换。</p>
<p> *    AF_CAN：控制器区域网络汽车总线协议。</p>
<p> *    AF_TIPC：TIPC，“集群域套接字”协议。</p>
<p> *    AF_BLUETOOTH：蓝牙低级套接字协议。</p>
<p> *    AF_ALG：与内核加密 API 接口。</p>
<p> *    AF_VSOCK：VSOCK（最初为“VMWare VSockets”）协议，用于虚拟机和宿主机之间的通信。</p>
<p> *    AF_KCM：KCM（内核连接复用器）接口。</p>
<p> *    AF_XDP：XDP（快速数据通道）接口。</p>
<p> * @param type 指定要创建的socket类型</p>
<p> *    SOCK_STREAM：提供序列化、可靠的、双向的、基于连接的字节流。可以支持带外数据传输机制。</p>
<p> *    SOCK_DGRAM：支持数据报（无连接、不可靠的固定最大长度的消息）。</p>
<p> *    SOCK_SEQPACKET：为固定最大长度的数据报提供了一个序列化的、可靠的、双向的基于连接的数据传输路径；消费者需要在每次输入系统调用中读取整个报文段。</p>
<p> *    SOCK_RAW：提供原始的网络协议访问。</p>
<p> *    SOCK_RDM：提供一个不保证顺序的可靠数据报层。</p>
<p> * 自 Linux 2.6.27 以来，type 参数还具有第二个目的：除了指定套接字类型外，它还可以包含任何以下值的按位 OR，以修改 socket() 的行为：</p>
<p> *    SOCK_NONBLOCK：在新文件描述符引用的打开文件描述符上设置 O_NONBLOCK 文件状态标志（参见 open(2)）。使用此标志可以节省调用 fcntl(2) 来实现相同结果的额外调用。</p>
<p> *    SOCK_CLOEXEC：在新文件描述符上设置关闭时执行（FD_CLOEXEC）标志。有关为什么可能有用的原因，请参阅 open(2) 中 O_CLOEXEC 标志的描述。</p>
<p> * @param protocol 指定要与socket一起使用的特定协议。指定协议为 0 会导致 socket() 使用适用于所请求的socket类型的未指定的默认协议</p>
<p> * @return int 文件描述符，如果失败返回-1</p>
<p> *&#x2F;</p>
<p>int socket(int domain, int type, int protocol);</p>
<p>在下面的案例中，我们选择创建用于IPv4互联网协议（AF_INET）通信的SOCK_STREAM类型套接字。当套接字类型为SOCK_STREAM时，意味着创建的套接字用于提供一个序列化的、可靠的、双向的、基于连接的字节流。换言之，TCP&#x2F;IP网络中传输的数据是一个连续的流，接收方收到的数据顺序与发送方发送的数据顺序相同。SOCK_STREAM类型的套接字通常使用以下协议：</p>
<p>Ø TCP (Transmission Control Protocol)：这是最常用的SOCK_STREAM协议。TCP提供了一种可靠的数据传输服务，在数据传输过程中，它能自动处理确认接收、超时重传等多种情况，确保数据的正确传输。</p>
<p>Ø SCTP (Stream Control Transmission Protocol)：SCTP是一种传输层协议，提供了类似TCP的可靠传输服务，但是在某些方面比TCP更先进，例如它支持多路径传输和多流传输。SCTP更多被应用于特定的领域，如电信网络。</p>
<p>我们将protocol设置为0，自动选择通信协议（TCP、SCTP）。</p>
<p><strong>2）</strong><em><strong>*bind*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 当使用 socket(2) 创建套接字时，它存在于一个名称空间（地址族）中，但没有为其分配地址。bind() 将由 addr 指定的地址分配给文件描述符 sockfd 所引用的套接字。addrlen 指定了 addr 指向的地址结构的大小（以字节为单位）。传统上，这个操作被称为“给套接字分配一个名称”</p>
<p> * </p>
<p> * @param sockfd 套接字文件描述符</p>
<p> * @param addr 指定的地址。地址的长度和格式取决于socket的地址族</p>
<p> * @param addrlen addr 指向的地址结构的大小（以字节为单位）。</p>
<p> * @return int 成功 0</p>
<p> *       失败 -1</p>
<p> *&#x2F;</p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>（1）地址族</p>
<p>在网络编程中，地址族（Address Family）指定了套接字（socket）使用的网络协议类型以及地址的格式。简而言之，地址族决定了网络通信的范围和方式，比如是在同一台机器上的进程间通信，还是在网络上不同主机间的通信。每种地址族都支持特定类型的通信协议和地址格式。下面是一些常见的地址族：</p>
<p><strong>①</strong> <strong>AF_INET</strong></p>
<p>代表IPv4网络协议的地址族，使用32位地址。</p>
<p>主要用于互联网上的通信。</p>
<p>地址格式通常为点分十进制，如192.168.1.1。</p>
<p><strong>②</strong> <strong>AF_INET6</strong></p>
<p>代表IPv6网络协议的地址族，使用128位地址。</p>
<p>是IPv4的后继，旨在解决IPv4地址耗尽问题，并提供更多的功能。</p>
<p>地址格式为冒号分隔的十六进制，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。</p>
<p><strong>③ AF_UNIX (或 AF_LOCAL)</strong></p>
<p>用于同一台机器上的进程间通信（IPC）。</p>
<p>使用文件系统路径名作为地址。</p>
<p>这种方式不通过网络层进行数据传输，而是在操作系统内部完成，因此效率较高。</p>
<p><strong>④</strong> <strong>AF_PACKET</strong></p>
<p>用于直接访问底层网络设备的数据链路层。</p>
<p>允许发送和接收在网络设备驱动层的帧，常用于实现低级网络协议。</p>
<p><strong>⑤ 其他地址族</strong></p>
<p>还有其他一些特定用途的地址族，如AF_IPX（IPX协议）、AF_NETLINK（用于内核用户空间通信）等，它们各自支持不同的网络协议和地址格式。</p>
<p>开发一个需要在互联网上通信的应用程序，通常会选择AF_INET或AF_INET6地址族。</p>
<p>（2）函数说明</p>
<p>当我们通过上一节的socket()函数创建套接字之后，它存储在一个命名空间（地址族）中，但是并未绑定地址。bind()函数将addr指定的地址绑定到文件描述符sockfd对应的套接字。addrlen记录了addr指针指向的地址结构体占用的字节大小。</p>
<p>（3）地址相关数据类型声明</p>
<p>① struct sockaddr结构体声明如下。</p>
<p>&#x2F;* </p>
<p>在名称绑定中使用的规则在地址族之间有所不同。请参阅第 7 节中的手册条目以获取详细信息。</p>
<p>对于 AF_INET，请参阅 ip(7)；</p>
<p>对于 AF_INET6，请参阅 ipv6(7)；</p>
<p>对于 AF_UNIX，请参阅 unix(7)；</p>
<p>对于 AF_APPLETALK，请参阅 ddp(7)；</p>
<p>对于 AF_PACKET，请参阅 packet(7)；</p>
<p>对于 AF_X25，请参阅 x25(7)；</p>
<p>对于 AF_NETLINK，请参阅 netlink(7)。</p>
<p>传递给 addr 参数的实际结构取决于地址族。sockaddr 结构定义如下：</p>
<p>*&#x2F;</p>
<p>struct sockaddr {</p>
<p>  sa_family_t sa_family; &#x2F;&#x2F; 地址家族，如 AF_INET、AF_INET6、AF_UNIX 等</p>
<p>  char     sa_data[14]; &#x2F;&#x2F; 用于存储具体地址数据的数组，其布局取决于地址</p>
<p>}</p>
<p>&#x2F;*</p>
<p>此结构的唯一目的是将 addr 中传递的结构指针进行转换，以避免编译器警告。</p>
<p>*&#x2F;</p>
<p>我们接下来的程序编写用的是IPV4协议，所以我们用的应该是AF_INET通信域。按照手册说明使用man 7 ip查看手册：</p>
<p>② sockaddr_in</p>
<p>&#x2F;* </p>
<p>IP 套接字地址被定义为 IP 接口地址和一个 16 位端口号的组合。基本的 IP 协议不提供端口号，它们由高层协议如 udp(7) 和 tcp(7) 实现。在原始套接字中，sin_port 被设置为 IP 协议。</p>
<p>*&#x2F;</p>
<p>struct sockaddr_in {</p>
<p>  sa_family_t   sin_family; &#x2F;* 地址族：AF_INET *&#x2F;</p>
<p>  in_port_t    sin_port;  &#x2F;* 端口号，网络字节顺序 *&#x2F;</p>
<p>  struct in_addr sin_addr;  &#x2F;* 互联网地址 *&#x2F;</p>
<p>};</p>
<p>&#x2F;* </p>
<p>sin_family 总是设置为 AF_INET。</p>
<p>sin_port 包含端口号，以网络字节顺序表示。低于 1024 的端口号称为特权端口（或有时称为：保留端口）。只有特权进程（在 Linux 中：具有 CAP_NET_BIND_SERVICE 用户命名空间中的权限，控制其网络命名空间）可以绑定到这些套接字。注意，原始 IPv4 协议本身没有端口的概念，它们仅由 tcp(7) 和 udp(7) 等高级协议实现。</p>
<p>sin_addr 是 IP 主机地址。</p>
<p>③ in_addr</p>
<p>&#x2F;* 互联网地址 *&#x2F;</p>
<p>struct in_addr {</p>
<p>  uint32_t    s_addr;   &#x2F;* 网络字节顺序中的地址 *&#x2F;</p>
<p>};</p>
<p>struct in_addr 的 s_addr 成员以网络字节顺序表示主机接口地址。应使用 htonl(3) 分配 INADDR_* 值（例如，INADDR_LOOPBACK）或使用 inet_aton(3)、inet_addr(3)、inet_makeaddr(3) 库函数或直接使用名称解析器（参见 gethostbyname(3)）进行设置。</p>
<p>*&#x2F;</p>
<p>（4）地址结构体说明</p>
<p>sockaddr 结构体是所有特定地址结构体（如 sockaddr_in 和 sockaddr_un）的基类，这些特定结构体继承了 sockaddr 的结构并添加了各自所需的额外信息</p>
<p>由于 struct sockaddr 是通用结构体，所以在实际使用中，通常会根据地址类型将其转换为相应的具体结构体类型（如 struct sockaddr_in 对于 IPv4 地址），以方便访问和操作地址信息。在调用诸如 bind(), connect(), accept() 等套接字函数时，通常需要使用 struct sockaddr * 类型的指针，并结合 socklen_t 类型的变量来传递和接收地址信息。</p>
<p>所以我们需要声明的地址结构体类型应为struct sockaddr_in，并按照网络字节序去设置IP地址和端口。</p>
<p>（5）其他数据类型</p>
<p>socklen_t相关宏定义如下</p>
<p>typedef __socklen_t socklen_t;</p>
<p>__STD_TYPE __U32_TYPE __socklen_t;</p>
<p># define __STD_TYPE   typedef</p>
<p>#define __U32_TYPE    unsigned int</p>
<p>由上述定义可得，socklen_t实际上是__socklen_t的别名，而__socklen_t实质上是无符号整型的别名</p>
<p>typedef unsigned int __socklen_t;</p>
<p>综上，socklen_t是unsigned int的别名。</p>
<p><strong>3）</strong><em><strong>*listen*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 将 sockfd 指定的套接字标记为被动套接字，即将用于使用 accept(2) 接受传入的连接请求。</p>
<p> * </p>
<p> * @param sockfd 套接字文件描述符</p>
<p> * @param backlog 指定还未accpet但是已经完成链接的队列长度</p>
<p> * @return int 成功 0 </p>
<p> *       失败 -1</p>
<p> *&#x2F;</p>
<p>int listen(int sockfd, int backlog);</p>
<p>（1）说明</p>
<p>listen()是Linux提供的用于TCP网络编程的系统调用，作用是让一个套接字进入监听状态，准备接受连接请求。当listen函数被调用之后，sockfd指定的套接字会从一个主动套接字转变为一个被动套接字，表明它将被用来接受进来的连接请求，而不是主动发起连接。accept函数随后用于响应连接请求。</p>
<p>（2）参数</p>
<p>Ø sockfd：监听连接请求的套接字文件描述符，要求该描述符已经通过bind函数绑定到一个本地地址。</p>
<p>Ø backlog：未被及时响应的连接可以被放入队列等待连接，该参数指定等待队列可以容纳的最大连接数。</p>
<p>（3）返回值</p>
<p>listen函数的返回值如下：</p>
<p>Ø 成功：返回0。</p>
<p>Ø 失败：返回-1，并设置全局变量errno以指示错误原因。</p>
<p><strong>4）</strong><em><strong>*accept*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 从监听套接字 sockfd 的待处理连接队列中提取第一个连接请求，创建一个新的连接套接字，并返回指向该套接字的新文件描述符。新创建的套接字不处于监听状态。原始套接字 sockfd 不受此调用的影响。</p>
<p> * </p>
<p> * @param sockfd 一个使用 socket(2) 创建、使用 bind(2) 绑定到本地地址，并在 listen(2) 后监听连接的套接字。</p>
<p> * @param addr 要么是一个空指针，要么是一个指向 sockaddr 结构的指针，用于返回连接socket的地址。</p>
<p> * @param addrlen 如果 address 是空指针，则为一个空指针；如果 address 不是空指针，则为一个指向 socklen_t 对象的指针，该对象在调用前指定提供的 sockaddr 结构的长度，并在调用后指定存储地址的长度。</p>
<p> * @return int 返回一个新的套接字文件描述符，用于与客户端通信，如果失败返回-1，并设置errno来表示错误原因</p>
<p> *&#x2F;</p>
<p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
<p><strong>5）</strong><em><strong>*connect*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 由客户端调用，来与服务端建立连接。</p>
<p> * </p>
<p> * @param sockfd 客户端套接字的文件描述符</p>
<p> * @param addr 指向sockaddr结构体的指针，包含目的地地址信息</p>
<p> * @param addrlen 指定addr指向的结构体的大小</p>
<p> * @return int 成功 0 </p>
<p> *       失败 -1，并设置errno以指示错误原因</p>
<p> *&#x2F;</p>
<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p><strong>6）</strong><em><strong>*send*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 用于向另一个套接字传输消息。</p>
<p> * </p>
<p> * @param sockfd 发送套接字的文件描述符。</p>
<p> * @param buf 发送缓冲区，并非操作系统分配为服务端和客户端分配的缓冲区，而是用户为了发送数据，自己维护的字节序列。const修饰表名它是“只读”的，即send函数不会修改这块内存的内容。</p>
<p> * @param len 要发送的数据的字节长度。它决定了从buf指向的缓冲区中将发送多少数据。</p>
<p> * @param flags flags 参数是以下标志之一或多个的按位或。对于大多数应用，这个参数被设置为0，表示不使用任何特殊行为。</p>
<p> *    MSG_CONFIRM 告知链路层发生了前进：您从另一端收到了成功的回复。如果链路层没有收到此消息，它将定期重新探测邻居（例如，通过单播 ARP）。仅对 SOCK_DGRAM 和 SOCK_RAW sockets 有效，当前仅对 IPv4 和 IPv6 实现。有关详情，请参阅 arp(7)。</p>
<p> *    MSG_DONTROUTE 不要使用网关发送报文段，只发送到直接连接的网络中的主机。通常仅由诊断或路由程序使用。仅为具有路由功能的协议族定义；报文段套接字不支持。</p>
<p> *    MSG_DONTWAIT 启用非阻塞操作；如果操作会阻塞，则返回 EAGAIN 或 EWOULDBLOCK。这提供了类似于设置 O_NONBLOCK 标志（通过 fcntl(2) F_SETFL 操作）的行为，但不同之处在于 MSG_DONTWAIT 是一个每次调用的选项，而 O_NONBLOCK 是对打开文件描述符（参见 open(2)）的设置，将影响调用进程中的所有线程以及持有引用相同打开文件描述符的其他进程。</p>
<p> *    MSG_EOR 终止记录（当支持此概念时，例如 SOCK_SEQPACKET 类型的套接字）。</p>
<p> *    MSG_MORE 调用方有更多数据要发送。此标志与 TCP sockets 一起使用，以获得与 TCP_CORK 套接字选项相同的效果（请参阅 tcp(7)），不同之处在于此标志可以基于每次调用设置。自 Linux 2.6 起，此标志还适用于 UDP sockets，并告知内核将使用此标志设置的所有调用发送的数据打包到单个数据报中，仅在执行不指定此标志的调用时才传输。（另请参阅 udp(7) 中描述的 UDP_CORK 套接字选项。）</p>
<p> *    MSG_NOSIGNAL 如果面向流的套接字的对等端关闭了连接，则不生成 SIGPIPE 信号。仍会返回 EPIPE 错误。这提供了类似于使用 sigaction(2) 忽略 SIGPIPE 的行为，但 MSG_NOSIGNAL 是每次调用的特性，而忽略 SIGPIPE 设置了一个影响进程中的所有线程的进程属性。</p>
<p> *    MSG_OOB 在支持此概念的套接字上发送带外数据（例如，类型为 SOCK_STREAM 的套接字）；底层协议还必须支持带外数据。</p>
<p> * @return ssize_t成功发送的字节数。如果出现错误，它将返回-1，并设置errno以指示错误的具体原因。</p>
<p> *&#x2F;</p>
<p>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</p>
<p><strong>7）</strong><em><strong>*recv*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 从套接字关联的连接中接收数据。</p>
<p> * </p>
<p> * @param sockfd 套接字文件描述符。</p>
<p> * @param buf 接收缓冲区，同样地，此处也并非内核维护的缓冲区。</p>
<p> * @param len 缓冲区长度，即buf可以接收的最大字节数。</p>
<p> * @param flags flags 参数是以下标志之一或多个的按位或。对于大多数应用，这个参数被设置为0，表示不使用任何特殊行为。</p>
<p> *    MSG_DONTWAIT 启用非阻塞操作；如果操作会阻塞，则调用失败</p>
<p> *    MSG_ERRQUEUE 此标志指定应该从套接字错误队列中接收排队的错误。</p>
<p> *    MSG_OOB 此标志请求接收在正常数据流中不会接收到的带外数据。</p>
<p> *    MSG_PEEK 此标志导致接收操作从接收队列的开头返回数据，而不从队列中删除该数据。因此，后续的接收调用将返回相同的数据。</p>
<p> *    MSG_TRUNC 对于原始（AF_PACKET）、Internet 数据报、netlink和 UNIX 数据报套接字：返回报文段或数据报的实际长度，即使它比传递的缓冲区长。</p>
<p> *    MSG_WAITALL 此标志请求操作阻塞，直到满足完整的请求。</p>
<p> * @return ssize_t 返回接收到的字节数，如果连接已经正常关闭，返回值将是0。如果出现错误，返回-1，并且errno变量将被设置为指示错误的具体原因。</p>
<p> *&#x2F;</p>
<p>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</p>
<p><strong>8）</strong><em><strong>*shutdown*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief关闭套接字的一部分或全部连接</p>
<p> * </p>
<p> * @param sockfd 套接字文件描述符</p>
<p> * @param how 指定关闭的类型。其取值如下：</p>
<p> *    SHUT_RD：关闭读。之后，该套接字不再接收数据。任何当前阻塞在recv调用上的操作都将返回0，表示连接的另一端已经关闭。</p>
<p> *    SHUT_WR：关闭写。之后，试图通过该套接字发送数据将导致错误。如果使用此选项，TCP连接将发送一个FIN包给连接的对端，表明此方向上的数据传输已经完成。此时对端的recv调用将接收到0。</p>
<p> *    SHUT_RDWR：关闭读写。同时关闭套接字的读取和写入部分，等同于分别调用SHUT_RD和SHUT_WR。之后，该套接字既不能接收数据也不能发送数据。</p>
<p> * @return int 成功 0 </p>
<p> *       失败 -1，并设置errno变量以指示具体的错误原因。</p>
<p> *&#x2F;</p>
<p>int shutdown(int sockfd, int how);</p>
<p><strong>9）</strong><em><strong>*close*</strong></em></p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;*</p>
<p>  用于关闭一个之前通过open()、socket()等函数打开的文件描述符</p>
<p>  int __fd: 这是一个整数值,表示要关闭的文件描述符</p>
<p>  return: 成功关闭文件描述符时,close()函数返回0</p>
<p>​      发送失败,例如试图关闭一个已经关闭的文件描述符或系统资源不足,close()会返回-1</p>
<p>*&#x2F;</p>
<p>int close(int __fd);</p>
<p>TCP通信中，套接字也是通过文件描述符操控的，底层同样存储在struct file结构体中，socket相关的数据存在该类型结构体实例的私有数据字段，因此，我们通过close()关闭套接字，效果和关闭文件是类似的，都是使得底层文件描述的引用计数减一，若引用计数减为0则释放套接字相关的资源。</p>
<h4 id="6-3-8-网络字节序和主机字节序转化"><a href="#6-3-8-网络字节序和主机字节序转化" class="headerlink" title="6.3.8 网络字节序和主机字节序转化"></a>6.3.8 <strong>网络字节序和主机字节序转化</strong></h4><p><strong>1）</strong><em><strong>*两种字节序*</strong></em></p>
<p>在网络编程中，特别是在跨平台和网络通信时，字节序（Byte Order）是非常重要的概念。字节序指的是多字节数据在内存中的存储顺序。主要有两种字节序：</p>
<p>（1）大端字节序（Big-Endian）：高位字节存储在内存的低地址处，低位字节存储在高地址处。这种字节序遵循自然数字的书写习惯，也被称为网络字节序（Network Byte Order）或网络标准字节序，因为它在网络通信中被广泛采用，如IP协议就要求使用大端字节序。</p>
<p>（2）小端字节序（Little-Endian）：低位字节存储在内存的低地址处，高位字节存储在高地址处。这是Intel x86-64架构以及其他一些现代处理器普遍采用的字节序，称为主机字节序（Host Byte Order）。</p>
<p><strong>2）</strong><em><strong>*相关函数*</strong></em></p>
<p>（1）使用man 3 htonl可得</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将无符号整数 hostlong 从主机字节顺序（h）转换为网络字节顺序（n）。</p>
<p> *&#x2F;</p>
<p>uint32_t htonl(uint32_t hostlong);</p>
<p>&#x2F;**</p>
<p> * @brief 将无符号短整数 hostshort 从主机字节顺序（h）转换为网络字节顺序（n）。</p>
<p> *&#x2F;</p>
<p>uint16_t htons(uint16_t hostshort);</p>
<p>&#x2F;**</p>
<p> * @brief 将无符号整数 netlong 从网络字节顺序（n）转换为主机字节顺序（h）。</p>
<p> *&#x2F;</p>
<p>uint32_t ntohl(uint32_t netlong);</p>
<p>&#x2F;**</p>
<p> * @brief 将无符号短整数 netshort 从网络字节顺序（n）转换为主机字节顺序（h）。</p>
<p> *&#x2F;</p>
<p>uint16_t ntohs(uint16_t netshort);</p>
<p>在网络通信中，为了让不同字节序的主机能够相互理解对方的数据，常常需要进行字节序转换。例如，发送数据前需要将主机字节序转换为网络字节序，接收数据后则需要将网络字节序转换为主机字节序。例如，如果你有一个IP地址或端口号（通常存储为整数）需要在网络上传输，就需要先使用htons()或htonl()将其转换为网络字节序，然后在网络另一端接收时，使用ntohs()或ntohl()将其转换回主机字节序。这样可以确保数据在网络中的传输不受不同主机字节序的影响。</p>
<p>笔者用于测试的PC架构是x86-64，因此主机字节序为小端字节序。网络字节序为大端字节序。</p>
<p>（2）使用man 3 inet_aton可得</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将来自 IPv4 点分十进制表示法的 Internet 主机地址 cp 转换为二进制形式（以网络字节顺序）并将其存储在 inp 指向的结构体中。</p>
<p> * @return int 成功返回 1;失败 返回 0</p>
<p> *&#x2F;</p>
<p>int inet_aton(const char *cp, struct in_addr *inp);</p>
<p>&#x2F;**</p>
<p> * @brief 将来自 IPv4 点分十进制表示法的 Internet 主机地址 cp 转换为网络字节顺序的二进制数据。</p>
<p> * @return 如果输入无效，则返回 INADDR_NONE（通常为 -1）。使用此函数存在问题，因为 -1 是一个有效地址（255.255.255.255）。请优先使用 inet_aton()、inet_pton(3) 或 getaddrinfo(3)，它们提供了更清晰的错误返回方式。</p>
<p> *&#x2F;</p>
<p>in_addr_t inet_addr(const char *cp);</p>
<p>&#x2F;**</p>
<p> * @brief 函数将字符串 cp（以 IPv4 点分十进制表示法表示）转换为适合用作 Internet 网络地址的主机字节顺序中的数字。</p>
<p> * @return in_addr_t 成功时，返回转换后的地址。如果输入无效，则返回 -1。</p>
<p> *&#x2F;</p>
<p>in_addr_t inet_network(const char *cp);</p>
<p>&#x2F;* @brief  字符串格式转换为sockaddr_in格式</p>
<p>  @param int af: 通常为 AF_INET 用于IPv4地址，或 AF_INET6 用于IPv6地址</p>
<p>  @param char *src: 包含IP地址字符串的字符数组，如果是IPv4地址，格式为点分十进制（如 “192.168.1.1”）；如果是IPv6地址，格式为冒号分隔的十六进制表示（如 “2001:0db8:85a3:0000:0000:8a2e:0370:7334”）</p>
<p>  @param void *dst：指向一个足够大的缓冲区（对于IPv4是一个struct in_addr结构体，对于IPv6是一个struct in6_addr结构体），用于存储转换后的二进制IP地址</p>
<p>  @return int : 成功转换返回0; 输入地址错误返回1;发生错误返回-1</p>
<p>*&#x2F;</p>
<p>int inet_pton(int af, const char *src, void *dst);</p>
<p>&#x2F;**</p>
<p> * @brief </p>
<p> * </p>
<p> * @param in 将以网络字节顺序给出的 Internet 主机地址 in 转换为 IPv4 点分十进制表示法的字符串。字符串存储在静态分配的缓冲区中，后续调用将覆盖该缓冲区。</p>
<p> * @return char* 缓冲区指针</p>
<p> *&#x2F;</p>
<p>char *inet_ntoa(struct in_addr in);</p>
<p>&#x2F;**</p>
<p> * @brief 是 inet_netof() 和 inet_lnaof() 的反函数。它返回一个以网络字节顺序表示的 Internet 主机地址，由主机字节顺序中的网络号 net 和本地地址 host 组成。</p>
<p> *&#x2F;</p>
<p>struct in_addr inet_makeaddr(in_addr_t net, in_addr_t host);</p>
<p>&#x2F;**</p>
<p> * @brief 返回 Internet 地址 in 的本地网络地址部分。返回的值以主机字节顺序表示。</p>
<p> *&#x2F;</p>
<p>in_addr_t inet_lnaof(struct in_addr in);</p>
<p>&#x2F;**</p>
<p> * @brief 返回 Internet 地址 in 的网络号部分。返回的值以主机字节顺序表示。</p>
<p> *&#x2F;</p>
<p>in_addr_t inet_netof(struct in_addr in);</p>
<p><strong>3）</strong><em><strong>*测试例程*</strong></em></p>
<p>（1）创建num_endianess_convert.c</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  &#x2F;&#x2F;网络地址赋值</p>
<p>  unsigned short local_num &#x3D; 0x1F, network_num &#x3D; 0;</p>
<p>  network_num &#x3D; htons(local_num);</p>
<p>  printf(“将主机字节序的无符号整数: 0x%hX 转换为网络字节序的结果为: 0x%hX\n”, local_num, network_num);</p>
<p>  local_num &#x3D; ntohs(network_num);</p>
<p>  printf(“将网络字节序的无符号整数: 0x%hX 转换为主机字节序的结果为: 0x%hX\n”, network_num, local_num);</p>
<p>  return 0;</p>
<p>}</p>
<p>（2）创建Makefile，写入以下内容</p>
<p>CC:&#x3D;gcc</p>
<p>num_endianess_convert: num_endianess_convert.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（3）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps158.jpg" alt="img"> </p>
<p>可以看到，大端序和小端序的转换是以字节为单位进行的。</p>
<p>（4）创建inet_endian_convert.c</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  &#x2F;&#x2F; 网络地址赋值</p>
<p>  struct sockaddr_in server_addr;</p>
<p>  struct in_addr server_in_addr;</p>
<p>  in_addr_t server_in_addr_t;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;server_in_addr, 0, sizeof(server_in_addr));</p>
<p>  memset(&amp;server_in_addr_t, 0, sizeof(server_in_addr_t));</p>
<p>  &#x2F;&#x2F; 打印16进制IP地址作为对照</p>
<p>  printf(“192.168.6.101 的16进制表示为 0x%X 0x%X 0x%X 0x%X\n”, 192, 168, 6, 101);</p>
<p>  &#x2F;&#x2F; 不推荐使用,因为输入-1返回的地址是一个有效地址（255.255.255.255）</p>
<p>  server_in_addr_t &#x3D; inet_addr(“192.168.6.101”);</p>
<p>  printf(“inet_addr convert: 0x%X\n”, server_in_addr_t);</p>
<p>  inet_aton(“192.168.6.101”, &amp;server_in_addr);</p>
<p>  printf(“inet_aton convert: 0x%X\n”, server_in_addr.s_addr);</p>
<p>  &#x2F;&#x2F; 推荐使用</p>
<p>  &#x2F;&#x2F; 字符串转sockin_addr结构体</p>
<p>  inet_pton(AF_INET, “192.168.6.101”, &amp;server_addr.sin_addr);</p>
<p>  printf(“inet_pton 后 server_addr.sin_addr 的16进制表示为 0x%X\n”, server_addr.sin_addr.s_addr);</p>
<p>  &#x2F;&#x2F; 结构体转化为字符串</p>
<p>  printf(“通过inet_ntoa打印inet_pton转化后的地址: %s\n”, inet_ntoa(server_addr.sin_addr));</p>
<p>  &#x2F;&#x2F; 打印本地网络地址部分</p>
<p>  printf(“local net section: 0x%X\n”, inet_lnaof(server_addr.sin_addr));</p>
<p>  &#x2F;&#x2F; 打印网络号部分</p>
<p>  printf(“netword number section: 0x%X\n”, inet_netof(server_addr.sin_addr));</p>
<p>  &#x2F;&#x2F; 使用本地网络地址和网络号可以拼接成in_addr</p>
<p>  server_addr.sin_addr &#x3D; inet_makeaddr(inet_netof(server_addr.sin_addr), 102);</p>
<p>  &#x2F;&#x2F; 以网络字节序16进制打印拼接的地址</p>
<p>  printf(“inet_makeaddr: 0x%X\n”, server_addr.sin_addr.s_addr);</p>
<p>  &#x2F;&#x2F; 打印拼接的地址</p>
<p>  printf(“通过inet_ntoa打印inet_makeaddr拼接后的地址%s\n”, inet_ntoa(server_addr.sin_addr));</p>
<p>  return 0;</p>
<p>}</p>
<p>（5）Makefile</p>
<p>inet_endian_convert: inet_endian_convert.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>（6）运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps159.jpg" alt="img"> </p>
<h3 id="6-4-传输层-基于TCP协议的程序"><a href="#6-4-传输层-基于TCP协议的程序" class="headerlink" title="6.4 传输层-基于TCP协议的程序"></a>6.4 <strong>传输层-基于TCP协议的程序</strong></h3><h4 id="6-4-1-只接受一个连接的范例程序"><a href="#6-4-1-只接受一个连接的范例程序" class="headerlink" title="6.4.1 只接受一个连接的范例程序"></a>6.4.1 <strong>只接受一个连接的范例程序</strong></h4><p>为便于分析连接建立及销毁过程，本例程仅支持同时建立单个TCP连接。</p>
<p><strong>1）</strong><em><strong>*服务端（single_conn_*</strong></em><em><strong>*server.c*</strong></em><em><strong>*）*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>void *read_from_client(void *argv)</p>
<p>{</p>
<p>  int client_fd &#x3D; *(int *)argv;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  ssize_t count &#x3D; 0;</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    perror(“malloc server read_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while ((count &#x3D; recv(client_fd, read_buf, 1024, 0)))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“recv”);</p>
<p>​    }</p>
<p>​    fputs(read_buf, stdout);</p>
<p>  }</p>
<p>  printf(“客户端请求关闭连接……\n”);</p>
<p>  free(read_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>void *write_to_client(void *argv)</p>
<p>{</p>
<p>  int client_fd &#x3D; *(int *)argv;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  ssize_t send_count &#x3D; 0;</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“写缓存分配失败，断开连接\n”);</p>
<p>​    shutdown(client_fd, SHUT_WR);</p>
<p>​    perror(“malloc server write_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (fgets(write_buf, 1024, stdin) !&#x3D; NULL)</p>
<p>  {</p>
<p>​    send_count &#x3D; send(client_fd, write_buf, 1024, 0);</p>
<p>​    if (send_count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“send”);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“接收到命令行的终止信号，不再写入，关闭连接……\n”);</p>
<p>  shutdown(client_fd, SHUT_WR);</p>
<p>  free(write_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result, client_fd;</p>
<p>  pthread_t pid_read, pid_write;</p>
<p>  struct sockaddr_in server_addr, client_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;client_addr, 0, sizeof(client_addr));</p>
<p>  &#x2F;&#x2F; 声明IPV4通信协议</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 我们需要绑定0.0.0.0地址，转换成网络字节序后完成设置</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</p>
<p>  &#x2F;&#x2F; 端口随便用一个，但是不要用特权端口</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建server socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 绑定地址</p>
<p>  temp_result &#x3D; bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“bind”, temp_result);</p>
<p>  &#x2F;&#x2F; 进入监听模式</p>
<p>  temp_result &#x3D; listen(sockfd, 128);</p>
<p>  handle_error(“listen”, temp_result);</p>
<p>  &#x2F;&#x2F; 接受第一个client连接</p>
<p>  socklen_t cliaddr_len &#x3D; sizeof(client_addr);</p>
<p>  client_fd &#x3D; accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;cliaddr_len);</p>
<p>  handle_error(“accept”, client_fd);</p>
<p>  printf(“与客户端 from %s at PORT %d 文件描述符 %d 建立连接\n”,</p>
<p>​      inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), client_fd);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来读取客户端数据，并打印到 stdout</p>
<p>  pthread_create(&amp;pid_read, NULL, read_from_client, (void *)&amp;client_fd);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来从命令行读取数据并发送到客户端</p>
<p>  pthread_create(&amp;pid_write, NULL, write_to_client, (void *)&amp;client_fd);</p>
<p>  &#x2F;&#x2F; 阻塞主线程</p>
<p>  pthread_join(pid_read, NULL);</p>
<p>  pthread_join(pid_write, NULL);</p>
<p>  printf(“释放资源\n”);</p>
<p>  close(client_fd);</p>
<p>  close(sockfd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*客户端（single_conn_client*</strong></em><em><strong>*.c*</strong></em><em><strong>*）*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>&#x2F;&#x2F; 192.168.10.150 IP 地址的16进制表示</p>
<p>#define INADDR_LOCAL 0xC0A80A96</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>void *read_from_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  ssize_t count &#x3D; 0;</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    perror(“malloc client read_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (count &#x3D; recv(sockfd, read_buf, 1024, 0))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“recv”);</p>
<p>​    }</p>
<p>​    fputs(read_buf, stdout);</p>
<p>  }</p>
<p>  printf(“收到服务端的终止信号……\n”);</p>
<p>  free(read_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>void *write_to_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  ssize_t send_count &#x3D; 0;</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“写缓存分配失败，断开连接\n”);</p>
<p>​    shutdown(sockfd, SHUT_WR);</p>
<p>​    perror(“malloc client write_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (fgets(write_buf, 1024, stdin) !&#x3D; NULL)</p>
<p>  {</p>
<p>​    send_count &#x3D; send(sockfd, write_buf, 1024, 0);</p>
<p>​    if (send_count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“send”);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“接收到命令行的终止信号，不再写入，关闭连接……\n”);</p>
<p>  shutdown(sockfd, SHUT_WR);</p>
<p>  free(write_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result;</p>
<p>  pthread_t pid_read, pid_write;</p>
<p>  struct sockaddr_in server_addr, client_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;client_addr, 0, sizeof(client_addr));</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 连接本机 127.0.0.1</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_LOOPBACK);</p>
<p>  &#x2F;&#x2F; 连接端口 6666</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  client_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 连接本机 192.168.10.150</p>
<p>  client_addr.sin_addr.s_addr &#x3D; htonl(INADDR_LOCAL);</p>
<p>  &#x2F;&#x2F; 连接端口 8888</p>
<p>  client_addr.sin_port &#x3D; htons(8888);</p>
<p>  &#x2F;&#x2F; 创建socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  temp_result &#x3D; bind(sockfd, (struct sockaddr *)&amp;client_addr, sizeof(client_addr));</p>
<p>  handle_error(“bind”, temp_result);</p>
<p>  &#x2F;&#x2F; 连接server</p>
<p>  temp_result &#x3D; connect(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“connect”, temp_result);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来读取服务端数据，并打印到 stdout</p>
<p>  pthread_create(&amp;pid_read, NULL, read_from_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来从命令行读取数据并发送到服务端</p>
<p>  pthread_create(&amp;pid_write, NULL, write_to_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 阻塞主线程</p>
<p>  pthread_join(pid_read, NULL);</p>
<p>  pthread_join(pid_write, NULL);</p>
<p>  printf(“关闭资源\n”);</p>
<p>  close(sockfd);</p>
<p>  return 0;</p>
<p>}</p>
<p>在上述例程中，我们将客户端绑定到了192.168.10.150的8888端口，192.168.10.150实际上是本机IP，此处等价于localhost或127.0.0.1。此外，通常服务端不需要绑定到具体的IP和端口，如果不绑定，启动后会操作系统会随机为客户端分配本机的某个端口。我们这里将客户端绑定至指定的IP和端口，主要是为了在分析时便于区分客户端和服务端，实际的客户端程序完全可以省去这一步。</p>
<p><strong>3）</strong><em><strong>*编译并测试*</strong></em></p>
<p>（1）Makefile</p>
<p>在Makefile开头补充伪目标定义和变量定义</p>
<p>.PHONY: single_conn single_conn_clean</p>
<p>single_conn_executables:&#x3D;single_conn_server single_conn_client</p>
<p>Makefile末尾补充目标声明</p>
<p>single_conn_server: single_conn_server.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>single_conn_client: single_conn_client.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>single_conn: $(single_conn_executables)</p>
<p>single_conn_clean:</p>
<p>  -rm .&#x2F;$(word 1, $(single_conn_executables)) .&#x2F;$(word 2, $(single_conn_executables))</p>
<p>（2）测试</p>
<p>通过Makefile编译后，执行以下操作。</p>
<p>① 开启两个XShell标签页，然后“垂直排列”</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps160.jpg" alt="img"> </p>
<p>效果如下</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps161.jpg" alt="img"> </p>
<p>② 分别在两个窗口中开启服务端和客户端</p>
<p>先开服务端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps162.jpg" alt="img"> </p>
<p>再开客户端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps163.jpg" alt="img"> </p>
<p>④ 服务端向客户端发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps164.jpg" alt="img"> </p>
<p>⑤ 客户端向服务端发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps165.jpg" alt="img"> </p>
<p>⑥ 在客户端窗口按下Ctrl+D，断开连接</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps166.jpg" alt="img"> </p>
<p>⑦ 在服务端按下Ctrl+D，断开连接</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps167.jpg" alt="img"> </p>
<h4 id="6-4-2-关于缓冲区的补充说明"><a href="#6-4-2-关于缓冲区的补充说明" class="headerlink" title="6.4.2 关于缓冲区的补充说明"></a>6.4.2 <strong>关于缓冲区的补充说明</strong></h4><p><strong>1）</strong><em><strong>*进程的I&#x2F;O缓冲区*</strong></em></p>
<p>进程的缓冲区机制是一种中间存储技术，用于在数据处理和传输中暂存数据。对于提高计算效率、优化资源利用、以及确保数据在处理和传输过程中的稳定性和可靠性至关重要。</p>
<p>进程的I&#x2F;O缓冲区用于文件读写或通过标准输入输出与终端交互。分为输入缓冲区和输出缓冲区。</p>
<p>（1）输入缓冲区存储从文件或其他外部源接收的数据，直到进程准备好处理它。</p>
<p>（2）输出缓冲区暂存要发送到外部设备或系统的数据，直到能够执行写操作。</p>
<p><strong>2）</strong><em><strong>*网络编程中的缓冲区*</strong></em></p>
<p>网络编程中，尤其是使用socket通信时，内核会在内核空间维护网络缓冲区，它也分为输入输出缓冲区。与I&#x2F;O缓冲区不同，网络缓冲区的管理是由内核来完成的，用户无法干预。当然，用户可以在应用程序中通过在堆空间动态分配内存的方式构建额外的缓冲区。</p>
<p>（1）数据接收</p>
<p>当网络数据到达网络接口（如以太网卡）时，数据首先被操作系统的网络驱动接收。操作系统会将这些数据存储在内核空间的接收缓冲区中。应用程序之后通过读取系统调用（如recv或read），从内核空间的缓冲区中获取这些数据。</p>
<p>（2）数据发送</p>
<p>当应用程序想要发送数据时，它通过写入系统调用（如send或write）将数据传递给内核。内核将这些数据存放在内核空间的发送缓冲区中，然后根据网络协议的需要适时将数据发送到网络上。</p>
<p><strong>3）</strong><em><strong>*进程的缓冲模式*</strong></em></p>
<p>进程在执行I&#x2F;O操作时，可以有以下三种类型的缓冲模式。</p>
<p>（1）行缓冲（Line Buffering）</p>
<p>在这种模式下，碰到换行符或缓冲区已满时刷写到目标文件。</p>
<p>行缓冲通常用于标准输出（stdout），尤其是当标准输出关联到终端（控制台）时。这样做可以确保用户每输入一行命令就能看到响应的输出，而不必等到缓冲区完全填满。</p>
<p>（2）全缓冲（Fully Buffering）</p>
<p>在全缓冲模式下，数据只会在缓冲区满时刷新，这意味着数据被存储在缓冲区直到缓冲区被填满，然后整个缓冲区的内容一次性刷写。</p>
<p>通常向文件写数据的默认模式就是全缓冲，这样可以减少对底层系统资源的调用次数，提高数据处理效率。</p>
<p>（3）无缓冲（No Buffering）</p>
<p>无缓冲模式意味着数据直接刷写，不经过缓冲区。</p>
<p>标准错误（stderr）通常是无缓冲的，以确保错误信息能够立即输出。</p>
<p>（4）设置缓冲模式</p>
<p>在C语言中，可以通过调用setvbuf()函数来设置文件流的缓冲模式。</p>
<p><strong>4）</strong><em><strong>*相关函数*</strong></em></p>
<p>（1）setvbuf()</p>
<p>#include &lt;stdio.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 设置文件流的缓冲模式</p>
<p> * </p>
<p> * @param stream 要设置的文件流，可以是输入缓冲流也可以是输出缓冲流</p>
<p> * @param buf 指向缓冲区的指针，这个参数为NULL则自动分配缓冲区。</p>
<p> * @param mode 缓冲区模式</p>
<p> *     _IOFBF：全缓冲，数据会存储在缓冲区中直到缓冲区满。</p>
<p> *     _IOLBF：行缓冲，数据会存储在缓冲区中直到碰到换行符或缓冲区满。</p>
<p> *     _IONBF：无缓冲，输出操作将直接从调用进程到目标设备，不经过缓冲区。</p>
<p> * @param size 缓冲区大小，以字节为单位。size为0时，</p>
<p> *     如果buf为NULL，则标准C库将为该文件流自动分配一个默认大小的缓冲区</p>
<p> *     如果buf不为NULL，将size设置为0不合逻辑，行为是未定义的</p>
<p> * @return int 成功返回0，失败返回非零值</p>
<p> *&#x2F;</p>
<p>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</p>
<p>（2）fflush()</p>
<p>#include &lt;stdio.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 刷新一个流，如果是输出流，强制将用户空间所有缓冲的数据输出到下游设备或目标文件</p>
<p> *          如果是输入流，若是与可寻址文件关联的输入流（不包含管道和终端），丢弃缓冲区未被应用消费的数据</p>
<p> *                 对管道和终端关联的输入流执行fflush()通常不会有任何效果</p>
<p> *     fflush() 主要是用来处理输出流的</p>
<p> * @param stream 待刷新的数据流，如果为NULL，则刷新所有打开的输出流。</p>
<p> * @return int 成功返回0.失败返回EOF，并设置errno</p>
<p> *&#x2F;</p>
<p>int fflush(FILE *stream);</p>
<p><strong>5）</strong><em><strong>*案例*</strong></em></p>
<p>（1）写文件设置无缓冲模式</p>
<p>① 创建without_buf_test.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>int main() {</p>
<p>  FILE *file &#x3D; fopen(“&#x2F;home&#x2F;atguigu&#x2F;socket_test&#x2F;testfile.txt”, “w”);</p>
<p>  if (file &#x3D;&#x3D; NULL) {</p>
<p>​    perror(“Failed to open file”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 设置文件为行缓冲模式</p>
<p>  if (setvbuf(file, NULL, _IONBF, 0) !&#x3D; 0) {</p>
<p>​    perror(“Failed to set buffer mode”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  fprintf(file, “hello”);</p>
<p>  char *argv[] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;ping”, “-c”, “1”, “<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>“, NULL};</p>
<p>  char *envp[] &#x3D; {NULL};</p>
<p>  execve(“&#x2F;usr&#x2F;bin&#x2F;ping”, argv, envp);</p>
<p>  perror(“execve”);</p>
<p>  return 0;</p>
<p>}</p>
<p>上述代码中，我们将file设置为无缓冲模式，数据被立即写入testfile.txt。</p>
<p>② Makefile</p>
<p>without_buf_test: without_buf_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps168.jpg" alt="img"> </p>
<p>（2）写文件设置行缓冲模式</p>
<p>清空testfile.txt。</p>
<p>① 创建line_buf_test.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>int main() {</p>
<p>  FILE *file &#x3D; fopen(“&#x2F;home&#x2F;atguigu&#x2F;socket_test&#x2F;testfile.txt”, “w”);</p>
<p>  if (file &#x3D;&#x3D; NULL) {</p>
<p>​    perror(“Failed to open file”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 设置文件为行缓冲模式</p>
<p>  if (setvbuf(file, NULL, _IOLBF, 0) !&#x3D; 0) {</p>
<p>​    perror(“Failed to set buffer mode”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  fprintf(file, “hello”);</p>
<p>  char *argv[] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;ping”, “-c”, “1”, “<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>“, NULL};</p>
<p>  char *envp[] &#x3D; {NULL};</p>
<p>  execve(“&#x2F;usr&#x2F;bin&#x2F;ping”, argv, envp);</p>
<p>  perror(“execve”);</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>line_buf_test: line_buf_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps169.jpg" alt="img"> </p>
<p>此时testfile.txt为空，因为我们没有写入换行符。</p>
<p>（3）行缓冲模式数据末尾有换行符</p>
<p>① 创建line_buf_with_enter_test.c</p>
<p>在上述案例的基础上，在hello后面添加换行符\n。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>int main() {</p>
<p>  FILE *file &#x3D; fopen(“&#x2F;home&#x2F;atguigu&#x2F;socket_test&#x2F;testfile.txt”, “w”);</p>
<p>  if (file &#x3D;&#x3D; NULL) {</p>
<p>​    perror(“Failed to open file”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 设置文件为行缓冲模式</p>
<p>  if (setvbuf(file, NULL, _IOLBF, 0) !&#x3D; 0) {</p>
<p>​    perror(“Failed to set buffer mode”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  fprintf(file, “hello\n”);</p>
<p>  char *argv[] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;ping”, “-c”, “1”, “<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>“, NULL};</p>
<p>  char *envp[] &#x3D; {NULL};</p>
<p>  execve(“&#x2F;usr&#x2F;bin&#x2F;ping”, argv, envp);</p>
<p>  perror(“execve”);</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>line_buf_with_enter_test: line_buf_with_enter_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps170.jpg" alt="img"> </p>
<p>testfile.txt会写入hello和换行符。</p>
<p>（4）写文件设置全缓冲模式</p>
<p>清空testfile.txt。</p>
<p>① 创建full_buf_test.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>int main() {</p>
<p>  FILE *file &#x3D; fopen(“&#x2F;home&#x2F;atguigu&#x2F;socket_test&#x2F;testfile.txt”, “w”);</p>
<p>  if (file &#x3D;&#x3D; NULL) {</p>
<p>​    perror(“Failed to open file”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 设置文件为全缓冲模式</p>
<p>  if (setvbuf(file, NULL, _IOFBF, 0) !&#x3D; 0) {</p>
<p>​    perror(“Failed to set buffer mode”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  fprintf(file, “hello\n”);</p>
<p>  char *argv[] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;ping”, “-c”, “1”, “<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>“, NULL};</p>
<p>  char *envp[] &#x3D; {NULL};</p>
<p>  execve(“&#x2F;usr&#x2F;bin&#x2F;ping”, argv, envp);</p>
<p>  perror(“execve”);</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>full_buf_test: full_buf_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps171.jpg" alt="img"> </p>
<p>此时testfile.txt为空，因为设置了全缓冲模式，即便有换行符也不会触发刷写操作。</p>
<p>（5）全缓冲模式下手动触发刷写操作</p>
<p>① 创建full_buf_fflush_test.c</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>int main() {</p>
<p>  FILE *file &#x3D; fopen(“&#x2F;home&#x2F;atguigu&#x2F;socket_test&#x2F;testfile.txt”, “w”);</p>
<p>  if (file &#x3D;&#x3D; NULL) {</p>
<p>​    perror(“Failed to open file”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 设置文件为全缓冲模式</p>
<p>  if (setvbuf(file, NULL, _IOFBF, 0) !&#x3D; 0) {</p>
<p>​    perror(“Failed to set buffer mode”);</p>
<p>​    return 1;</p>
<p>  }</p>
<p>  fprintf(file, “hello\n”);</p>
<p>  fflush(file);</p>
<p>  char *argv[] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;ping”, “-c”, “1”, “<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>“, NULL};</p>
<p>  char *envp[] &#x3D; {NULL};</p>
<p>  execve(“&#x2F;usr&#x2F;bin&#x2F;ping”, argv, envp);</p>
<p>  perror(“execve”);</p>
<p>  return 0;</p>
<p>}</p>
<p>② Makefile</p>
<p>full_buf_fflush_test: full_buf_fflush_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p>③ 运行</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps172.jpg" alt="img"> </p>
<p>添加了fflush()，即便设置为全缓冲模式，hello\n也会被刷写入目标文件，此时testfile.txt中可以看到hello和换行。</p>
<h4 id="6-4-3-连接建立及断开过程分析"><a href="#6-4-3-连接建立及断开过程分析" class="headerlink" title="6.4.3 连接建立及断开过程分析"></a>6.4.3 <strong>连接建立及断开过程分析</strong></h4><p><strong>1）</strong><em><strong>*命令行查看TCP进程*</strong></em></p>
<p>我们可以通过netstat命令查看当前计算机中正在运行的TCP进程。</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ sudo netstat -tanlp</p>
<p>上述命令可以列出当前主机中所有活跃的TCP进程。</p>
<p>Ø -t：仅显示TCP连接。</p>
<p>Ø -a：显示所有套接字。</p>
<p>Ø -n：以数字形式显示地址和端口号，不尝试解析名称。</p>
<p>Ø -l：显示正在监听的服务端口。</p>
<p>Ø -p：显示监听某端口的进程的PID和名称。</p>
<p>效果如下。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps173.jpg" alt="img"> </p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ sudo netstat -tanlp | grep 8888</p>
<p>启动上面的客户端和服务端，执行上述命令，我们可以根据端口号筛选相关进程。</p>
<p>效果如下：</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps174.jpg" alt="img"> </p>
<p><strong>2）</strong><em><strong>*分析*</strong></em></p>
<p>（1）安装wireshark</p>
<p>wireshar是一个抓包工具，可以捕获基于TCP客户端和服务端发送的报文段。</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ sudo apt install wireshark</p>
<p>（2）打开wireshark</p>
<p>wireshark有图形化界面，XShell不支持。在VM Ware中开启终端，输入以下命令打开wireshark。</p>
<p>atguigu@ubuntu:~$ sudo wireshark</p>
<p>双击Loopback：lo打开回环网卡的监控页面</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps175.jpg" alt="img"> </p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps176.jpg" alt="img"> </p>
<p>（3）配置过滤条件</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps177.jpg" alt="img"> </p>
<p>在wireshark页面上方的对话框中输入“tcp”后回车，表示仅抓取基于TCP协议通讯的报文段，如上图所示。</p>
<p>（4）启动服务端</p>
<p>启动服务端后，查看wrieshark监控页面的报文段</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps178.jpg" alt="img"> </p>
<p>启动服务端，连接尚未建立，所以wireshark不会抓到报文段</p>
<p>（5）启动客户端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps179.jpg" alt="img"> </p>
<p>① 查看wireshark监控页面</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps180.jpg" alt="img"> </p>
<p>可以清晰地看到三次握手的过程，客户端首先发送SYN标志为1的报文段请求连接，然后服务端返回SYN及ACK标志均为1的报文段做应答，最后客户端发回ACK为1的报文段应答服务端，三次握手完成，TCP连接建立成功。</p>
<p>② 通过命令行查看</p>
<p>再开启一个XShell标签页，执行以下命令</p>
<p>atguigu@ubuntu:~&#x2F;helloworld$ sudo netstat -tanlp | grep 8888</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps181.jpg" alt="img"> </p>
<p>可以看到，客户端与服务端均处于ESTABLISHED状态，连接已建立，准备好发送数据。</p>
<p>（6）收发数据测试</p>
<p>① 客户端和服务端分别向对方发送一条数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps182.jpg" alt="img"> </p>
<p>② 查看wireshark监控页面</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps183.jpg" alt="img"> </p>
<p>可以看到两组报文段，分别为“服务端发送，客户端响应”以及“客户端发送，服务端响应”。</p>
<p>③ 查看客户端和服务端状态</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps184.jpg" alt="img"> </p>
<p>状态不变。</p>
<p>（7）客户端通过Ctrl+D发送终止信号</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps185.jpg" alt="img"> </p>
<p>① 查看wireshark</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps186.jpg" alt="img"> </p>
<p>② 此时客户端无法继续发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps187.jpg" alt="img"> </p>
<p>所有从stdin输入的数据都会被丢弃。</p>
<p>③ 服务端仍可发送数据，客户端仍可接收</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps188.jpg" alt="img"> </p>
<p>④ 查看wireshark</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps189.jpg" alt="img"> </p>
<p>⑤ 查看客户端和服务端状态</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps190.jpg" alt="img"> </p>
<p>此时，服务端处于CLOSE_WAIT状态，客户端处于FIN-WAIT2状态。</p>
<p>第一次挥手之后，内核控制被动关闭的一方立即响应，因此FIN-WAIT1持续时间极短，基本无法通过上述方式看到这个状态。</p>
<p>（8）服务端通过Ctrl+D发送终止信号</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps191.jpg" alt="img"> </p>
<p>① 查看wireshark</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps192.jpg" alt="img"> </p>
<p>② 查看客户端和服务端状态</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps193.jpg" alt="img"> </p>
<p>服务端资源已释放，看不到相关信息，客户端进入TIME_WAIT状态，持续时间为2MSL。之后客户端资源也会释放。</p>
<h4 id="6-4-4-服务端基于多线程的支持多个连接的范例程序"><a href="#6-4-4-服务端基于多线程的支持多个连接的范例程序" class="headerlink" title="6.4.4 服务端基于多线程的支持多个连接的范例程序"></a>6.4.4 <strong>服务端基于多线程的支持多个连接的范例程序</strong></h4><p><strong>1）</strong><em><strong>*服务端（multi_conn_threads_server.c）*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>void *read_from_client_then_write(void *argv)</p>
<p>{</p>
<p>  int client_fd &#x3D; *(int *)argv;</p>
<p>  ssize_t count &#x3D; 0, send_count &#x3D; 0;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    printf(“服务端读缓存创建异常，断开连接\n”);</p>
<p>​    shutdown(client_fd, SHUT_WR);</p>
<p>​    close(client_fd);</p>
<p>​    perror(“malloc sever read_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“服务端写缓存创建异常，断开连接\n”);</p>
<p>​    free(read_buf);</p>
<p>​    shutdown(client_fd, SHUT_WR);</p>
<p>​    close(client_fd);</p>
<p>​    perror(“malloc server write_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while ((count &#x3D; recv(client_fd, read_buf, 1024, 0)))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“recv”);</p>
<p>​    }</p>
<p>​    printf(“reveive message from client_fd: %d: %s\n”, client_fd, read_buf);</p>
<p>​    strcpy(write_buf, “reveived~\n”);</p>
<p>​    send_count &#x3D; send(client_fd, write_buf, 1024, 0);</p>
<p>​    if (send_count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“send”);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“客户端client_fd: %d请求关闭连接……\n”, client_fd);</p>
<p>  strcpy(write_buf, “receive your shutdown signal\n”);</p>
<p>  send_count &#x3D; send(client_fd, write_buf, 1024, 0);</p>
<p>  if (send_count &lt; 0)</p>
<p>  {</p>
<p>​    perror(“send”);</p>
<p>  }</p>
<p>  printf(“释放client_fd: %d资源\n”, client_fd);</p>
<p>  shutdown(client_fd, SHUT_WR);</p>
<p>  close(client_fd);</p>
<p>  free(read_buf);</p>
<p>  free(write_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result;</p>
<p>  struct sockaddr_in server_addr, client_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;client_addr, 0, sizeof(client_addr));</p>
<p>  &#x2F;&#x2F; 声明IPV4通信协议</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 我们需要绑定0.0.0.0地址，转换成网络字节序后完成设置</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</p>
<p>  &#x2F;&#x2F; 端口随便用一个，但是不要用特权端口</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建server socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 绑定地址</p>
<p>  temp_result &#x3D; bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“bind”, temp_result);</p>
<p>  &#x2F;&#x2F; 进入监听模式</p>
<p>  temp_result &#x3D; listen(sockfd, 128);</p>
<p>  handle_error(“listen”, temp_result);</p>
<p>  socklen_t cliaddr_len &#x3D; sizeof(client_addr);</p>
<p>  &#x2F;&#x2F; 接受client连接</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    int client_fd &#x3D; accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;cliaddr_len);</p>
<p>​    handle_error(“accept”, client_fd);</p>
<p>​    printf(“与客户端 from %s at PORT %d 文件描述符 %d 建立连接\n”,</p>
<p>​        inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), client_fd);</p>
<p>​    pthread_t pid_read_write;</p>
<p>​    &#x2F;&#x2F; 启动一个子线程，用来读取客户端数据，并打印到 stdout</p>
<p>​    &#x2F;&#x2F; 要注意，此处的pid_read_write并不是线程ID，而是用于线程处理函数的标识符</p>
<p>​    if (pthread_create(&amp;pid_read_write, NULL, read_from_client_then_write, (void *)&amp;client_fd))</p>
<p>​    {</p>
<p>​      perror(“pthread_create”);</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 将子线程处理为detached状态，使其终止时自动回收资源，同时不阻塞主线程</p>
<p>​    pthread_detach(pid_read_write);</p>
<p>​    printf(“创建子线程并处理为detached状态\n”);</p>
<p>  }</p>
<p>  printf(“释放资源\n”);</p>
<p>  close(sockfd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*客户端（multi_conn_threads_client.c）*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>void *read_from_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  ssize_t count &#x3D; 0;</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    perror(“malloc client read_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (count &#x3D; recv(sockfd, read_buf, 1024, 0))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“recv”);</p>
<p>​    }</p>
<p>​    fputs(read_buf, stdout);</p>
<p>  }</p>
<p>  printf(“收到服务端的终止信号……\n”);</p>
<p>  free(read_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>void *write_to_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  ssize_t send_count;</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“写缓存申请异常，断开连接\n”);</p>
<p>​    shutdown(sockfd, SHUT_WR);</p>
<p>​    perror(“malloc client write_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (fgets(write_buf, 1024, stdin) !&#x3D; NULL)</p>
<p>  {</p>
<p>​    send(sockfd, write_buf, 1024, 0);</p>
<p>​    if (send_count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“send”);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“接收到命令行的终止信号，不再写入，关闭连接……\n”);</p>
<p>  shutdown(sockfd, SHUT_WR);</p>
<p>  free(write_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result;</p>
<p>  pthread_t pid_read, pid_write;</p>
<p>  struct sockaddr_in server_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 连接本机 127.0.0.1</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_LOOPBACK);</p>
<p>  &#x2F;&#x2F; 连接端口 6666</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 连接server</p>
<p>  temp_result &#x3D; connect(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“connect”, temp_result);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来读取服务端数据，并打印到 stdout</p>
<p>  pthread_create(&amp;pid_read, NULL, read_from_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来从命令行读取数据并发送到服务端</p>
<p>  pthread_create(&amp;pid_write, NULL, write_to_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 主线程等待子线程退出</p>
<p>  pthread_join(pid_read, NULL);</p>
<p>  pthread_join(pid_write, NULL);</p>
<p>  printf(“关闭资源\n”);</p>
<p>  close(sockfd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>3）</strong><em><strong>*编译并测试*</strong></em></p>
<p>（1）Makefile</p>
<p>补充顶部的伪目标声明，补充变量定义</p>
<p>.PHONY: single_conn single_conn_clean multi_conn_threads multi_conn_threads_clean</p>
<p>multi_conn_threads_executables:&#x3D;multi_conn_threads_server multi_conn_threads_client</p>
<p>在文件末尾追加目标定义</p>
<p>multi_conn_threads_server: multi_conn_threads_server.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>multi_conn_threads_client: multi_conn_threads_client.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>multi_conn_threads: $(multi_conn_threads_executables)</p>
<p>multi_conn_threads_clean:</p>
<p>  -rm .&#x2F;$(firstword $(multi_conn_threads_executables)) .&#x2F;$(lastword $(multi_conn_threads_executables))</p>
<p>（2）测试</p>
<p>运行multi_conn_threads目标后，执行以下操作</p>
<p>① 开启三个Xshell标签页，然后“垂直排列”</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps194.jpg" alt="img"> </p>
<p>② 开启服务端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps195.jpg" alt="img"> </p>
<p>③ 开启两个客户端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps196.jpg" alt="img"> </p>
<p>服务端提示客户端已连接，并给出客户端sockfd的文件描述符。</p>
<p>④ 用两个客户端分别发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps197.jpg" alt="img"> </p>
<p>⑤ 在客户端窗口Ctrl+D关闭连接</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps198.jpg" alt="img"> </p>
<p>连接全部断开，服务端仍在阻塞，等待新的连接。</p>
<h4 id="6-4-5-服务端基于多进程的支持多个连接的范例程序"><a href="#6-4-5-服务端基于多进程的支持多个连接的范例程序" class="headerlink" title="6.4.5 服务端基于多进程的支持多个连接的范例程序"></a>6.4.5 <strong>服务端基于多进程的支持多个连接的范例程序</strong></h4><p><strong>1）</strong><em><strong>*服务端（*</strong></em><em><strong>*multi_conn_processes_server.c*</strong></em><em><strong>*）*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>void zombie_dealer(int sig) {</p>
<p>  pid_t pid;</p>
<p>  int status;</p>
<p>  &#x2F;&#x2F; 一个SIGCHLD可能对应多个子进程的退出</p>
<p>  &#x2F;&#x2F; 使用while循环回收所有退出的子进程，避免僵尸进程的出现</p>
<p>  while ((pid &#x3D; waitpid(-1, &amp;status, WNOHANG)) &gt; 0) {</p>
<p>​    if (WIFEXITED(status)) {</p>
<p>​      printf(“子进程: %d 以 %d 状态正常退出，已被回收\n”, pid, WEXITSTATUS(status));</p>
<p>​    } else if (WIFSIGNALED(status)) {</p>
<p>​      printf(“子进程: %d 被 %d 信号杀死，已被回收\n”, pid, WTERMSIG(status));</p>
<p>​    } else {</p>
<p>​      printf(“子进程: %d 因其它原因退出，已被回收\n”, pid);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>void *read_from_client_then_write(void *argv)</p>
<p>{</p>
<p>  int client_fd &#x3D; *(int *)argv;</p>
<p>  ssize_t count &#x3D; 0, send_count &#x3D; 0;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    printf(“服务端pid: %d: 读缓存创建异常，断开连接\n”, getpid());</p>
<p>​    shutdown(client_fd, SHUT_WR);</p>
<p>​    close(client_fd);</p>
<p>​    perror(“malloc sever read_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“服务端pid: %d: 写缓存创建异常，断开连接\n”, getpid());</p>
<p>​    free(read_buf);</p>
<p>​    shutdown(client_fd, SHUT_WR);</p>
<p>​    close(client_fd);</p>
<p>​    perror(“malloc server write_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while ((count &#x3D; recv(client_fd, read_buf, 1024, 0)))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“recv”);</p>
<p>​    }</p>
<p>​    printf(“服务端pid: %d: reveive message from client_fd: %d: %s\n”, getpid(), client_fd, read_buf);</p>
<p>​    sprintf(write_buf, “服务端pid: %d: reveived~\n”, getpid());</p>
<p>​    send_count &#x3D; send(client_fd, write_buf, 1024, 0);</p>
<p>​    if (send_count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“send”);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“服务端pid: %d: 客户端client_fd: %d请求关闭连接……\n”, getpid(), client_fd);</p>
<p>  sprintf(write_buf, “服务端pid: %d: receive your shutdown signal\n”, getpid());</p>
<p>  send_count &#x3D; send(client_fd, write_buf, 1024, 0);</p>
<p>  if (send_count &lt; 0)</p>
<p>  {</p>
<p>​    perror(“send”);</p>
<p>  }</p>
<p>  printf(“服务端pid: %d: 释放client_fd: %d资源\n”, getpid(), client_fd);</p>
<p>  shutdown(client_fd, SHUT_WR);</p>
<p>  close(client_fd);</p>
<p>  free(read_buf);</p>
<p>  free(write_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result;</p>
<p>  struct sockaddr_in server_addr, client_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;client_addr, 0, sizeof(client_addr));</p>
<p>  &#x2F;&#x2F; 声明IPV4通信协议</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 我们需要绑定0.0.0.0地址，转换成网络字节序后完成设置</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</p>
<p>  &#x2F;&#x2F; 端口随便用一个，但是不要用特权端口</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建server socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 绑定地址</p>
<p>  temp_result &#x3D; bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“bind”, temp_result);</p>
<p>  &#x2F;&#x2F; 进入监听模式</p>
<p>  temp_result &#x3D; listen(sockfd, 128);</p>
<p>  handle_error(“listen”, temp_result);</p>
<p>  socklen_t cliaddr_len &#x3D; sizeof(client_addr);</p>
<p>  &#x2F;&#x2F; 注册信号处理函数，处理SIGCHLD信号，避免僵尸进程出现</p>
<p>  signal(SIGCHLD, zombie_dealer);</p>
<p>  &#x2F;&#x2F; 接受client连接</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    int client_fd &#x3D; accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;cliaddr_len);</p>
<p>​    handle_error(“accept”, client_fd);</p>
<p>​    pid_t pid &#x3D; fork();</p>
<p>​    if (pid &gt; 0)</p>
<p>​    {</p>
<p>​      printf(“this is father, pid is %d, continue accepting…\n”, getpid());</p>
<p>​      &#x2F;&#x2F; 父进程不需要处理client_fd，释放文件描述符，使其引用计数减一，以便子进程释放client_fd后，其引用计数可以减为0,从而释放资源</p>
<p>​      close(client_fd);</p>
<p>​    }</p>
<p>​    else if (pid &#x3D;&#x3D; 0)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F; 子进程不需要处理sockfd，释放文件描述符，使其引用计数减一</p>
<p>​      close(sockfd);</p>
<p>​      printf(“与客户端 from %s at PORT %d 文件描述符 %d 建立连接\n”,</p>
<p>​          inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), client_fd);</p>
<p>​      printf(“新的服务端pid为: %d\n”, getpid());</p>
<p>​      &#x2F;&#x2F; 读取客户端数据，并打印到 stdout</p>
<p>​      read_from_client_then_write((void *)&amp;client_fd);</p>
<p>​      &#x2F;&#x2F; 释放资源并终止子进程</p>
<p>​      close(client_fd);</p>
<p>​      exit(EXIT_SUCCESS);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“释放资源\n”);</p>
<p>  close(sockfd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*客户端（*</strong></em><em><strong>*multi_conn_processes_client.c*</strong></em><em><strong>*）*</strong></em></p>
<p>这里的客户端程序与multi_conn_threads_client.c完全一致</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>void *read_from_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  ssize_t count &#x3D; 0;</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    perror(“malloc client read_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (count &#x3D; recv(sockfd, read_buf, 1024, 0))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“recv”);</p>
<p>​    }</p>
<p>​    fputs(read_buf, stdout);</p>
<p>  }</p>
<p>  printf(“收到服务端的终止信号……\n”);</p>
<p>  free(read_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>void *write_to_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  ssize_t send_count;</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“写缓存申请异常，断开连接\n”);</p>
<p>​    shutdown(sockfd, SHUT_WR);</p>
<p>​    perror(“malloc client write_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (fgets(write_buf, 1024, stdin) !&#x3D; NULL)</p>
<p>  {</p>
<p>​    send(sockfd, write_buf, 1024, 0);</p>
<p>​    if (send_count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“send”);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“接收到命令行的终止信号，不再写入，关闭连接……\n”);</p>
<p>  shutdown(sockfd, SHUT_WR);</p>
<p>  free(write_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result;</p>
<p>  pthread_t pid_read, pid_write;</p>
<p>  struct sockaddr_in server_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 连接本机 127.0.0.1</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_LOOPBACK);</p>
<p>  &#x2F;&#x2F; 连接端口 6666</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 连接server</p>
<p>  temp_result &#x3D; connect(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“connect”, temp_result);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来读取服务端数据，并打印到 stdout</p>
<p>  pthread_create(&amp;pid_read, NULL, read_from_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来从命令行读取数据并发送到服务端</p>
<p>  pthread_create(&amp;pid_write, NULL, write_to_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 主线程等待子线程退出</p>
<p>  pthread_join(pid_read, NULL);</p>
<p>  pthread_join(pid_write, NULL);</p>
<p>  printf(“关闭资源\n”);</p>
<p>  close(sockfd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>3）</strong><em><strong>*编译并测试*</strong></em></p>
<p>（1）Makefile</p>
<p>在头部的伪目标声明中补充内容，补充变量定义</p>
<p>.PHONY: single_conn single_conn_clean multi_conn_threads multi_conn_threads_clean multi_conn_processes multi_conn_processes_clean</p>
<p>multi_conn_processes_executables:&#x3D;multi_conn_processes_server multi_conn_processes_client</p>
<p>multi_conn_processes_server: multi_conn_processes_server.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>multi_conn_processes_client: multi_conn_processes_client.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>multi_conn_processes: $(multi_conn_processes_executables)</p>
<p>multi_conn_processes_clean:</p>
<p>  -rm .&#x2F;$(word 1, $(multi_conn_processes_executables)) .&#x2F;$(word 2, $(multi_conn_processes_executables))</p>
<p>（2）测试</p>
<p>运行multi_conn_processes目标后，执行以下步骤</p>
<p>① 垂直排列开启三个XShell窗口</p>
<p>② 在其中一个窗口开启服务端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps199.jpg" alt="img"> </p>
<p>③ 在另外两个窗口开启客户端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps200.jpg" alt="img"> </p>
<p>可以看到，每当一个新连接到来，服务端父进程都会创建一个新的子进程专门用于处理该连接。</p>
<p>此外，两个连接创建的client_fd文件描述符竟然都是4，这是因为每次创建子进程后，父进程就会释放client_fd，对应的文件描述符4被释放，新的连接到来时会从可用的最小文件描述符开始占用，因此新连接的client_fd也是4。虽然它们的client_fd是一样的，但对应的底层文件描述却是完全不同的。</p>
<p>④ 在两个客户端中发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps201.jpg" alt="img"> </p>
<p>每个连接都有独立的服务端进程处理。</p>
<p>⑤ 在客户端发送Ctrl+D终止连接</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps202.jpg" alt="img"> </p>
<p>上文提到，服务端的父进程中，两个连接对应的client_fd都是4，fork()之后，子进程会继承父进程的文件描述符表，因此两个服务端子进程的client_fd也都是4。</p>
<p>⑥ 服务端通过Ctrl+C终止</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps203.jpg" alt="img"> </p>
<h3 id="6-5-传输层-基于UDP协议的程序"><a href="#6-5-传输层-基于UDP协议的程序" class="headerlink" title="6.5 传输层-基于UDP协议的程序"></a>6.5 <strong>传输层-基于UDP协议的程序</strong></h3><h4 id="6-5-1-UDP-通讯流程"><a href="#6-5-1-UDP-通讯流程" class="headerlink" title="6.5.1 UDP****通讯流程"></a>6.5.1 <strong>UDP****通讯流程</strong></h4><p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps204.png" alt="img"></p>
<h4 id="6-5-2-UDP开发常用函数"><a href="#6-5-2-UDP开发常用函数" class="headerlink" title="6.5.2 UDP开发常用函数"></a>6.5.2 <strong>UDP<strong><strong>开发</strong></strong>常用函数</strong></h4><p>UDP通讯也使用socket，但是接收和发送的函数与TCP不一样。由于UDP不存在握手这一步骤，所以在绑定地址之后，服务端不需要listen，客户端也不需要connect，服务端同样不需要accept。只要服务端绑定以后，就可以相互发消息了，由于没有握手过程，两端都不能确定对方是否收到消息，这也是UDP协议不如TCP协议可靠的地方。</p>
<p>UDP协议接收和发送数据不再用send和recv方法，这两个方法一般用于TCP通信，UDP通信使用sendto和recvfrom方法，声明如下：</p>
<p><strong>1）</strong><em><strong>*recvfrom*</strong></em></p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 将接收到的消息放入缓冲区 buf 中。</p>
<p> * </p>
<p> * @param sockfd 套接字文件描述符</p>
<p> * @param buf 缓冲区指针</p>
<p> * @param len 缓冲区大小</p>
<p> * @param flags 通信标签，详见recv方法说明</p>
<p> * @param src_addr 可以填NULL，如果 src_addr 不是 NULL，并且底层协议提供了消息的源地址，则该源地址将被放置在 src_addr 指向的缓冲区中。</p>
<p> * @param addrlen 如果src_addr不为NULL，它应初始化为与 src_addr 关联的缓冲区的大小。返回时，addrlen 被更新为包含实际源地址的大小。如果提供的缓冲区太小，则返回的地址将被截断；在这种情况下，addrlen 将返回一个大于调用时提供的值。</p>
<p> * @return ssize_t 实际收到消息的大小。如果接收失败，返回-1</p>
<p> *&#x2F;</p>
<p>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</p>
<p><strong>2）</strong><em><strong>*sendto*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 向指定地址发送缓冲区中的数据（一般用于UDP模式）</p>
<p> * </p>
<p> * @param sockfd 套接字文件描述符</p>
<p> * @param buf 缓冲区指针</p>
<p> * @param len 缓冲区大小</p>
<p> * @param flags 通信标签，详细减send方法说明</p>
<p> * @param dest_addr 目标地址。如果用于连接模式，该参数会被忽略</p>
<p> * @param addrlen 目标地址长度</p>
<p> * @return ssize_t 发送的消息大小。发送失败返回-1</p>
<p> *&#x2F;</p>
<p>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</p>
<h4 id="6-5-3-范例程序"><a href="#6-5-3-范例程序" class="headerlink" title="6.5.3 范例程序"></a>6.5.3 <strong>范例程序</strong></h4><p><strong>1）</strong><em><strong>*UDP协议服务端（*</strong></em><em><strong>*udp_server.c*</strong></em><em><strong>*）*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result, client_fd;</p>
<p>  struct sockaddr_in server_addr, client_addr;</p>
<p>  char *buf &#x3D; malloc(1024);</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;client_addr, 0, sizeof(client_addr));</p>
<p>  &#x2F;&#x2F; 声明IPV4通信协议</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 我们需要绑定0.0.0.0地址，转换成网络字节序后完成设置</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</p>
<p>  &#x2F;&#x2F; 端口随便用一个，但是不要用特权端口</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建server socket，注意通信类型</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_DGRAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 绑定地址</p>
<p>  temp_result &#x3D; bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“bind”, temp_result);</p>
<p>  do</p>
<p>  {</p>
<p>​    &#x2F;&#x2F; 清空缓冲区</p>
<p>​    memset(buf, 0, 1024);</p>
<p>​    &#x2F;&#x2F; 尝试接受数据</p>
<p>​    socklen_t client_addr_len &#x3D; sizeof(client_addr);</p>
<p>​    temp_result &#x3D; recvfrom(sockfd, buf, 1024, 0, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);</p>
<p>​    handle_error(“recvfrom”, temp_result);</p>
<p>​    &#x2F;&#x2F; 如果客户端发来的不是EOF</p>
<p>​    if (strncmp(buf, “EOF”, 3) !&#x3D; 0)</p>
<p>​    {</p>
<p>​      printf(“received msg from %s at port %d: %s”, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), buf);</p>
<p>​      strcpy(buf, “OK\n”);</p>
<p>​    } else {</p>
<p>​      printf(“received EOF from client, existing…\n”);</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F; 收到数据后回复OK或EOF(客户端发送的是EOF则回复EOF，否则回复OK)</p>
<p>​    temp_result &#x3D; sendto(sockfd, buf, 4, 0, (struct sockaddr *)&amp;client_addr, client_addr_len);</p>
<p>​    handle_error(“sendto”, temp_result);</p>
<p>  } while (strncmp(buf, “EOF”, 3) !&#x3D; 0);</p>
<p>  free(buf);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*UDP协议客户端（*</strong></em><em><strong>*udp_client.c*</strong></em><em><strong>*）*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result, client_fd;</p>
<p>  struct sockaddr_in server_addr;</p>
<p>  char *buf &#x3D; malloc(1024);</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  &#x2F;&#x2F; 声明IPV4通信协议</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 我们需要绑定0.0.0.0地址，转换成网络字节序后完成设置</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_LOOPBACK);</p>
<p>  &#x2F;&#x2F; 端口随便用一个，但是不要用特权端口</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建server socket，注意通信类型</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_DGRAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  do</p>
<p>  {</p>
<p>​    write(STDOUT_FILENO, “Type something you want to send: “, 34);</p>
<p>​    &#x2F;&#x2F; 从标准输入读取数据</p>
<p>​    int buf_len &#x3D; read(STDIN_FILENO, buf, 1023);</p>
<p>​    temp_result &#x3D; sendto(sockfd, buf, buf_len, 0, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>​    handle_error(“sendto”, temp_result);</p>
<p>​    &#x2F;&#x2F; 清空缓冲区</p>
<p>​    memset(buf, 0, 1024);</p>
<p>​    &#x2F;&#x2F; 尝试接受数据</p>
<p>​    temp_result &#x3D; recvfrom(sockfd, buf, 1024, 0, NULL, NULL);</p>
<p>​    handle_error(“recvfrom”, temp_result);</p>
<p>​    &#x2F;&#x2F; 如果服务端发来的不是EOF</p>
<p>​    if (strncmp(buf, “EOF”, 3) !&#x3D; 0)</p>
<p>​    {</p>
<p>​      printf(“received msg from %s at port %d: %s”, inet_ntoa(server_addr.sin_addr), ntohs(server_addr.sin_port), buf);</p>
<p>​    }</p>
<p>  } while (strncmp(buf, “EOF”, 3) !&#x3D; 0);</p>
<p>  free(buf);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>3）</strong><em><strong>*编译并执行*</strong></em></p>
<p>（1）Makefile</p>
<p>在顶部的伪目标声明中补充内容，并补充变量定义</p>
<p>.PHONY: single_conn single_conn_clean multi_conn_threads multi_conn_threads_clean multi_conn_processes multi_conn_processes_clean udp_test upd_test_clean</p>
<p>udp_test_executables:&#x3D;udp_server udp_client</p>
<p>在文件末尾补充目标定义</p>
<p>udp_server: udp_server.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>udp_client: udp_client.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>udp_test: $(udp_test_executables)</p>
<p>upd_test_clean:</p>
<p>  -rm .&#x2F;$(firstword $(udp_test_executables)) .&#x2F;$(lastword $(udp_test_executables))</p>
<p>（2）运行</p>
<p>编译后执行以下步骤。</p>
<p>① 在XShell中打开两个标签页，并垂直分割</p>
<p>② 分别在两个标签页中启动服务端和客户端，先启动服务端，后启动客户端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps205.jpg" alt="img"> </p>
<p>③ 在客户端发送一些数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps206.jpg" alt="img"> </p>
<p>④ 客户端发送EOF字符串，断开连接</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps207.jpg" alt="img"> </p>
<h3 id="6-6-U-nix-Domain-Socket-IPC"><a href="#6-6-U-nix-Domain-Socket-IPC" class="headerlink" title="6.6 U****nix Domain Socket IPC"></a>6.6 <strong>U****nix Domain Socket IPC</strong></h3><h4 id="6-6-1-简介"><a href="#6-6-1-简介" class="headerlink" title="6.6.1 简介"></a>6.6.1 <strong>简介</strong></h4><p>Socket编程原本是为了网络服务的，后来逐渐发展成一种进程间通信的方式：Unix Domain Socket IPC。它允许在同一台主机上运行的进程之间进行高效的数据传输，无需经过网络协议栈，因此具有低延迟和高性能的特点。通过文件系统中的特殊文件（通常是一个套接字文件），进程可以通过套接字（socket）来进行通信，实现双向的数据传输。Unix Domain Socket IPC被广泛用于各种应用场景，如进程间通信、客户端-服务器模型等，是Unix&#x2F;Linux系统中实现进程间通信的重要工具之一。</p>
<h4 id="6-6-2-套接字-地址结构体说明"><a href="#6-6-2-套接字-地址结构体说明" class="headerlink" title="6.6.2 套接字****地址结构体说明"></a>6.6.2 <strong>套接字****地址结构体说明</strong></h4><p>使用man 7 unix查看文档，可得：</p>
<p>&#x2F;*</p>
<p>地址格式</p>
<p>UNIX 域套接字地址表示为以下结构：</p>
<p>*&#x2F;</p>
<p>struct sockaddr_un {</p>
<p>  sa_family_t sun_family;        &#x2F;* AF_UNIX *&#x2F;</p>
<p>  char     sun_path[108];       &#x2F;* Pathname *&#x2F;</p>
<p>};</p>
<p>&#x2F;*</p>
<p>sun_family 字段始终包含 AF_UNIX。在 Linux 上，sun_path 的大小为 108 字节；请参见下面的注意事项。</p>
<p>各种系统调用（例如，bind(2)、connect(2) 和 sendto(2)）将一个 sockaddr_un 参数作为输入。一些其他系统调用（例如，getsockname(2)、getpeername(2)、recvfrom(2) 和 accept(2)）返回此类型的参数。</p>
<p>在 sockaddr_un 结构中区分三种类型的地址：</p>
<p>路径名：可以使用 bind(2) 将 UNIX 域套接字绑定到以空字符结尾的文件系统路径名。当返回路径名套接字的地址（由上述系统调用之一返回）时，其长度为</p>
<p>sizeof(sa_family_t) + strlen(sun_path) + 1</p>
<p>未命名：未使用 bind(2) 将流套接字绑定到路径名的套接字没有名称。同样，socketpair(2) 创建的两个套接字也没有名称。返回未命名套接字的地址时，其长度为 sizeof(sa_family_t)，并且不应检查 sun_path。</p>
<p>抽象：通过 sun_path[0] 是空字节(‘\0’) 来区分抽象套接字地址（与路径名套接字）。此命名空间中套接字的地址由地址结构指定长度覆盖的 sun_path 中的附加字节给出。（名称中的空字节没有特殊意义。）名称与文件系统路径名无关。当返回抽象套接字的地址时，返回的 addrlen 大于 sizeof(sa_family_t)（即大于 2），并且套接字的名称包含在 sun_path 的前 (addrlen - sizeof(sa_family_t)) 字节中。</p>
<p>*&#x2F;</p>
<p>关于pathname socket，文档中还有详细介绍。</p>
<p>&#x2F;*</p>
<p>绑定套接字到路径名时，应遵循以下规则以实现最大的可移植性和编码便利性：</p>
<p>sun_path 中的路径名应以空字符结尾。</p>
<p>路径名的长度，包括终止的空字节，不应超过 sun_path 的大小。</p>
<p>描述封装 sockaddr_un 结构的 addrlen 参数应指定为 sizeof(struct sockaddr_un)。</p>
<p>在 Linux 实现中，路径名套接字遵循它们所在目录的权限。如果进程在创建套接字的目录中没有写和搜索（执行）权限，则创建新套接字将失败。</p>
<p>在 Linux 上，连接到流套接字对象需要对该套接字具有写权限；同样，向数据报套接字发送数据报也需要对该套接字具有写权限。POSIX 对套接字文件的权限效果没有做出任何声明，在某些系统上（例如，旧版 BSD），套接字权限会被忽略。可移植的程序不应依赖此功能来进行安全性保障。</p>
<p>路径名套接字的所有者、组和权限可以更改（使用 chown(2) 和 chmod(2)）。</p>
<p>*&#x2F;</p>
<p>简单来说，使用AF_UNIX通信域，可以声明一个使用本地文件的socket，其他进程可以绑定该文件完成进程间通信。</p>
<h4 id="6-6-3-范例程序"><a href="#6-6-3-范例程序" class="headerlink" title="6.6.3 范例程序"></a>6.6.3 <strong>范例程序</strong></h4><p><strong>1）</strong><em><strong>*创建socket_ipc_test.c*</strong></em></p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stddef.h&gt;</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;un.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#define SOCKET_PATH “unix_domain.socket”</p>
<p>#define SERVER_MODE 1</p>
<p>#define CLIENT_MODE 2</p>
<p>#define BUF_LEN 1024</p>
<p>static struct sockaddr_un socket_addr;</p>
<p>static char *buf;</p>
<p>void handle_error(char *err_msg)</p>
<p>{</p>
<p>  perror(err_msg);</p>
<p>  unlink(SOCKET_PATH);</p>
<p>  exit(-1);</p>
<p>}</p>
<p>void server_mode(int sockfd)</p>
<p>{</p>
<p>  int client_fd, msg_len;</p>
<p>  static struct sockaddr_un client_addr;</p>
<p>  if (bind(sockfd, (struct sockaddr *)&amp;socket_addr, sizeof(socket_addr)) &lt; 0)</p>
<p>  {</p>
<p>​    handle_error(“bind”);</p>
<p>  }</p>
<p>  if (listen(sockfd, 128) &lt; 0)</p>
<p>  {</p>
<p>​    handle_error(“listen”);</p>
<p>  }</p>
<p>  socklen_t client_addr_len &#x3D; sizeof(client_addr);</p>
<p>  if ((client_fd &#x3D; accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len)) &lt; 0)</p>
<p>  {</p>
<p>​    handle_error(“accept”);</p>
<p>  }</p>
<p>  write(STDOUT_FILENO, “Connected to client!\n”, 21);</p>
<p>  do</p>
<p>  {</p>
<p>​    memset(buf, 0, BUF_LEN);</p>
<p>​    msg_len &#x3D; recv(client_fd, buf, BUF_LEN, 0);</p>
<p>​    printf(“Received msg: %s”, buf);</p>
<p>​    if (strncmp(buf, “EOF”, 3) !&#x3D; 0)</p>
<p>​    {</p>
<p>​      strcpy(buf, “OK!\n\0”);</p>
<p>​    }</p>
<p>​    send(client_fd, buf, strlen(buf), 0);</p>
<p>  } while (strncmp(buf, “EOF”, 3) !&#x3D; 0);</p>
<p>  if (shutdown(client_fd, SHUT_RDWR) &lt; 0)</p>
<p>  {</p>
<p>​    handle_error(“shutdown server”);</p>
<p>  }</p>
<p>  unlink(SOCKET_PATH);</p>
<p>}</p>
<p>void client_mode(int sockfd)</p>
<p>{</p>
<p>  int msg_len, header_len;</p>
<p>  if (connect(sockfd, (struct sockaddr *)&amp;socket_addr, sizeof(socket_addr)))</p>
<p>  {</p>
<p>​    handle_error(“connect”);</p>
<p>  }</p>
<p>  write(STDOUT_FILENO, “Connected to server!\n”, 21);</p>
<p>  strcpy(buf, “Msg received: “);</p>
<p>  &#x2F;&#x2F; 计算buf中头的长度</p>
<p>  header_len &#x3D; strlen(buf);</p>
<p>  do</p>
<p>  {</p>
<p>​    msg_len &#x3D; read(STDIN_FILENO, buf + header_len, BUF_LEN - header_len);</p>
<p>​    send(sockfd, buf + header_len, msg_len, 0);</p>
<p>​    msg_len &#x3D; recv(sockfd, buf + header_len, BUF_LEN - header_len, 0);</p>
<p>​    write(STDOUT_FILENO, buf, msg_len + header_len);</p>
<p>  } while (strncmp(buf + header_len, “EOF”, 3) !&#x3D; 0);</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int fd &#x3D; 0, mode &#x3D; 0;</p>
<p>  if (argc &#x3D;&#x3D; 1 || strncmp(argv[1], “server”, 6) &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    mode &#x3D; SERVER_MODE;</p>
<p>  }</p>
<p>  else if (strncmp(argv[1], “client”, 6) &#x3D;&#x3D; 0)</p>
<p>  {</p>
<p>​    mode &#x3D; CLIENT_MODE;</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>​    perror(“参数错误”);</p>
<p>​    exit(-1);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; address初始化</p>
<p>  memset(&amp;socket_addr, 0, sizeof(struct sockaddr_un));</p>
<p>  buf &#x3D; malloc(BUF_LEN);</p>
<p>  &#x2F;&#x2F; 给address赋值</p>
<p>  socket_addr.sun_family &#x3D; AF_UNIX;</p>
<p>  strcpy(socket_addr.sun_path, SOCKET_PATH);</p>
<p>  if ((fd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)</p>
<p>  {</p>
<p>​    handle_error(“socket”);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 分服务端和客户端</p>
<p>  switch (mode)</p>
<p>  {</p>
<p>  case SERVER_MODE:</p>
<p>​    server_mode(fd);</p>
<p>​    break;</p>
<p>  case CLIENT_MODE:</p>
<p>​    client_mode(fd);</p>
<p>​    break;</p>
<p>  }</p>
<p>  if (shutdown(fd, SHUT_RDWR) &lt; 0)</p>
<p>  {</p>
<p>​    handle_error(“shutdown”);</p>
<p>  }</p>
<p>  free(buf);</p>
<p>  exit(0);</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>（1）在头部补充伪目标声明</p>
<p>.PHONY: single_conn single_conn_clean multi_conn_threads multi_conn_threads_clean multi_conn_processes multi_conn_processes_clean udp_test upd_test_clean socket_ipc_test_clean</p>
<p>（2）尾部补充目标定义</p>
<p>socket_ipc_test: socket_ipc_test.c</p>
<p>  $(CC) -o $@ $^</p>
<p>socket_ipc_test_clean:</p>
<p>  -rm .&#x2F;socket_ipc_test</p>
<p><strong>3）</strong><em><strong>*运行*</strong></em></p>
<p>（1）开启两个XShell标签页</p>
<p>（2）启动服务端</p>
<p>.&#x2F;socket_ipc_test server或.&#x2F;socket_ipc_test均可启动服务端，即命令行不传参，默认启动服务端。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps208.jpg" alt="img"> </p>
<p>（3）启动客户端</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps209.jpg" alt="img"> </p>
<p>（4）客户端发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps210.jpg" alt="img"> </p>
<p>（5）客户端发送EOF断开连接</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps211.jpg" alt="img"> </p>
<h3 id="6-7-网络层-IP协议"><a href="#6-7-网络层-IP协议" class="headerlink" title="6.7 网络层-IP协议"></a>6.7 <strong>网络层-IP协议</strong></h3><h4 id="6-7-1-简介"><a href="#6-7-1-简介" class="headerlink" title="6.7.1 简介"></a>6.7.1 <strong>简介</strong></h4><p>IP（Internet Protocol，互联网协议）是网络通信中最基础的协议之一，用于在不同的网络设备之间传输数据。IP协议定义了数据包的格式和寻址方法，使得数据能够从源地址传输到目标地址。</p>
<h4 id="6-7-2-IP地址"><a href="#6-7-2-IP地址" class="headerlink" title="6.7.2 IP地址"></a>6.7.2 <strong>IP地址</strong></h4><p>IP地址（Internet Protocol Address，互联网协议地址）是分配给连接到计算机网络的每个设备的唯一标识符，用于在网络中进行通信。IP地址使数据包在网络上能够找到其目标位置，确保数据从源设备传输到目标设备。</p>
<h4 id="6-7-3-IP协议版本"><a href="#6-7-3-IP协议版本" class="headerlink" title="6.7.3 IP协议版本"></a>6.7.3 <strong>IP协议版本</strong></h4><p><strong>1）</strong><em><strong>*IPv4（Internet Protocol version 4）*</strong></em></p>
<p>IPv4是最早和最常用的IP协议版本，使用32位地址，地址范围为0.0.0.0到255.255.255.255。IPv4的地址空间约为43亿个，但由于地址分配效率问题和互联网的快速增长，IPv4地址已接近枯竭。</p>
<p>Ø 地址长度：32位（4字节）</p>
<p>Ø 地址表示：点分十进制（例如：192.168.0.1）</p>
<p>Ø 地址数量：约43亿个</p>
<p><strong>2）</strong><em><strong>*IPv6（Internet Protocol version 6）*</strong></em></p>
<p>IPv6是为解决IPv4地址枯竭问题而设计的新一代IP协议，使用128位地址，能够提供数量巨大的地址空间。</p>
<p>Ø 地址长度：128位（16字节）</p>
<p>Ø 地址表示：十六进制数和冒号分隔（例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334）</p>
<p>Ø 地址数量：几乎无限（2的128次方）</p>
<p>Ø 内置了IPsec（用于网络安全）</p>
<h4 id="6-7-4-IP地址分类"><a href="#6-7-4-IP地址分类" class="headerlink" title="6.7.4 IP地址分类"></a>6.7.4 <strong>IP地址分类</strong></h4><p><strong>1）</strong><em><strong>*根据作用范围*</strong></em></p>
<p>（1）私有IP地址</p>
<p>私有IP地址用于局域网（LAN）内部，不在互联网中传输。常见的私有IP地址范围有：</p>
<p>10.0.0.0 - 10.255.255.255</p>
<p>172.16.0.0 - 172.31.255.255</p>
<p>192.168.0.0 - 192.168.255.255</p>
<p>（2）公有IP地址</p>
<p>公有IP地址由互联网服务提供商（ISP）分配，可以在全球互联网中唯一识别。</p>
<p><strong>2）</strong><em><strong>*根据是否可以更改*</strong></em></p>
<p>（1）静态IP地址</p>
<p>静态IP地址是手动分配的，不会改变。适用于需要长期保持相同IP地址的设备，如服务器。</p>
<p>（2）动态IP地址</p>
<p>动态IP地址由DHCP服务器动态分配，每次连接网络时可能会改变。适用于普通用户设备，如电脑和手机。</p>
<h4 id="6-7-5-网络层硬件设备"><a href="#6-7-5-网络层硬件设备" class="headerlink" title="6.7.5 网络层硬件设备"></a>6.7.5 <strong>网络层硬件设备</strong></h4><p><strong>1）</strong><em><strong>*注意*</strong></em></p>
<p>在网络分层模型中，某层的设备通常需要执行<strong>该层及以下所有层</strong>的功能。</p>
<p><strong>1）</strong><em><strong>*路由器*</strong></em></p>
<p>路由器是一种网络设备，用于在计算机网络之间转发数据包。它主要用于连接不同的网络，并确定数据包的最佳路径。路由器通过分析数据包的目标地址，选择最有效的路由路径，将数据包传输到目的地。</p>
<p><strong>路由器</strong>主要工作网络分层模型的<strong>网络层</strong>。</p>
<h3 id="6-8-应用层-DNS协议"><a href="#6-8-应用层-DNS协议" class="headerlink" title="6.8 应用层-DNS协议"></a>6.8 <strong>应用层-DNS协议</strong></h3><h4 id="6-8-1-简介"><a href="#6-8-1-简介" class="headerlink" title="6.8.1 简介"></a>6.8.1 <strong>简介</strong></h4><p>访问网站实际上是与某台服务器通信。为了定位这台服务器，我们需要使用IP地址。然而，IP地址是一串数字，不易读且难以记忆。</p>
<p>域名（Domain Name）是互联网上用于标识网站的易于记忆的名称，代替了难记的IP地址，使用户能够方便地访问网站。域名由一系列标签组成，这些标签由点（.）分隔，每个标签代表域名层次结构中的一个级别。如<a target="_blank" rel="noopener" href="http://www.atguigu.com/">www.atguigu.com</a>。</p>
<p>DNS（Domain Name System，域名系统）协议是一种用于将人类易读的域名（如<a target="_blank" rel="noopener" href="http://www.atguigu.com/">www.atguigu.com</a>）转换为计算机可以识别的IP地址（如192.0.2.1）的网络协议。它是互联网的关键组件之一，使用户能够使用友好的域名而不是难记的IP地址来访问网站和其他互联网资源。</p>
<h4 id="6-8-2-一个典型的DNS查询示例"><a href="#6-8-2-一个典型的DNS查询示例" class="headerlink" title="6.8.2 一个典型的DNS查询示例"></a>6.8.2 <strong>一个典型的DNS查询示例</strong></h4><p>（1）用户请求：用户在浏览器中输入一个域名（如<a target="_blank" rel="noopener" href="http://www.atguigu.com/">www.atguigu.com</a>）。</p>
<p>（2）本地缓存检查：客户端首先检查本地缓存中是否有该域名的IP地址。如果有，直接返回结果；如果没有，继续下一步。</p>
<p>（3）递归查询：</p>
<p>Ø 查询本地DNS服务器：客户端向本地DNS服务器发送递归查询请求。</p>
<p>Ø 查询根域名服务器：本地DNS服务器向根域名服务器查询。根域名服务器返回顶级域名服务器（TLD Server）的地址。</p>
<p>Ø 查询顶级域名服务器：本地DNS服务器向顶级域名服务器查询，顶级域名服务器返回权威DNS服务器的地址。</p>
<p>Ø 查询权威DNS服务器：本地DNS服务器向权威DNS服务器查询，权威DNS服务器返回目标IP地址。</p>
<p>（4）返回结果：本地DNS服务器将获得的IP地址返回给客户端。</p>
<p>（5）访问目标网站：客户端使用获得的IP地址访问目标网站。</p>
<h3 id="6-9-数据链路层"><a href="#6-9-数据链路层" class="headerlink" title="6.9 数据链路层"></a>6.9 <strong>数据链路层</strong></h3><h4 id="6-9-1-主要功能"><a href="#6-9-1-主要功能" class="headerlink" title="6.9.1 主要功能"></a>6.9.1 <strong>主要功能</strong></h4><p>在两个网络实体之间提供数据链路连接的建立、维持和释放管理。构成数据链路数据单元（frame：数据帧或帧），并对帧定界、同步、收发顺序的控制。并且包括传输过程中的网络流量控制、差错检测和差错控制等方面。</p>
<p>只提供导线的一端到另一端（本质是点到点）的数据传输。</p>
<h4 id="6-9-2-MAC地址"><a href="#6-9-2-MAC地址" class="headerlink" title="6.9.2 MAC地址"></a>6.9.2 <strong>MAC地址</strong></h4><p><strong>1）</strong><em><strong>*功能*</strong></em></p>
<p>MAC地址（Media Access Control Address，介质访问控制地址）是网络设备的硬件地址，用于在局域网（LAN）中唯一标识设备。MAC地址嵌入在设备的网络接口控制器（NIC）中，每个设备在全球范围内都应该具有一个唯一的MAC地址。</p>
<p>MAC地址工作在数据链路层，用于设备间通信。</p>
<p><strong>2）</strong><em><strong>*格式*</strong></em></p>
<p>MAC地址通常是48位（二进制）的数字，通常表示为12位的十六进制数。例如，00:1A:2B:3C:4D:5E。常见的表示形式有两种：</p>
<p>Ø 用冒号分隔的六个十六进制数对（如 00:1A:2B:3C:4D:5E）</p>
<p>Ø 用连字符分隔的六个十六进制数对（如 00-1A-2B-3C-4D-5E）</p>
<h4 id="6-9-3-ARP协议"><a href="#6-9-3-ARP协议" class="headerlink" title="6.9.3 ARP协议"></a>6.9.3 <strong>ARP协议</strong></h4><p><strong>1）</strong><em><strong>*作用*</strong></em></p>
<p>Address Resolution Protocol，地址解析协议，用于将IP地址转换为物理MAC地址。这个转换过程在局域网内是必须的，因为以太网帧是通过MAC地址传输的，而网络层数据包使用IP地址。</p>
<p><strong>2）</strong><em><strong>*工作流程*</strong></em></p>
<p>（1）ARP请求</p>
<p>当一个设备（如计算机）需要发送数据到另一个设备，但只知道目标设备的IP地址时，它会在网络上广播一个ARP请求帧。这个请求帧包含发送方的IP地址和MAC地址，以及目标设备的IP地址。</p>
<p>（2）ARP响应</p>
<p>网络上所有设备都接收到ARP请求，但只有目标设备会响应。目标设备会发送一个包含其MAC地址的ARP响应帧直接回到发送方。</p>
<p>（3）地址缓存</p>
<p>发送方接收到ARP响应后，会将目标设备的IP地址和MAC地址映射关系缓存到本地的ARP缓存中，以便下次发送数据时无需再进行地址解析。</p>
<h4 id="6-9-4-RARP协议"><a href="#6-9-4-RARP协议" class="headerlink" title="6.9.4 RARP协议"></a>6.9.4 <strong>RARP协议</strong></h4><p><strong>1）</strong><em><strong>*作用*</strong></em></p>
<p>RARP（Reverse Address Resolution Protocol，反向地址解析协议）是一种用于计算机网络的协议，主要作用是通过已知的物理地址（MAC地址）获取相应的IP地址。RARP在一些早期的网络设备上用于无盘工作站或没有永久存储IP地址的设备，使这些设备能够在网络上正常通信。</p>
<p><strong>2）</strong><em><strong>*工作流程*</strong></em></p>
<p>（1）广播请求</p>
<p>当设备启动时，它会生成一个RARP请求包，其中包含自己的MAC地址。设备将该请求包以广播的方式发送到网络上，以便所有网络上的RARP服务器都能接收到。</p>
<p>（2）RARP服务器接收请求</p>
<p>网络中的RARP服务器监听并接收所有的RARP请求。RARP服务器维护着一个映射表，包含每个设备的MAC地址和对应的IP地址。</p>
<p>（3）服务器查找映射表</p>
<p>RARP服务器接收到请求后，会在其映射表中查找请求中包含的MAC地址。如果找到对应的IP地址，服务器会生成一个RARP响应包，其中包含该设备的IP地址。</p>
<p>（4）发送响应</p>
<p>RARP服务器将RARP响应包发送回请求设备。这通常是通过单播方式直接发送到请求设备的MAC地址。</p>
<p>（5）设备配置IP地址</p>
<p>请求设备接收到RARP响应包后，从中提取出自己的IP地址并配置到其网络接口上。</p>
<h4 id="6-9-5-数据链路层硬件设备"><a href="#6-9-5-数据链路层硬件设备" class="headerlink" title="6.9.5 数据链路层硬件设备"></a>6.9.5 <strong>数据链路层硬件设备</strong></h4><p><strong>1）</strong><em><strong>*交换机*</strong></em></p>
<p>交换机是一种网络设备，主要用于在局域网（LAN）内连接多台设备，并根据设备的MAC地址来转发数据帧。交换机的主要功能是提高网络性能和管理网络流量。与集线器（Hub）相比，交换机更智能，因为它能够根据数据帧的目标地址进行精确的转发，从而减少网络冲突和提高传输效率。</p>
<p><strong>交换机</strong>工作在<strong>数据链路层</strong>。</p>
<h3 id="6-10-物理层"><a href="#6-10-物理层" class="headerlink" title="6.10 物理层"></a>6.10 <strong>物理层</strong></h3><h4 id="6-10-1-相关概念"><a href="#6-10-1-相关概念" class="headerlink" title="6.10.1 相关概念"></a>6.10.1 <strong>相关概念</strong></h4><p><strong>1）</strong><em><strong>*传输介质*</strong></em></p>
<p>传输介质是用于在网络节点之间传输数据的物理通道。它是网络物理层的组成部分，直接影响数据传输的速度、距离和可靠性。传输介质分为有线和无线两大类。</p>
<p><strong>2）</strong><em><strong>*模拟信号（Analog Signal）*</strong></em></p>
<p>模拟信号是一种连续的信号，它在某一范围内可以取任何值。模拟信号的变化是连续的，与被表示的信息成比例。例如，声音信号是空气压力的连续变化，它可以被转换成相应的电压变化，形成模拟电信号。</p>
<p><strong>3）</strong><em><strong>*数字信号（Digital Signal）*</strong></em></p>
<p>数字信号是一种离散的信号，它只有特定的、离散的取值（通常是二进制的0和1）。数字信号表示的信息是以离散的时间间隔取样的，并且每个样本的值是离散的。</p>
<p><strong>4）</strong><em><strong>*编码（Encoding）*</strong></em></p>
<p>编码是将数据转换为适合传输或存储的格式。编码通常用于在数字信号之间进行转换，以提高数据传输的效率和可靠性。编码有多种类型，每种类型用于特定的应用和目的。如曼彻斯特编码、NRZ编码、4B&#x2F;5B编码等。</p>
<p><strong>5）</strong><em><strong>*信号调制（Modulation）*</strong></em></p>
<p>调制是将信号转换为适合在传输介质上传输的形式。调制通常用于将数字信号转换为模拟信号，以便通过无线电波、光纤或其他传输介质传输。调制通过改变载波信号的某些特性来表示数据。调制分为四种：调幅、调频、调相和正交振幅调制。</p>
<p><strong>6）</strong><em><strong>*带宽（Bandwidth）*</strong></em></p>
<p>带宽在网络通信中有两种主要解释，一种是指物理带宽，另一种是指有效带宽。</p>
<p>（1）物理带宽（频率带宽）</p>
<p>物理带宽是指传输介质能够传输的频率范围，通常以赫兹（Hz）为单位。它表示信道在某一时间内能够传输的信号频率范围。</p>
<p>（2）有效带宽（数据带宽）</p>
<p>有效带宽是指在一段时间内传输数据的最大速率，通常以比特每秒（bps）为单位。它表示传输介质或信道在单位时间内能够传输的最大数据量。</p>
<p><strong>7）</strong><em><strong>*物理拓扑（Physical Topology）*</strong></em></p>
<p>网络设备的物理布局和连接方式，如星型拓扑、环型拓扑、总线型拓扑和网状拓扑。</p>
<h4 id="6-10-2-物理层的职责"><a href="#6-10-2-物理层的职责" class="headerlink" title="6.10.2 物理层的职责"></a>6.10.2 <strong>物理层的职责</strong></h4><p>物理层是网络分层模型的最底层，其主要作用是负责在网络节点之间传输原始的比特流。它涉及实际的硬件和物理传输介质，并定义了数据在传输介质上的表示和传输方法。</p>
<p><strong>1）</strong><em><strong>*比特传输*</strong></em></p>
<p>将数据链路层生成的帧转换为适合传输介质的信号（如电信号、光信号或无线电波），并在接收端将信号还原为比特流。</p>
<p><strong>2）</strong><em><strong>*物理连接*</strong></em></p>
<p>提供计算机与网络之间的实际物理连接，包括电缆、连接器和接口。</p>
<p><strong>3）</strong><em><strong>*信号编码和调制*</strong></em></p>
<p>将数字比特流编码成适合传输介质的信号形式，例如曼彻斯特编码、NRZ编码、QAM调制等。</p>
<p><strong>4）</strong><em><strong>*数据速率控制*</strong></em></p>
<p>定义了数据传输速率（带宽），例如10Mbps、100Mbps、1Gbps等。</p>
<p><strong>5）</strong><em><strong>*传输模式*</strong></em></p>
<p>定义传输的模式，包括单工（单向传输）、半双工（双向但不能同时传输）和全双工（双向同时传输）。</p>
<p><strong>6）</strong><em><strong>*物理拓扑*</strong></em></p>
<p>规定了网络的物理布局，如星型、环型、总线型和网状拓扑。</p>
<h4 id="6-10-3-传输介质"><a href="#6-10-3-传输介质" class="headerlink" title="6.10.3 传输介质"></a>6.10.3 <strong>传输介质</strong></h4><p><strong>1）</strong><em><strong>*有线传输介质*</strong></em></p>
<p>（1）双绞线（Twisted Pair）</p>
<p>Ø 未屏蔽双绞线（UTP）：常用于以太网（如Cat5e、Cat6电缆）。</p>
<p>Ø 屏蔽双绞线（STP）：用于需要更高干扰防护的环境。</p>
<p>（2）同轴电缆（Coaxial Cable）</p>
<p>用于有线电视和早期的以太网。</p>
<p>（3）光纤（Optical Fiber）</p>
<p>Ø 单模光纤（SMF）：适用于长距离通信。</p>
<p>Ø 多模光纤（MMF）：适用于短距离通信。</p>
<p><strong>2）</strong><em><strong>*无线传输介质*</strong></em></p>
<p>（1）无线电波（Radio Waves）：用于Wi-Fi、蓝牙、Zigbee等。</p>
<p>（2）微波（Microwaves）：用于长距离通信和卫星通信。</p>
<p>（3）红外线（Infrared）：用于短距离设备间的通信，如遥控器。</p>
<h4 id="6-10-4-协议"><a href="#6-10-4-协议" class="headerlink" title="6.10.4 协议"></a>6.10.4 <strong>协议</strong></h4><p>IEEE802.3、IEEE802.4、IEEE802.5的物理层协议、RS-232、RS-485、RS-449、FDDI等。</p>
<h4 id="6-10-5-物理层硬件设备"><a href="#6-10-5-物理层硬件设备" class="headerlink" title="6.10.5 物理层硬件设备"></a>6.10.5 <strong>物理层硬件设备</strong></h4><p><strong>1）</strong><em><strong>*集线器（Hub）*</strong></em></p>
<p>集线器是一种基本的网络设备，用于将多个以太网设备连接在一起。它在所有连接的端口之间广播收到的比特流，所有端口共享同一信道，数据的冲突和碰撞频繁发生，效率低下，逐渐被交换机取代。</p>
<p><strong>2）</strong><em><strong>*调制解调器（Modem）*</strong></em></p>
<p>将数字信号转换为模拟信号（调制），或将模拟信号转换回数字信号（解调）。</p>
<p><strong>3）</strong><em><strong>*光纤收发器（Fiber Optic Transceiver）*</strong></em></p>
<p>用于在光纤通信系统中发送和接收光信号。它将电信号转换为光信号，并将光信号转换回电信号。通常用在长距离的数据传输中，用于扩展光纤网络的传输距离。</p>
<p><strong>4）</strong><em><strong>*光猫（Optical Network Terminal）*</strong></em></p>
<p>光猫是光纤接入终端设备，通常用于家庭和小型办公室，连接光纤服务提供商的网络与用户的内部网络。</p>
<p><strong>5）</strong><em><strong>*中继器（Repeater）*</strong></em></p>
<p>用于延长网络信号的传输距离。它接收、放大并重新发送信号，以补偿信号衰减。常用于扩展有线网络覆盖范围，特别是在长距离连接中。</p>
<h1 id="第-7-章-守护进程和I-O多路复用"><a href="#第-7-章-守护进程和I-O多路复用" class="headerlink" title="第 7 章 守护进程和I&#x2F;O多路复用"></a>第 7 章 <strong>守护进程和I&#x2F;O多路复用</strong></h1><p>在&#x2F;home&#x2F;atguigu目录下创建daemon_and_multiplex目录，本章的所有测试例程均置于该目录下。</p>
<h3 id="7-1-守护进程"><a href="#7-1-守护进程" class="headerlink" title="7.1 守护进程"></a>7.1 <strong>守护进程</strong></h3><h4 id="7-1-1-定义"><a href="#7-1-1-定义" class="headerlink" title="7.1.1 定义"></a>7.1.1 <strong>定义</strong></h4><p>守护进程是在操作系统后台运行的一种特殊类型的进程，它独立于前台用户界面，不与任何终端设备直接关联。这些进程通常在系统启动时启动，并持续运行直到系统关闭，或者它们完成其任务并自行终止。守护进程通常用于服务请求、管理系统或执行周期性任务。</p>
<h4 id="7-1-2-控制终端"><a href="#7-1-2-控制终端" class="headerlink" title="7.1.2 控制终端"></a>7.1.2 <strong>控制终端</strong></h4><p>控制终端是与会话关联的终端设备，它是用户输入和输出的通道。进程通常通过其控制终端与用户交互，接收输入和向用户显示输出。对于守护进程来说，它必须从任何控制终端中脱离，确保其独立于任何用户会话在后台运行，这样才能保证其稳定性和安全性，不受用户直接控制和会话结束等事件的影响。</p>
<h4 id="7-1-3-编程规则"><a href="#7-1-3-编程规则" class="headerlink" title="7.1.3 编程规则"></a>7.1.3 <strong>编程规则</strong></h4><p><strong>1）</strong><em><strong>*创建子进程并结束父进程*</strong></em></p>
<p>在UNIX和类UNIX系统中，进程是通过复制（使用fork()）创建的。守护进程需要在后台独立运行。</p>
<p><strong>2）</strong><em><strong>*设置会话ID*</strong></em></p>
<p>setsid()创建一个新会话，并使调用它的进程成为新会话的领导者，这样做的主要目的是让守护进程摆脱原来的控制终端。这样，守护进程就不会接收到终端发出的任何信号，例如挂断信号（SIGHUP），从而保证其运行不受前台用户操作的影响。</p>
<p><strong>3）</strong><em><strong>*第二次fork()*</strong></em></p>
<p>使得守护进程不是会话领导，没有获取控制终端的能力，避免意外获取控制终端。</p>
<p><strong>4）</strong><em><strong>*更改工作目录*</strong></em></p>
<p>将工作目录更改到根目录(&#x2F;)，主要是为了避免守护进程继续占用其启动时的文件系统。这对于可移动的或网络挂载的文件系统尤其重要，确保这些文件系统不需要时可以被卸载。</p>
<p><strong>5）</strong><em><strong>*重设文件权限掩码*</strong></em></p>
<p>调用umask(0)确保守护进程创建的文件权限不受继承的umask值的影响，守护进程可以更精确地控制其创建的文件和目录的权限。</p>
<p><strong>6）</strong><em><strong>*关闭文件描述符*</strong></em></p>
<p>守护进程通常不需要标准输入、输出和错误文件描述符，因为它们不与终端交互。关闭这些不需要的文件描述符可以避免资源泄露，提高守护进程的安全性和效率。</p>
<p><strong>7）</strong><em><strong>*处理信号*</strong></em></p>
<p>SIGHUP和SIGTERM信号。</p>
<p>SIGHUP：虽然守护进程和终端断开，但仍然有可能收到其它进程或内核发来的SIGHUP信号，守护进程不应该因为它而终止。</p>
<p>SIGTERM：SIGTERM信号是终止信号，用于请求守护进程优雅地终止。通过命令行执行kill <pid>命令可以发送SIGTERM信号，接收到这个信号之后，守护进程终止子进程，并清理回收资源，最后退出。</p>
<p><strong>8）</strong><em><strong>*执行具体任务*</strong></em></p>
<p>这一步是守护进程的核心，它开始执行为其设计的特定功能，如监听网络请求、定期清理文件系统、执行系统备份等。</p>
<h4 id="7-1-4-相关系统调用和库函数"><a href="#7-1-4-相关系统调用和库函数" class="headerlink" title="7.1.4 相关系统调用和库函数"></a>7.1.4 <strong>相关系统调用和库函数</strong></h4><p><strong>1）</strong><em><strong>*setsid*</strong></em></p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 如果调用进程不是进程组的领导者，则创建一个新的会话。创建者是新会话的领导者</p>
<p> * </p>
<p> * @return pid_t 成功则返回调用进程的新会话ID，失败则返回(pid_t)-1，并设置errno以指明错误原因</p>
<p> *&#x2F;</p>
<p>pid_t setsid(void);</p>
<p><strong>2）</strong><em><strong>*umask*</strong></em></p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 设置调用进程的文件模式创建掩码。</p>
<p> * </p>
<p> * @param mask 掩码。是一个八进制数，它指定哪些权限位在文件或目录创建时应被关闭。我们通过umask(0)确保守护进程创建的文件和目录具有最开放的权限设置。</p>
<p> * @return mode_t 这个系统调用必然成功，返回之前的掩码值</p>
<p> *&#x2F;</p>
<p>mode_t umask(mode_t mask);</p>
<p><strong>3）</strong><em><strong>*chdir*</strong></em></p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 更改调用进程的工作目录</p>
<p> * </p>
<p> * @param path 更改后的工作路径</p>
<p> * @return int 成功返回0，失败返回-1，并设置errno</p>
<p> *&#x2F;</p>
<p>int chdir(const char *path);</p>
<p><strong>4）</strong><em><strong>*openlog*</strong></em></p>
<p>#include &lt;syslog.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 为程序开启一个面向系统日志的连接</p>
<p> * </p>
<p> * @param ident 每条消息的字符串前缀，按照惯例通常设置为程序名称</p>
<p> * @param option option：指定控制 openlog 和后续 syslog 调用的标志。常见标志包括：</p>
<p> *  LOG_PID：在每条日志消息中包含进程ID。</p>
<p> *  LOG_CONS：如果无法将消息发送到日志守护进程，则直接将消息写入控制台。</p>
<p> *  LOG_NDELAY：立即打开与系统日志守护进程的连接。</p>
<p> *  LOG_ODELAY：延迟打开与系统日志守护进程的连接，直到实际写入日志时。</p>
<p> *  LOG_PERROR：将日志消息同时输出到标准错误输出。</p>
<p> * @param facility facility：指定日志消息的来源类别，用于区分系统不同部分的日志消息。包括：</p>
<p> *  LOG_AUTH：认证系统</p>
<p> *  LOG_CRON：cron 和 at 调度守护进程</p>
<p> *  LOG_DAEMON：系统守护进程</p>
<p> *  LOG_KERN：内核消息</p>
<p> *  LOG_LOCAL0 至 LOG_LOCAL7：本地使用</p>
<p> *  LOG_MAIL：邮件系统</p>
<p> *  LOG_SYSLOG：syslog 自身的消息</p>
<p> *  LOG_USER：用户进程</p>
<p> *  LOG_UUCP：UUCP 子系统</p>
<p> *&#x2F;</p>
<p>void openlog(const char *ident, int option, int facility);</p>
<p><strong>5）</strong><em><strong>*syslog*</strong></em></p>
<p>#include &lt;syslog.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 生成一条日志消息</p>
<p> * </p>
<p> * @param priority 由一个facility和一个level值或操作得到，如果未指定facility，则使用openlog指定的默认值，如果上文没有调用openlog()，则将使用默认值LOG_USER。level取值如下</p>
<p> *  LOG_EMERG（系统无法使用）表示系统已经不可用，通常用于严重的紧急情况。例如：系统崩溃或关键硬件故障。</p>
<p> *  LOG_ALERT（必须立即采取行动）表示必须立即采取措施解决的问题。例如：磁盘空间用尽或数据库崩溃。</p>
<p> *  LOG_CRIT（严重条件）表示严重的错误或问题，但不需要立即采取行动。例如：应用程序的某个重要功能失败。</p>
<p> *  LOG_ERR（错误条件）表示一般错误情况，需要注意和修复。例如：无法打开文件或网络连接失败。</p>
<p> *  LOG_WARNING（警告条件）表示潜在问题或警告，建议检查，但不会立即影响系统功能。例如：磁盘空间接近用尽或配置文件缺失。</p>
<p> *  LOG_NOTICE（正常但重要的情况）表示正常运行过程中需要特别注意的事件。例如：系统启动或关闭成功。</p>
<p> *  LOG_INFO（信息性消息）表示一般信息，用于记录正常操作的事件。例如：用户登录或定时任务完成。</p>
<p> *  LOG_DEBUG（调试级别消息）表示详细的调试信息，通常用于开发和调试阶段。例如：函数调用跟踪或变量值变化。</p>
<p> * @param format 类似于printf()的格式化字符串</p>
<p> * @param … 可变参数，可以传递给格式化字符串</p>
<p> *&#x2F;</p>
<p>void syslog(int priority, const char *format, …);</p>
<p><strong>6）</strong><em><strong>*closelog*</strong></em></p>
<p>#include &lt;syslog.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 关闭用于写入系统日志的文件描述符</p>
<p> * </p>
<p> *&#x2F;</p>
<p>void closelog(void);</p>
<p><strong>7）</strong><em><strong>*sysconf*</strong></em></p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 获取运行时配置信息</p>
<p> * </p>
<p> * @param name 配置名称，取值太多，可以通过 man 3 sysconf 自行查阅，我们只用到_SC_OPEN_MAX，记录了当前进程可以打开的文件描述符的最大数量</p>
<p> * @return long 配置的值</p>
<p> *&#x2F;</p>
<p>long sysconf(int name);</p>
<h4 id="7-1-5-测试案例"><a href="#7-1-5-测试案例" class="headerlink" title="7.1.5 测试案例"></a>7.1.5 <strong>测试案例</strong></h4><p><strong>1）</strong><em><strong>*创建daemon_test.c*</strong></em></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;syslog.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>pid_t pid;</p>
<p>int is_shutdown &#x3D; 0;</p>
<p>void signal_handler(int sig)</p>
<p>{</p>
<p>  switch (sig)</p>
<p>  {</p>
<p>  case SIGHUP:</p>
<p>​    syslog(LOG_WARNING, “收到SIGHUP信号…”);</p>
<p>​    break;</p>
<p>  case SIGTERM:</p>
<p>​    syslog(LOG_NOTICE, “接收到终止信号，准备退出守护进程…”);</p>
<p>​    syslog(LOG_NOTICE, “向子进程发送SIGTERM信号…”);</p>
<p>​    is_shutdown &#x3D; 1;</p>
<p>​    kill(pid, SIGTERM);</p>
<p>​    break;</p>
<p>  default:</p>
<p>​    syslog(LOG_INFO, “Received unhandled signal”);</p>
<p>  }</p>
<p>}</p>
<p>void my_daemonize()</p>
<p>{</p>
<p>  pid_t pid;</p>
<p>  &#x2F;&#x2F; Fork off the parent process</p>
<p>  pid &#x3D; fork();</p>
<p>  if (pid &lt; 0)</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  if (pid &gt; 0)</p>
<p>​    exit(EXIT_SUCCESS);</p>
<p>  if (setsid() &lt; 0)</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  &#x2F;&#x2F; 处理 SIGHUP、SIGTERM 信号</p>
<p>  signal(SIGHUP, signal_handler);</p>
<p>  signal(SIGTERM, signal_handler);</p>
<p>  pid &#x3D; fork();</p>
<p>  if (pid &lt; 0)</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  if (pid &gt; 0)</p>
<p>​    exit(EXIT_SUCCESS);</p>
<p>  &#x2F;&#x2F; 重置umask</p>
<p>  umask(0);</p>
<p>  &#x2F;&#x2F; 将工作目录切换为根目录</p>
<p>  chdir(“&#x2F;“);</p>
<p>  &#x2F;&#x2F; 关闭所有打开的文件描述符</p>
<p>  for (int x &#x3D; 0; x &lt;&#x3D; sysconf(_SC_OPEN_MAX); x++)</p>
<p>  {</p>
<p>​    close(x);</p>
<p>  }</p>
<p>  openlog(“this is our daemonize process: “, LOG_PID, LOG_DAEMON);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  my_daemonize();</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    pid &#x3D; fork();</p>
<p>​    if (pid &gt; 0)</p>
<p>​    {</p>
<p>​      syslog(LOG_INFO, “守护进程正在监听服务端进程…”);</p>
<p>​      waitpid(-1, NULL, 0);</p>
<p>​      if (is_shutdown) {</p>
<p>​        syslog(LOG_NOTICE, “子进程已被回收，即将关闭syslog连接，守护进程退出”);</p>
<p>​        closelog();</p>
<p>​        exit(EXIT_SUCCESS);</p>
<p>​      }</p>
<p>​      syslog(LOG_ERR, “服务端进程终止，3s后重启…”);</p>
<p>​      sleep(3);</p>
<p>​    }</p>
<p>​    else if (pid &#x3D;&#x3D; 0)</p>
<p>​    {</p>
<p>​      syslog(LOG_INFO, “子进程fork成功”);</p>
<p>​      syslog(LOG_INFO, “启动服务端进程”);</p>
<p>​      char *path &#x3D; “&#x2F;home&#x2F;atguigu&#x2F;daemon_and_multiplex&#x2F;tcp_server”;</p>
<p>​      char *argv[] &#x3D; {“my_tcp_server”, NULL};</p>
<p>​      errno &#x3D; 0;</p>
<p>​      execve(path, argv, NULL);</p>
<p>​      char buf[1024];</p>
<p>​      sprintf(buf, “errno: %d”, errno);</p>
<p>​      syslog(LOG_ERR, “%s”, buf);</p>
<p>​      syslog(LOG_ERR, “服务端进程启动失败”);</p>
<p>​      exit(EXIT_FAILURE);</p>
<p>​    }</p>
<p>​    else</p>
<p>​    {</p>
<p>​      syslog(LOG_ERR, “子进程fork失败”);</p>
<p>​    }</p>
<p>  }</p>
<p>  return EXIT_SUCCESS;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*创建tcp_server.c*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>#include &lt;syslog.h&gt;</p>
<p>int sockfd;</p>
<p>void zombie_dealer(int sig)</p>
<p>{</p>
<p>  pid_t pid;</p>
<p>  int status;</p>
<p>  char buf[1024];</p>
<p>  memset(buf, 0, 1024);</p>
<p>  &#x2F;&#x2F; 一个SIGCHLD可能对应多个子进程的退出</p>
<p>  &#x2F;&#x2F; 使用while循环回收所有退出的子进程，避免僵尸进程的出现</p>
<p>  while ((pid &#x3D; waitpid(-1, &amp;status, WNOHANG)) &gt; 0)</p>
<p>  {</p>
<p>​    if (WIFEXITED(status))</p>
<p>​    {</p>
<p>​      sprintf(buf, “子进程: %d 以 %d 状态正常退出，已被回收\n”, pid, WEXITSTATUS(status));</p>
<p>​      syslog(LOG_INFO, “%s”, buf);</p>
<p>​    }</p>
<p>​    else if (WIFSIGNALED(status))</p>
<p>​    {</p>
<p>​      sprintf(buf, “子进程: %d 被 %d 信号杀死，已被回收\n”, pid, WTERMSIG(status));</p>
<p>​      syslog(LOG_INFO, “%s”, buf);</p>
<p>​    }</p>
<p>​    else</p>
<p>​    {</p>
<p>​      sprintf(buf, “子进程: %d 因其它原因退出，已被回收\n”, pid);</p>
<p>​      syslog(LOG_WARNING, “%s”, buf);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>void sigterm_handler(int sig) {</p>
<p>  syslog(LOG_NOTICE, “服务端接收到守护进程发出的SIGTERM，准备退出…”);</p>
<p>  syslog(LOG_NOTICE, “释放sockfd”);</p>
<p>  close(sockfd);</p>
<p>  syslog(LOG_NOTICE, “释放syslog连接，服务端进程终止”);</p>
<p>  closelog();</p>
<p>  &#x2F;&#x2F; 退出</p>
<p>  exit(EXIT_SUCCESS);</p>
<p>}</p>
<p>void read_from_client_then_write(void *argv)</p>
<p>{</p>
<p>  int client_fd &#x3D; *(int *)argv;</p>
<p>  ssize_t count &#x3D; 0, send_count &#x3D; 0;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  char log_buf[1024];</p>
<p>  memset(log_buf, 0, 1024);</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    sprintf(log_buf, “服务端pid: %d: 读缓存创建异常，断开连接\n”, getpid());</p>
<p>​    syslog(LOG_ERR, “%s”, log_buf);</p>
<p>​    shutdown(client_fd, SHUT_WR);</p>
<p>​    close(client_fd);</p>
<p>​    return;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    sprintf(log_buf, “服务端pid: %d: 写缓存创建异常，断开连接\n”, getpid());</p>
<p>​    syslog(LOG_ERR, “%s”, log_buf);</p>
<p>​    free(read_buf);</p>
<p>​    shutdown(client_fd, SHUT_WR);</p>
<p>​    close(client_fd);</p>
<p>​    return;</p>
<p>  }</p>
<p>  while ((count &#x3D; recv(client_fd, read_buf, 1024, 0)))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      syslog(LOG_ERR, “server recv error”);</p>
<p>​    }</p>
<p>​    sprintf(log_buf, “服务端pid: %d: reveive message from client_fd: %d: %s”, getpid(), client_fd, read_buf);</p>
<p>​    syslog(LOG_INFO, “%s”, log_buf);</p>
<p>​    memset(log_buf, 0, 1024);</p>
<p>​    sprintf(write_buf, “服务端pid: %d: reveived~\n”, getpid());</p>
<p>​    send_count &#x3D; send(client_fd, write_buf, 1024, 0);</p>
<p>  }</p>
<p>  sprintf(log_buf, “服务端pid: %d: 客户端client_fd: %d请求关闭连接……\n”, getpid(), client_fd);</p>
<p>  syslog(LOG_NOTICE, “%s”, log_buf);</p>
<p>  sprintf(write_buf, “服务端pid: %d: receive your shutdown signal\n”, getpid());</p>
<p>  send_count &#x3D; send(client_fd, write_buf, 1024, 0);</p>
<p>  sprintf(log_buf, “服务端pid: %d: 释放client_fd: %d资源\n”, getpid(), client_fd);</p>
<p>  syslog(LOG_NOTICE, “%s”, log_buf);</p>
<p>  shutdown(client_fd, SHUT_WR);</p>
<p>  close(client_fd);</p>
<p>  free(read_buf);</p>
<p>  free(write_buf);</p>
<p>  return;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int temp_result;</p>
<p>  struct sockaddr_in server_addr, client_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;client_addr, 0, sizeof(client_addr));</p>
<p>  &#x2F;&#x2F; 声明IPV4通信协议</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 我们需要绑定0.0.0.0地址，转换成网络字节序后完成设置</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</p>
<p>  &#x2F;&#x2F; 端口随便用一个，但是不要用特权端口</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建server socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  &#x2F;&#x2F; 绑定地址</p>
<p>  temp_result &#x3D; bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  &#x2F;&#x2F; 进入监听模式</p>
<p>  temp_result &#x3D; listen(sockfd, 128);</p>
<p>  socklen_t cliaddr_len &#x3D; sizeof(client_addr);</p>
<p>  &#x2F;&#x2F; 注册信号处理函数，处理SIGCHLD信号，避免僵尸进程出现</p>
<p>  signal(SIGCHLD, zombie_dealer);</p>
<p>  &#x2F;&#x2F; 处理SIGTERM函数，以优雅退出</p>
<p>  signal(SIGTERM, sigterm_handler);</p>
<p>  char log_buf[1024];</p>
<p>  memset(log_buf, 0, 1024);</p>
<p>  &#x2F;&#x2F; 接受client连接</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    int client_fd &#x3D; accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;cliaddr_len);</p>
<p>​    pid_t pid &#x3D; fork();</p>
<p>​    if (pid &gt; 0)</p>
<p>​    {</p>
<p>​      sprintf(log_buf, “this is father, pid is %d, continue accepting…\n”, getpid());</p>
<p>​      syslog(LOG_INFO, “%s”, log_buf);</p>
<p>​      memset(log_buf, 0, 1024);</p>
<p>​      &#x2F;&#x2F; 父进程不需要处理client_fd，释放文件描述符，使其引用计数减一，以便子进程释放client_fd后，其引用计数可以减为0,从而释放资源</p>
<p>​      close(client_fd);</p>
<p>​    }</p>
<p>​    else if (pid &#x3D;&#x3D; 0)</p>
<p>​    {</p>
<p>​      &#x2F;&#x2F; 子进程不需要处理sockfd，释放文件描述符，使其引用计数减一</p>
<p>​      close(sockfd);</p>
<p>​      sprintf(log_buf, “与客户端 from %s at PORT %d 文件描述符 %d 建立连接\n”, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), client_fd);</p>
<p>​      syslog(LOG_INFO, “%s”, log_buf);</p>
<p>​      memset(log_buf, 0, 1024);</p>
<p>​      sprintf(log_buf, “新的服务端pid为: %d\n”, getpid());</p>
<p>​      syslog(LOG_INFO, “%s”, log_buf);</p>
<p>​      memset(log_buf, 0, 1024);</p>
<p>​      &#x2F;&#x2F; 读取客户端数据，并打印到 stdout</p>
<p>​      read_from_client_then_write((void *)&amp;client_fd);</p>
<p>​      &#x2F;&#x2F; 释放资源并终止子进程</p>
<p>​      close(client_fd);</p>
<p>​      exit(EXIT_SUCCESS);</p>
<p>​    }</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>3）</strong><em><strong>*tcp_client.c*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    return -1;         \</p>
<p>  }</p>
<p>void *read_from_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *read_buf &#x3D; NULL;</p>
<p>  ssize_t count &#x3D; 0;</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    perror(“malloc client read_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (count &#x3D; recv(sockfd, read_buf, 1024, 0))</p>
<p>  {</p>
<p>​    if (count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“recv”);</p>
<p>​    }</p>
<p>​    fputs(read_buf, stdout);</p>
<p>  }</p>
<p>  printf(“收到服务端的终止信号……\n”);</p>
<p>  free(read_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>void *write_to_server(void *argv)</p>
<p>{</p>
<p>  int sockfd &#x3D; *(int *)argv;</p>
<p>  char *write_buf &#x3D; NULL;</p>
<p>  ssize_t send_count;</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * 1024);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“写缓存申请异常，断开连接\n”);</p>
<p>​    shutdown(sockfd, SHUT_WR);</p>
<p>​    perror(“malloc client write_buf”);</p>
<p>​    return NULL;</p>
<p>  }</p>
<p>  while (fgets(write_buf, 1024, stdin) !&#x3D; NULL)</p>
<p>  {</p>
<p>​    send(sockfd, write_buf, 1024, 0);</p>
<p>​    if (send_count &lt; 0)</p>
<p>​    {</p>
<p>​      perror(“send”);</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“接收到命令行的终止信号，不再写入，关闭连接……\n”);</p>
<p>  shutdown(sockfd, SHUT_WR);</p>
<p>  free(write_buf);</p>
<p>  return NULL;</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  int sockfd, temp_result;</p>
<p>  pthread_t pid_read, pid_write;</p>
<p>  struct sockaddr_in server_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 连接本机 127.0.0.1</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_LOOPBACK);</p>
<p>  &#x2F;&#x2F; 连接端口 6666</p>
<p>  server_addr.sin_port &#x3D; htons(6666);</p>
<p>  &#x2F;&#x2F; 创建socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 连接server</p>
<p>  temp_result &#x3D; connect(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“connect”, temp_result);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来读取服务端数据，并打印到 stdout</p>
<p>  pthread_create(&amp;pid_read, NULL, read_from_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 启动一个子线程，用来从命令行读取数据并发送到服务端</p>
<p>  pthread_create(&amp;pid_write, NULL, write_to_server, (void *)&amp;sockfd);</p>
<p>  &#x2F;&#x2F; 主线程等待子线程退出</p>
<p>  pthread_join(pid_read, NULL);</p>
<p>  pthread_join(pid_write, NULL);</p>
<p>  printf(“关闭资源\n”);</p>
<p>  close(sockfd);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>4）</strong><em><strong>*Makefile*</strong></em></p>
<p>.PHONY: tcp_clean</p>
<p>tcp_executables:&#x3D;tcp_server tcp_client</p>
<p>CC:&#x3D;gcc</p>
<p>tcp_server: tcp_server.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>tcp_client: tcp_client.c</p>
<p>  $(CC) -o $@ $^</p>
<p>tcp_clean:</p>
<p>  -rm .&#x2F;$(word 1, $(tcp_executables)) .&#x2F;$(word 2, $(tcp_executables))</p>
<p>daemon_test: daemon_test.c tcp_clean tcp_server tcp_client</p>
<p>  -$(CC) -o $@ $&lt;</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>5）</strong><em><strong>*运行*</strong></em></p>
<p>（1）监控系统日志文件</p>
<p>当前Linux系统的系统日志文件路径为&#x2F;var&#x2F;log&#x2F;syslog，命令行执行以下命令。</p>
<p>atguigu@ubuntu:~$ tail -F &#x2F;var&#x2F;log&#x2F;syslog</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps212.jpg" alt="img"> </p>
<p>（2）在Makefile中运行daemon_test目标</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps213.jpg" alt="img"> </p>
<p>查看日志</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps214.jpg" alt="img"> </p>
<p>（3）命令行查看进程</p>
<p>atguigu@ubuntu:~$ ps -ef</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps215.jpg" alt="img"> </p>
<p>（4）启动客户端</p>
<p>在新的XShell标签页中执行以下命令</p>
<p>atguigu@ubuntu:~&#x2F;daemon_and_multiplex$ .&#x2F;tcp_client</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps216.jpg" alt="img"> </p>
<p>（5）客户端发送数据</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps217.jpg" alt="img"> </p>
<p>（6）客户端Ctrl+D发送终止符</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps218.jpg" alt="img"> </p>
<p>（7）杀掉服务端进程</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps219.jpg" alt="img"> </p>
<p>（8）3s后查看</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps220.jpg" alt="img"> </p>
<p>查看进程，服务端已被重启。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps221.jpg" alt="img"> </p>
<p>（9）优雅关闭守护进程</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps222.jpg" alt="img"> </p>
<p>再次查看进程列表，守护进程已退出。</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps223.jpg" alt="img"> </p>
<h3 id="7-2-I-O多路复用"><a href="#7-2-I-O多路复用" class="headerlink" title="7.2 I&#x2F;O多路复用"></a>7.2 <strong>I&#x2F;O多路复用</strong></h3><h4 id="7-2-1-什么是I-O多路复用"><a href="#7-2-1-什么是I-O多路复用" class="headerlink" title="7.2.1 什么是I&#x2F;O多路复用"></a>7.2.1 <strong>什么是I&#x2F;O多路复用</strong></h4><p>上文我们介绍了两种服务端接收多个TCP连接的实现方式：分别基于多线程和多进程实现。我们知道，进程和线程的创建都是有开销的，如果需要同时维护上万连接，这两种方式都是扛不住的。此时，需要使用更加节省资源、更加高效的方式：I&#x2F;O多路复用。</p>
<p><strong>1）</strong><em><strong>*定义*</strong></em></p>
<p>IO多路复用（I&#x2F;O Multiplexing）是Linux中用于处理多个I&#x2F;O操作的机制，使得单个线程或进程可以同时监视多个文件描述符，以处理多路I&#x2F;O请求。它主要通过以下系统调用实现：select、poll 和 epoll。</p>
<p><strong>2）</strong><em><strong>*实现机制*</strong></em></p>
<p>select：select 是早期的IO多路复用机制，它允许程序监视多个文件描述符，判断是否可以进行I&#x2F;O操作。程序通过提供三个文件描述符集（读、写、异常）和一个超时时间来调用select，在任何一个文件描述符变得可读、可写或出现错误时返回。</p>
<p>poll：poll 与 select 类似，但它使用一个包含文件描述符和事件的结构数组来代替三个文件描述符集。它可以处理更多文件描述符，并且更容易管理。</p>
<p>epoll：epoll 是 Linux 特有的、性能优化的 I&#x2F;O 多路复用机制。它比 select 和 poll 更高效，特别适用于大规模并发连接。epoll 提供了两种工作模式：水平触发（Level-Triggered, LT）和边沿触发（Edge-Triggered, ET）。ET 模式下，epoll 只在状态变化时通知，因此更高效，但也更复杂。</p>
<p><strong>3）</strong><em><strong>*作用和意义*</strong></em></p>
<p>（1）节省资源：IO多路复用允许单个进程或线程同时监视多个文件描述符，而不是为每个I&#x2F;O操作创建一个线程或进程。只需要维护文件描述符，极大地提高了节约了资源，减少了系统开销。</p>
<p>（2）效率高：使用IO多路复用省去了进程或线程上下文切换的开销，提升了处理效率，减少了系统资源（如内存和CPU时间）的消耗，从而提高了应用程序的整体性能和响应速度。</p>
<p>（3）简化编程模型：尽管IO多路复用增加了代码的复杂性，但它简化了高并发程序的设计，使得程序员可以更容易地管理多个I&#x2F;O操作，而不必处理大量的线程同步问题。</p>
<p><strong>4）</strong><em><strong>*应用场景*</strong></em></p>
<p>（1）网络服务器：例如HTTP服务器、FTP服务器等需要同时处理大量客户端请求的场景。</p>
<p>（2）聊天系统：实时聊天应用程序需要高效地管理多个用户的消息。</p>
<p>（3）监控系统：例如日志监控、数据库连接池管理等需要同时监视多个输入源的系统。</p>
<p>IO多路复用是Linux系统中处理多路I&#x2F;O操作的重要技术，它通过提高资源利用率和系统性能，为开发高效、高并发的应用程序提供了强大的支持。</p>
<p>select和poll底层都是基于线性结构实现的，需要对文件描述符集执行多次遍历和拷贝，效率低下，而epoll底层是基于红黑树（一种平衡二叉树）实现的，且通过维护就绪事件链表，效率更高，本文只介绍epoll。</p>
<h4 id="7-2-2-相关系统调用及数据类型"><a href="#7-2-2-相关系统调用及数据类型" class="headerlink" title="7.2.2 相关系统调用及数据类型"></a>7.2.2 <strong>相关系统调用及数据类型</strong></h4><p><strong>1）</strong><em><strong>*边缘触发和水平触发*</strong></em></p>
<p>在 epoll 的使用中，有两种事件触发模式：边缘触发（Edge Triggered, ET）和水平触发（Level Triggered, LT）。这两种模式决定了 epoll 如何通知应用程序有事件发生。可以类比单片机的边缘触发和电平触发。</p>
<p>水平触发是epoll的默认模式。在这种模式下，只要文件描述符上有未处理的事件，epoll就会不断通知应用程序。</p>
<p>边缘触发模式下，当文件描述符从未就绪状态变为就绪状态时，epoll 会通知应用程序。如果应用程序没有在通知后及时处理事件（例如，读出所有可读的数据），epoll 不会再次通知，除非文件描述符再次从未就绪变为就绪状态。即只在状态变化时通知一次，因而叫边缘触发。</p>
<p><strong>2）</strong><em><strong>*epoll_data*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief 记录内核需要存储的epoll实例相关数据的联合体。fd可用来存储文件描述符。</p>
<p> * </p>
<p> *&#x2F;</p>
<p>typedef union epoll_data {</p>
<p>void     *ptr;</p>
<p>int      fd;</p>
<p>uint32_t   u32;</p>
<p>uint64_t   u64;</p>
<p>} epoll_data_t;</p>
<p><strong>3）</strong><em><strong>*epoll_event*</strong></em></p>
<p>&#x2F;**</p>
<p> * @brief epoll实例维护了一个文件描述符的集合，称为感兴趣列表，这个列表中的文件描述符会被监听，并在就绪时被加入就绪链表。感兴趣列表存储的是文件描述符和struct epoll_event结构体实例组成的entry。</p>
<p> * events: 需要监听的就绪事件，是由以下0或更多事件类型或操作得到的：EPOLLIN、EPOLLOUT、EPOLLRDHUP、EPOLLPRI、EPOLLERR、EPOLLHUP、EPOLLET、EPOLLONESHOT、EPOLLWAKEUP、EPOLLEXCLUSIVE。下面的案例中我们只会用到EPOLLIN、EPOLLET</p>
<p> *  EPOLLIN: epoll_event实例相关联的文件描述符可用于读操作</p>
<p> *  EPOLLET: 将关联的文件描述符设置为边缘触发模式</p>
<p> * data: 指明内核应该存储并在文件描述符就绪时返回的数据</p>
<p> *&#x2F;</p>
<p>struct epoll_event {</p>
<p>uint32_t   events;    &#x2F;* Epoll events *&#x2F;</p>
<p>epoll_data_t data;     &#x2F;* User data variable *&#x2F;</p>
<p>};</p>
<p><strong>4）</strong><em><strong>*epoll_create*</strong></em></p>
<p>#include &lt;sys&#x2F;epoll.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief epoll创建一个新的epoll实例。</p>
<p> * </p>
<p> * @param size 从Linux内核2.6.8版本开始（当前Ubuntu系统版本为6.5.0）该参数被忽略，但是必须大于0</p>
<p> * @return int 成功返回指向新的epoll实例的文件描述符，失败返回-1并设置errno指明错误原因</p>
<p> *&#x2F;</p>
<p>int epoll_create(int size);</p>
<p><strong>5）</strong><em><strong>*epoll_createl*</strong></em></p>
<p>#include &lt;sys&#x2F;epoll.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 如果传入的flags参数为0，则与epoll_create完成的工作相同。</p>
<p> * </p>
<p> * @param flags 标记以获得不同的行为，可以是EPOLL_CLOEXEC，该标记将创建的epoll实例的文件描述符标记为close-on-exec。</p>
<p> * @return int 成功返回指向新的epoll实例的文件描述符，失败返回-1并设置errno指明错误原因</p>
<p> *&#x2F;</p>
<p>int epoll_create1(int flags);</p>
<p><strong>6）</strong><em><strong>*epoll_ctl*</strong></em></p>
<p>#include &lt;sys&#x2F;epoll.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief epoll_ctl提供了对fd和event组成的entry执行增、删、改操作的方式。</p>
<p> * </p>
<p> * @param epfd epoll实例的文件描述符</p>
<p> * @param op 对文件描述符执行的操作</p>
<p> *  EPOLL_CTL_ADD: 将fd和event组成的entry添加到感兴趣列表</p>
<p> *  EPOLL_CTL_MOD: 将感兴趣列表中与fd关联的event替换为此处传入的event</p>
<p> *  EPOLL_CTL_DEL: 从感兴趣列表删除与fd关联的entry，此时event被忽略</p>
<p> * @param fd 待处理的文件描述符</p>
<p> * @param event fd关联的描述信息。</p>
<p> * @return int 成功返回0，失败返回-1，并设置errno以指明错误原因</p>
<p> *&#x2F;</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p><strong>7）</strong><em><strong>*epoll_wait*</strong></em></p>
<p>#include &lt;sys&#x2F;epoll.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 等待epfd指向的epoll实例感兴趣列表中的事件发生。</p>
<p> * </p>
<p> * @param epfd epoll实例文件描述符</p>
<p> * @param events 提供给内核，用于返回已就绪的文件描述符信息</p>
<p> * @param maxevents 可以返回的最大文件描述符数量</p>
<p> * @param timeout 超时时间，指明epoll_wait()在事件触发前阻塞等待的最大毫秒数。</p>
<p> *         -1表示一直等待至有事件发生，0表示无论是否有事件发生立即返回。</p>
<p> * @return int 成功返回就绪的文件描述符数量，超时时间耗尽仍没有就绪事件返回0。失败则返回-1，并设置errno指明错误原因</p>
<p> *&#x2F;</p>
<p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</p>
<p><strong>8）</strong><em><strong>*fcntl*</strong></em></p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>&#x2F;**</p>
<p> * @brief 对fd指向的文件描述符执行cmd指明的操作。</p>
<p> * </p>
<p> * @param fd 文件描述符</p>
<p> * @param cmd 执行的操作，很多，此处不一一列出，常用的有F_GETFL和F_SETFL</p>
<p> *  F_GETFL: 返回文件的权限模式和状态标记，不需要额外的参数</p>
<p> *  F_SETFL: 将文件的状态标记设置为第三个参数指定的值</p>
<p> * @param … cmd需要的参数，可以没有</p>
<p> * @return int 如果是F_GETFL，成功则返回文件状态标记值，如果是F_SETFL成功返回0。失败均返回-1，同时设置errno指明错误原因</p>
<p> *&#x2F;</p>
<p>int fcntl(int fd, int cmd, …);</p>
<h4 id="7-2-3-测试例程"><a href="#7-2-3-测试例程" class="headerlink" title="7.2.3 测试例程"></a>7.2.3 <strong>测试例程</strong></h4><p><strong>1）</strong><em><strong>*创建*</strong></em><em><strong>*epoll_test.c*</strong></em></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;epoll.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>#define SEVER_PORT 6666</p>
<p>#define BUFFER_SIZE 1024</p>
<p>#define MAX_EVENTS 10</p>
<p>#define handle_error(cmd, result) \</p>
<p>  if (result &lt; 0)        \</p>
<p>  {               \</p>
<p>​    perror(cmd);        \</p>
<p>​    exit(EXIT_FAILURE);    \</p>
<p>  }</p>
<p>char *read_buf &#x3D; NULL;</p>
<p>char *write_buf &#x3D; NULL;</p>
<p>void init_buf()</p>
<p>{</p>
<p>  read_buf &#x3D; malloc(sizeof(char) * BUFFER_SIZE);</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  if (!read_buf)</p>
<p>  {</p>
<p>​    printf(“服务端读缓存创建异常，断开连接\n”);</p>
<p>​    perror(“malloc sever read_buf”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 判断内存是否分配成功</p>
<p>  write_buf &#x3D; malloc(sizeof(char) * BUFFER_SIZE);</p>
<p>  if (!write_buf)</p>
<p>  {</p>
<p>​    printf(“服务端写缓存创建异常，断开连接\n”);</p>
<p>​    free(read_buf);</p>
<p>​    perror(“malloc server write_buf”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  memset(read_buf, 0, BUFFER_SIZE);</p>
<p>  memset(write_buf, 0, BUFFER_SIZE);</p>
<p>}</p>
<p>void clear_buf(char *buf)</p>
<p>{</p>
<p>  memset(buf, 0, BUFFER_SIZE);</p>
<p>}</p>
<p>void set_nonblocking(int sockfd)</p>
<p>{</p>
<p>  int opts &#x3D; fcntl(sockfd, F_GETFL);</p>
<p>  if (opts &lt; 0)</p>
<p>  {</p>
<p>​    perror(“fcntl(F_GETFL)”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>  opts |&#x3D; O_NONBLOCK;</p>
<p>  int res &#x3D; fcntl(sockfd, F_SETFL, opts);</p>
<p>  if (res &lt; 0)</p>
<p>  {</p>
<p>​    perror(“fcntl(F_SETFL)”);</p>
<p>​    exit(EXIT_FAILURE);</p>
<p>  }</p>
<p>}</p>
<p>int main(int argc, char const *argv[])</p>
<p>{</p>
<p>  init_buf();</p>
<p>  &#x2F;&#x2F; 声明sockfd、clientfd和函数返回状态变量</p>
<p>  int sockfd, client_fd, temp_result;</p>
<p>  &#x2F;&#x2F; 声明服务端和客户端地址</p>
<p>  struct sockaddr_in server_addr, client_addr;</p>
<p>  memset(&amp;server_addr, 0, sizeof(server_addr));</p>
<p>  memset(&amp;client_addr, 0, sizeof(client_addr));</p>
<p>  &#x2F;&#x2F; 声明IPV4通信协议</p>
<p>  server_addr.sin_family &#x3D; AF_INET;</p>
<p>  &#x2F;&#x2F; 我们需要绑定0.0.0.0地址，转换成网络字节序后完成设置</p>
<p>  server_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</p>
<p>  &#x2F;&#x2F; 端口随便用一个，但是不要用特权端口</p>
<p>  server_addr.sin_port &#x3D; htons(SEVER_PORT);</p>
<p>  &#x2F;&#x2F; 创建server socket</p>
<p>  sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  handle_error(“socket”, sockfd);</p>
<p>  &#x2F;&#x2F; 绑定地址</p>
<p>  temp_result &#x3D; bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));</p>
<p>  handle_error(“bind”, temp_result);</p>
<p>  &#x2F;&#x2F; 进入监听模式</p>
<p>  temp_result &#x3D; listen(sockfd, 128);</p>
<p>  handle_error(“listen”, temp_result);</p>
<p>  &#x2F;&#x2F; 将sockfd设置为非阻塞模式</p>
<p>  set_nonblocking(sockfd);</p>
<p>  int epollfd, nfds;</p>
<p>  struct epoll_event ev, events[MAX_EVENTS];</p>
<p>  epollfd &#x3D; epoll_create1(0);</p>
<p>  handle_error(“epoll_createl”, epollfd);</p>
<p>  ev.data.fd &#x3D; sockfd;</p>
<p>  ev.events &#x3D; EPOLLIN;</p>
<p>  temp_result &#x3D; epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</p>
<p>  handle_error(“epoll_ctl”, temp_result);</p>
<p>  socklen_t cliaddr_len &#x3D; sizeof(client_addr);</p>
<p>  &#x2F;&#x2F; 接受client连接</p>
<p>  while (1)</p>
<p>  {</p>
<p>​    nfds &#x3D; epoll_wait(epollfd, events, MAX_EVENTS, -1);</p>
<p>​    handle_error(“epoll_wait”, nfds);</p>
<p>​    for (int i &#x3D; 0; i &lt; nfds; i++)</p>
<p>​    {</p>
<p>​      if (events[i].data.fd &#x3D;&#x3D; sockfd)</p>
<p>​      {</p>
<p>​        client_fd &#x3D; accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;cliaddr_len);</p>
<p>​        handle_error(“accept”, client_fd);</p>
<p>​        set_nonblocking(client_fd);</p>
<p>​        printf(“与客户端 from %s at PORT %d 文件描述符 %d 建立连接\n”,</p>
<p>​            inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), client_fd);</p>
<p>​        ev.data.fd &#x3D; client_fd;</p>
<p>​        ev.events &#x3D; EPOLLIN | EPOLLET;</p>
<p>​        epoll_ctl(epollfd, EPOLL_CTL_ADD, client_fd, &amp;ev);</p>
<p>​      }</p>
<p>​      else if (events[i].events &amp; EPOLLIN)</p>
<p>​      {</p>
<p>​        int count &#x3D; 0, send_count &#x3D; 0;</p>
<p>​        client_fd &#x3D; events[i].data.fd;</p>
<p>​        while ((count &#x3D; recv(client_fd, read_buf, BUFFER_SIZE, 0)) &gt; 0)</p>
<p>​        {</p>
<p>​          printf(“reveive message from client_fd: %d: %s\n”, client_fd, read_buf);</p>
<p>​          clear_buf(read_buf);</p>
<p>​          strcpy(write_buf, “reveived~\n”);</p>
<p>​          send_count &#x3D; send(client_fd, write_buf, strlen(write_buf), 0);</p>
<p>​          handle_error(“send”, send_count);</p>
<p>​          clear_buf(write_buf);</p>
<p>​        }</p>
<p>​        if (count &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EAGAIN)</p>
<p>​        {</p>
<p>​          printf(“来自客户端client_fd: %d当前批次的数据已读取完毕，继续监听文件描述符集\n”, client_fd);</p>
<p>​        }</p>
<p>​        else if (count &#x3D;&#x3D; 0)</p>
<p>​        {</p>
<p>​          printf(“客户端client_fd: %d请求关闭连接……\n”, client_fd);</p>
<p>​          strcpy(write_buf, “receive your shutdown signal\n”);</p>
<p>​          send_count &#x3D; send(client_fd, write_buf, strlen(write_buf), 0);</p>
<p>​          handle_error(“send”, send_count);</p>
<p>​          clear_buf(write_buf);</p>
<p>​          &#x2F;&#x2F; 从epoll文件描述符集中移除client_fd</p>
<p>​          printf(“从epoll文件描述符集中移除client_fd: %d\n”, client_fd);</p>
<p>​          epoll_ctl(epollfd, EPOLL_CTL_DEL, client_fd, NULL);</p>
<p>​          printf(“释放client_fd: %d资源\n”, client_fd);</p>
<p>​          shutdown(client_fd, SHUT_WR);</p>
<p>​          close(client_fd);</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>  printf(“释放资源\n”);</p>
<p>  close(epollfd);</p>
<p>  close(sockfd);</p>
<p>  free(read_buf);</p>
<p>  free(write_buf);</p>
<p>  return 0;</p>
<p>}</p>
<p><strong>2）</strong><em><strong>*Makefile*</strong></em></p>
<p>epoll_test: epoll_test.c</p>
<p>  -$(CC) -o $@ $^</p>
<p>  -.&#x2F;$@</p>
<p>  -rm .&#x2F;$@</p>
<p><strong>3）</strong><em><strong>*运行*</strong></em></p>
<p>（1）启动epoll_test</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps224.jpg" alt="img"> </p>
<p>（2）启动客户端并发送数据</p>
<p>客户端例程使用上文的tcp_client</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps225.jpg" alt="img"> </p>
<p>（3）客户端断开连接</p>
<p><img src="file:///D:\Users\badboy\AppData\Local\Temp\ksohtml1284\wps226.jpg" alt="img"> </p>
<p>我们通过epoll，只用单线程完成了之前需要多线程或多进程才可以完成的事情。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">joy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/26/6-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B9%8BLinux%E5%BA%94%E7%94%A8%E5%B1%82%E5%BC%80%E5%8F%91/">http://example.com/2024/09/26/6-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B9%8BLinux%E5%BA%94%E7%94%A8%E5%B1%82%E5%BC%80%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/05/3-c%E5%92%8C%E6%8C%87%E9%92%88/" title="3-c和指针"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">3-c和指针</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/17/5-Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="5-Linux中常用指令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">5-Linux中常用指令</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">joy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-Linux%E4%B8%8B%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">第 1 章 Linux下的C语言开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-GCC%E3%80%81glibc%E5%92%8CGNU-C%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.1 GCC、glibc和GNU C的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-GCC"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.1.1 GCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-glibc"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">1.1.2 glibc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-GNU-C"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">1.1.3 GNU C</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">1.1.4 三者之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-POSIX"><span class="toc-number">1.0.2.</span> <span class="toc-text">1.2 POSIX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AE%89%E8%A3%85IDE%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.0.3.</span> <span class="toc-text">1.3 安装IDE编程环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AE%89%E8%A3%85gcc"><span class="toc-number">1.0.4.</span> <span class="toc-text">1.4 安装gcc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E8%AE%BE%E7%BD%AE%E4%BD%BF%E7%94%A8VS"><span class="toc-number">1.0.5.</span> <span class="toc-text">1.5 设置使用VS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E5%90%AF%E5%8A%A8VSCode"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">1.5.1 启动VSCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E4%BF%AE%E6%94%B9%E4%B8%BA%E4%B8%AD%E6%96%87%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">1.5.2 修改为中文（可选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E4%BF%AE%E6%94%B9%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">1.5.3 修改页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">1.5.4 安装扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDVS%EF%BC%88%E5%85%88%E5%88%AB%E9%80%89%EF%BC%89"><span class="toc-number">1.0.6.</span> <span class="toc-text">1.6 彻底卸载VS（先别选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.7.</span> <span class="toc-text">1.7 C语言编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">1.7.1 预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E7%BC%96%E8%AF%91"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">1.7.2 编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-%E6%B1%87%E7%BC%96"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">1.7.3 汇编</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-4-%E9%93%BE%E6%8E%A5"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">1.7.4 链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-Makefile%E5%9F%BA%E7%A1%80"><span class="toc-number">1.0.8.</span> <span class="toc-text">1.8 Makefile基础</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E6%96%87%E4%BB%B6I-O"><span class="toc-number">2.</span> <span class="toc-text">第 2 章 文件I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-C%E6%A0%87%E5%87%86I-O%E5%BA%93%E5%87%BD%E6%95%B0%E5%9B%9E%E9%A1%BE"><span class="toc-number">2.0.1.</span> <span class="toc-text">2.1 C标准I&#x2F;O库函数回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%89%93%E5%BC%80-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">2.1.1 打开&#x2F;关闭文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">2.1.2 向文件中写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">2.1.3 从文件中读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-%E9%94%99%E8%AF%AF"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">2.1.4 标准输入&#x2F;输出&#x2F;错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.2 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">2.2.1 关于系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%B8%B8%E8%A7%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">2.2.2 常见系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">2.2.3 综合案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.0.3.</span> <span class="toc-text">2.3 文件描述符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第 3 章 进程处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Linux%E8%BF%9B%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">3.1 Linux进程简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">3.1.1 什么是进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E4%BD%BF%E7%94%A8system%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">3.1.2 使用system函数生成子进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.0.2.</span> <span class="toc-text">3.2 进程处理相关系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-C%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%84main%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">3.2.1 C标准中的main函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-fork"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">3.2.2 fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%92%8Cclose"><span class="toc-number">3.0.2.3.</span> <span class="toc-text">3.2.3 文件描述符的引用计数和close()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-execve"><span class="toc-number">3.0.2.4.</span> <span class="toc-text">3.2.4 execve</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-wait-pid"><span class="toc-number">3.0.2.5.</span> <span class="toc-text">3.2.5 wait****pid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E8%BF%9B%E7%A8%8B%E6%A0%91"><span class="toc-number">3.0.2.6.</span> <span class="toc-text">3.2.6 进程树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.0.2.7.</span> <span class="toc-text">3.2.7 孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.3 进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-SystemV-IPC%E5%92%8CPOSIX-IPC"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">1.1.1 SystemV IPC和POSIX IPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">1.1.2 匿名管道（Pipe）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">3.0.3.3.</span> <span class="toc-text">3.3.1 有名管道（FIFO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">3.0.3.4.</span> <span class="toc-text">3.3.2 共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.0.3.5.</span> <span class="toc-text">3.3.3 消息队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.0.4.</span> <span class="toc-text">3.4 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E4%BF%A1%E5%8F%B7%E7%AE%80%E4%BB%8B"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">3.4.1 信号简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%BE%8B%E7%A8%8B"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">3.4.2 信号处理例程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第 4 章 线程处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Linux%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">4.1 Linux线程简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.0.2.</span> <span class="toc-text">4.2 线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">4.2.1 线程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">4.2.2 线程终止</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-1-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.2.2.1.</span> <span class="toc-text">4.2.2.1 相关函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-2-%E6%B5%8B%E8%AF%95%E4%BE%8B%E7%A8%8B"><span class="toc-number">4.0.2.2.2.</span> <span class="toc-text">4.2.2.2 测试例程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.0.3.</span> <span class="toc-text">4.3 线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E5%92%8C%E9%94%81"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">4.3.1 竞态条件和锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">4.0.3.2.</span> <span class="toc-text">4.3.2 互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">4.0.3.3.</span> <span class="toc-text">4.3.3 读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.0.3.3.1.</span> <span class="toc-text">4.3.3.1 工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-2-%E7%9B%B8%E5%85%B3%E8%B0%83%E7%94%A8"><span class="toc-number">4.0.3.3.2.</span> <span class="toc-text">4.3.3.2 相关调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-3-%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%8D%E5%8A%A0%E9%94%81%E6%B5%8B%E8%AF%95"><span class="toc-number">4.0.3.3.3.</span> <span class="toc-text">4.3.3.3 写操作不加锁测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-4-%E5%86%99%E6%93%8D%E4%BD%9C%E6%B7%BB%E5%8A%A0%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">4.0.3.3.4.</span> <span class="toc-text">4.3.3.4 写操作添加读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-5-%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%9A%8F%E6%9C%BA"><span class="toc-number">4.0.3.3.5.</span> <span class="toc-text">4.3.3.5 读写操作执行顺序随机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-6-%E5%86%99%E9%A5%A5%E9%A5%BF%E6%B5%8B%E8%AF%95"><span class="toc-number">4.0.3.3.6.</span> <span class="toc-text">4.3.3.6 写饥饿测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.0.3.4.</span> <span class="toc-text">4.3.4 自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">4.0.3.5.</span> <span class="toc-text">4.3.5 条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.0.3.6.</span> <span class="toc-text">4.3.6 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-1-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">4.0.3.6.1.</span> <span class="toc-text">4.3.6.1 信号量相关概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-2-%E6%97%A0%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.0.3.6.2.</span> <span class="toc-text">4.3.6.2 无名信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-3-%E6%9C%89%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.0.3.6.3.</span> <span class="toc-text">4.3.6.3 有名信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-4-%E5%85%B3%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">4.0.3.6.4.</span> <span class="toc-text">4.3.6.4 关于信号量的总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.0.4.</span> <span class="toc-text">4.4 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">4.4.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-Glib%E5%BA%93"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">4.4.2 Glib库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-Glib%E5%BA%93%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.0.4.3.</span> <span class="toc-text">4.4.3 Glib库线程池工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.0.4.4.</span> <span class="toc-text">4.4.4 相关数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.4.5.</span> <span class="toc-text">4.4.5 相关函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-6-%E6%B5%8B%E8%AF%95%E4%BE%8B%E7%A8%8B"><span class="toc-number">4.0.4.6.</span> <span class="toc-text">4.4.6 测试例程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第 5 章 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82"><span class="toc-number">5.0.1.</span> <span class="toc-text">5.1 计算机系统的软件分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.0.2.</span> <span class="toc-text">5.2 进程和程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">5.0.3.</span> <span class="toc-text">5.3 进程控制块PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.0.4.</span> <span class="toc-text">5.4 进程的内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">5.4.1 内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.4.2.</span> <span class="toc-text">5.4.2 相关概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">5.0.5.</span> <span class="toc-text">5.5 进程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">5.0.5.1.</span> <span class="toc-text">5.5.1 CPU虚拟化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-CPU%E8%B0%83%E5%BA%A6"><span class="toc-number">5.0.5.2.</span> <span class="toc-text">5.5.2 CPU调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-3-%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.0.5.3.</span> <span class="toc-text">5.5.3 抽象的进程状态模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-4-Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.0.5.4.</span> <span class="toc-text">5.5.4 Linux进程状态实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-5-%E4%BA%8C%E8%80%85%E7%9A%84%E7%BB%9F%E4%B8%80"><span class="toc-number">5.0.5.5.</span> <span class="toc-text">5.5.5 二者的统一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-6-%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-number">5.0.5.6.</span> <span class="toc-text">5.5.6 调度队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">5.0.6.</span> <span class="toc-text">5.6 虚拟内存和物理内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-%E6%A1%88%E4%BE%8B"><span class="toc-number">5.0.6.1.</span> <span class="toc-text">5.6.1 案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">5.0.6.2.</span> <span class="toc-text">5.6.2 虚拟内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-3-%E5%86%8D%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">5.0.6.3.</span> <span class="toc-text">5.6.3 再看进程共享存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="toc-number">5.0.7.</span> <span class="toc-text">5.7 异常和中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.7.1.</span> <span class="toc-text">5.7.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.0.7.2.</span> <span class="toc-text">5.7.2 中断和异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-3-%E6%A1%88%E4%BE%8B"><span class="toc-number">5.0.7.3.</span> <span class="toc-text">5.7.3 案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">5.0.8.</span> <span class="toc-text">5.8 进程创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-1-%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.0.8.1.</span> <span class="toc-text">5.8.1 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">5.0.8.2.</span> <span class="toc-text">5.8.2 进程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-3-ps%E5%91%BD%E4%BB%A4"><span class="toc-number">5.0.8.3.</span> <span class="toc-text">5.8.3 ps命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-4-%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-number">5.0.8.4.</span> <span class="toc-text">5.8.4 进程组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">5.0.9.</span> <span class="toc-text">5.9 进程切换过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-1-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">5.0.9.1.</span> <span class="toc-text">5.9.1 进程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-2-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.0.9.2.</span> <span class="toc-text">5.9.2 进程上下文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">5.0.10.</span> <span class="toc-text">5.10 系统调用和库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.0.11.</span> <span class="toc-text">5.11 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-1-%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.0.11.1.</span> <span class="toc-text">5.11.1 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-2-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">5.0.11.2.</span> <span class="toc-text">5.11.2 线程和进程的区别与联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.0.11.3.</span> <span class="toc-text">5.11.3 线程的特点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-Socket-%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">第 6 章 Socket****编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.0.1.</span> <span class="toc-text">6.1 计算机网络的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E6%8C%89%E5%9C%B0%E7%90%86%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">6.1.1 按地理范围分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E6%8C%89%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%88%86%E7%B1%BB"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">6.1.2 按网络拓扑分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-%E6%8C%89%E7%BD%91%E7%BB%9C%E7%94%A8%E9%80%94%E5%88%86%E7%B1%BB"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">6.1.3 按网络用途分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-%E6%8C%89%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB"><span class="toc-number">6.0.1.4.</span> <span class="toc-text">6.1.4 按网络的交换技术分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-5-%E6%8C%89%E7%BD%91%E7%BB%9C%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">6.0.1.5.</span> <span class="toc-text">6.1.5 按网络的通信方式分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.0.2.</span> <span class="toc-text">6.2 计算机网络分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">6.2.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">6.2.2 OSI七层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.0.2.3.</span> <span class="toc-text">6.2.3 五层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.0.2.4.</span> <span class="toc-text">6.2.4 TCP&#x2F;IP四层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94%E4%BB%A5%E5%8F%8ATCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">6.0.2.5.</span> <span class="toc-text">6.2.5 OSI七层模型和TCP&#x2F;IP四层模型对比以及TCP&#x2F;IP协议栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-6-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83"><span class="toc-number">6.0.2.6.</span> <span class="toc-text">6.2.6 网络传输中的数据单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-7-%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.2.7.</span> <span class="toc-text">6.2.7 基于以太网的通信流程示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-8-%E6%9C%8D%E5%8A%A1%E3%80%81%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.0.2.8.</span> <span class="toc-text">6.2.8 服务、协议和接口的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.0.3.</span> <span class="toc-text">6.3 传输层-TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E4%BB%80%E4%B9%88%E6%98%AFTCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.0.3.1.</span> <span class="toc-text">6.3.1 什么是TCP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">6.0.3.2.</span> <span class="toc-text">6.3.2 TCP协议的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.0.3.3.</span> <span class="toc-text">6.3.3 TCP报文段格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-TCP%E7%8A%B6%E6%80%81"><span class="toc-number">6.0.3.4.</span> <span class="toc-text">6.3.4 TCP状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-5-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">6.0.3.5.</span> <span class="toc-text">6.3.5 TCP连接的建立和释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-6-TCP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">6.0.3.6.</span> <span class="toc-text">6.3.6 TCP数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-6-1-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%BF%9D%E9%9A%9C"><span class="toc-number">6.0.3.6.1.</span> <span class="toc-text">6.3.6.1 可靠传输保障</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-6-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">6.0.3.6.2.</span> <span class="toc-text">6.3.6.2 滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-6-3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">6.0.3.6.3.</span> <span class="toc-text">6.3.6.3 拥塞控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-6-4-%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3"><span class="toc-number">6.0.3.6.4.</span> <span class="toc-text">6.3.6.4 发送窗口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-7-TCP%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.3.7.</span> <span class="toc-text">6.3.7 TCP开发常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-8-%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E5%8C%96"><span class="toc-number">6.0.3.8.</span> <span class="toc-text">6.3.8 网络字节序和主机字节序转化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.0.4.</span> <span class="toc-text">6.4 传输层-基于TCP协议的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E5%8F%AA%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%8C%83%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.0.4.1.</span> <span class="toc-text">6.4.1 只接受一个连接的范例程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E5%85%B3%E4%BA%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">6.0.4.2.</span> <span class="toc-text">6.4.2 关于缓冲区的补充说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%8F%8A%E6%96%AD%E5%BC%80%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">6.0.4.3.</span> <span class="toc-text">6.4.3 连接建立及断开过程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%94%AF%E6%8C%81%E5%A4%9A%E4%B8%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%8C%83%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.0.4.4.</span> <span class="toc-text">6.4.4 服务端基于多线程的支持多个连接的范例程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%94%AF%E6%8C%81%E5%A4%9A%E4%B8%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%8C%83%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.0.4.5.</span> <span class="toc-text">6.4.5 服务端基于多进程的支持多个连接的范例程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.0.5.</span> <span class="toc-text">6.5 传输层-基于UDP协议的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1-UDP-%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">6.0.5.1.</span> <span class="toc-text">6.5.1 UDP****通讯流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-UDP%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.5.2.</span> <span class="toc-text">6.5.2 UDP开发常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3-%E8%8C%83%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.0.5.3.</span> <span class="toc-text">6.5.3 范例程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-U-nix-Domain-Socket-IPC"><span class="toc-number">6.0.6.</span> <span class="toc-text">6.6 U****nix Domain Socket IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.0.6.1.</span> <span class="toc-text">6.6.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-%E5%A5%97%E6%8E%A5%E5%AD%97-%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%B4%E6%98%8E"><span class="toc-number">6.0.6.2.</span> <span class="toc-text">6.6.2 套接字****地址结构体说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-%E8%8C%83%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.0.6.3.</span> <span class="toc-text">6.6.3 范例程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E7%BD%91%E7%BB%9C%E5%B1%82-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.0.7.</span> <span class="toc-text">6.7 网络层-IP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.0.7.1.</span> <span class="toc-text">6.7.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-IP%E5%9C%B0%E5%9D%80"><span class="toc-number">6.0.7.2.</span> <span class="toc-text">6.7.2 IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-IP%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC"><span class="toc-number">6.0.7.3.</span> <span class="toc-text">6.7.3 IP协议版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-4-IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">6.0.7.4.</span> <span class="toc-text">6.7.4 IP地址分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-5-%E7%BD%91%E7%BB%9C%E5%B1%82%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="toc-number">6.0.7.5.</span> <span class="toc-text">6.7.5 网络层硬件设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E5%BA%94%E7%94%A8%E5%B1%82-DNS%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.0.8.</span> <span class="toc-text">6.8 应用层-DNS协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.0.8.1.</span> <span class="toc-text">6.8.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-2-%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84DNS%E6%9F%A5%E8%AF%A2%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.8.2.</span> <span class="toc-text">6.8.2 一个典型的DNS查询示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">6.0.9.</span> <span class="toc-text">6.9 数据链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-1-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">6.0.9.1.</span> <span class="toc-text">6.9.1 主要功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-2-MAC%E5%9C%B0%E5%9D%80"><span class="toc-number">6.0.9.2.</span> <span class="toc-text">6.9.2 MAC地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-3-ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.0.9.3.</span> <span class="toc-text">6.9.3 ARP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-4-RARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.0.9.4.</span> <span class="toc-text">6.9.4 RARP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-5-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="toc-number">6.0.9.5.</span> <span class="toc-text">6.9.5 数据链路层硬件设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">6.0.10.</span> <span class="toc-text">6.10 物理层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">6.0.10.1.</span> <span class="toc-text">6.10.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-2-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-number">6.0.10.2.</span> <span class="toc-text">6.10.2 物理层的职责</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-3-%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">6.0.10.3.</span> <span class="toc-text">6.10.3 传输介质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-4-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.0.10.4.</span> <span class="toc-text">6.10.4 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-5-%E7%89%A9%E7%90%86%E5%B1%82%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="toc-number">6.0.10.5.</span> <span class="toc-text">6.10.5 物理层硬件设备</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8CI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">第 7 章 守护进程和I&#x2F;O多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.0.1.</span> <span class="toc-text">7.1 守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">7.1.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">7.1.2 控制终端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E7%BC%96%E7%A8%8B%E8%A7%84%E5%88%99"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">7.1.3 编程规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">7.0.1.4.</span> <span class="toc-text">7.1.4 相关系统调用和库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-5-%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B"><span class="toc-number">7.0.1.5.</span> <span class="toc-text">7.1.5 测试案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">7.0.2.</span> <span class="toc-text">7.2 I&#x2F;O多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E4%BB%80%E4%B9%88%E6%98%AFI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">7.2.1 什么是I&#x2F;O多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">7.2.2 相关系统调用及数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-%E6%B5%8B%E8%AF%95%E4%BE%8B%E7%A8%8B"><span class="toc-number">7.0.2.3.</span> <span class="toc-text">7.2.3 测试例程</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/26/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/" title="一生一芯">一生一芯</a><time datetime="2024-11-26T09:33:35.380Z" title="Created 2024-11-26 17:33:35">2024-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/18/4-ubuntu%2018.04%E5%BF%AB%E9%80%9F%E9%87%8D%E5%BC%80/" title="4-Ubuntu 18.04快速重开">4-Ubuntu 18.04快速重开</a><time datetime="2024-11-18T08:42:20.323Z" title="Created 2024-11-18 16:42:20">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/18/2-Altium%20Designer24/" title="2-Altium Designer24">2-Altium Designer24</a><time datetime="2024-11-18T08:36:36.333Z" title="Created 2024-11-18 16:36:36">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/05/3-c%E5%92%8C%E6%8C%87%E9%92%88/" title="3-c和指针">3-c和指针</a><time datetime="2024-10-05T01:08:40.601Z" title="Created 2024-10-05 09:08:40">2024-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/26/6-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B9%8BLinux%E5%BA%94%E7%94%A8%E5%B1%82%E5%BC%80%E5%8F%91/" title="6-尚硅谷嵌入式技术之Linux应用层开发">6-尚硅谷嵌入式技术之Linux应用层开发</a><time datetime="2024-09-26T01:48:58.379Z" title="Created 2024-09-26 09:48:58">2024-09-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By joy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>